[
    {
        "id": "f313dfa39a2c857c",
        "type": "tab",
        "label": "Master 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "11aec64be1c40451",
        "type": "tab",
        "label": "Simulated_Value",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "4b39492785a70ee0",
        "type": "tab",
        "label": "CR_EM01",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "f586f2e111bf806e",
        "type": "tab",
        "label": "NR-PPC",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "022b4db85aaf3abc",
        "type": "tab",
        "label": "INFLUX",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "cfa8980ee5e33ee0",
        "type": "tab",
        "label": "UI",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "80362ddefbe410fa",
        "type": "tab",
        "label": "inverter",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "fa01649a1ca3ae29",
        "type": "group",
        "z": "cfa8980ee5e33ee0",
        "name": "CREATE TABLE",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.8"
        },
        "nodes": [
            "50c293361ea9bb22",
            "150c3bbf6a1d05dc",
            "ef2838e3b3fde275"
        ],
        "x": 154,
        "y": 39,
        "w": 612,
        "h": 82
    },
    {
        "id": "478bc90ac909f00b",
        "type": "group",
        "z": "cfa8980ee5e33ee0",
        "name": "GET UI VALUES",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.8"
        },
        "nodes": [
            "2333360a287e0b32",
            "26b96cfb55df4d4b",
            "7fabc85b65e936a1",
            "f597a5e258ae9b12",
            "d75c0ff270881800",
            "ea8196cb99badea9",
            "84e16ed7825c2cbb",
            "4d7763e8022ffcd8",
            "5459e514e8b5a62b",
            "15d49f5162b870be",
            "abd0ab318a561745"
        ],
        "x": 154,
        "y": 179,
        "w": 1092,
        "h": 222
    },
    {
        "id": "05347136fb00c7d9",
        "type": "group",
        "z": "4b39492785a70ee0",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.8"
        },
        "nodes": [
            "96094fc9f5efa4e3",
            "37d74194d7301759",
            "fdbb12fc0a0c8b82",
            "b4d640bbb7acfba7",
            "ea61ce8c309d4463",
            "4822620155dd3b83",
            "0477b598e74358e0",
            "486e599ed79766d4",
            "a567c7b11e2b064a",
            "fd1584fe6fb4e127",
            "1349b8f032394075",
            "b4132fc61efb6b69",
            "8de1850f5dd7a6c6",
            "8c04ece3f20a202e",
            "a6b1eb06764e7070",
            "77d6b1485d0adb94",
            "15e394cd5841fb46",
            "0aeb8086ddc12feb",
            "5e832def27c0c32c",
            "a40795473a414b38"
        ],
        "x": 74,
        "y": 79,
        "w": 1212,
        "h": 282
    },
    {
        "id": "70b4b74643b43e4d",
        "type": "group",
        "z": "4b39492785a70ee0",
        "name": "VR_EM",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.8"
        },
        "nodes": [
            "771553536fa6e867",
            "71c351d6db2e5069",
            "bcaba8d066cd2f1c",
            "89b8caeb7bf75231",
            "7c24b68999756557",
            "3a7ff75fe5885c37",
            "5c5dfd1214f6eb71",
            "fef6f6558f828198",
            "a447db7b7c32988e",
            "061b018f3220f837",
            "b5cadf4d42acbf20",
            "2215dc8e90fe8340",
            "f4b6fea2c0b367b3",
            "c371db16c6ddfc63",
            "a9a60f45cfc5f6b4",
            "5f69d3fe91aaa12a",
            "e2ddcba055f3ba35",
            "c912072e049a3d50",
            "a3a896235b7b6594",
            "c55502568dab5dc7",
            "a73fc44f850f7471",
            "658aa85031b9bce7",
            "ef9c4d9ad4ba10de",
            "8cde8087405ef1ec"
        ],
        "x": 74,
        "y": 399,
        "w": 992,
        "h": 382
    },
    {
        "id": "048fc7bc2feb5fda",
        "type": "group",
        "z": "f313dfa39a2c857c",
        "name": "MQTT_REC_FROM_ENGINE",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.8"
        },
        "nodes": [
            "73460dc9bc32c56a",
            "4829a5ec24a43bb7",
            "dfb7880d117d569f",
            "30607a38eac50efb",
            "2bf2d718bcd5124c",
            "a95d2b7f8e7eda14",
            "be55ee41073e2b8f",
            "ca473a81103b480e",
            "6bd0562bc27918d9",
            "497111be4e6b67e2",
            "5d53606328303e16",
            "c7e73ddbf6cdd7e9"
        ],
        "x": 94,
        "y": 459,
        "w": 532,
        "h": 322
    },
    {
        "id": "18882cf9eafa39f8",
        "type": "group",
        "z": "f313dfa39a2c857c",
        "name": "MQTT_SEND_TO_ENGINE",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.8"
        },
        "nodes": [
            "7e06dde20744b4e5",
            "09728be7255809a1",
            "cc69ec99eb343c90",
            "86f58beb437e5149"
        ],
        "x": 714,
        "y": 459,
        "w": 552,
        "h": 122
    },
    {
        "id": "2e078411276e5df3",
        "type": "group",
        "z": "f313dfa39a2c857c",
        "name": "MQTT_SEND_FOR_REMOTE ON/OFF",
        "style": {
            "label": true,
            "color": "#000000",
            "stroke": "#777777",
            "fill": "#d1d1d1",
            "fill-opacity": "0.8"
        },
        "nodes": [
            "d064234a989b3b38",
            "02340cc8d02f1ab1",
            "f95a42d91f64ed9b",
            "0c27b454767bbf24"
        ],
        "x": 714,
        "y": 619,
        "w": 532,
        "h": 122
    },
    {
        "id": "257560a04a2bc470",
        "type": "junction",
        "z": "80362ddefbe410fa",
        "x": 280,
        "y": 620,
        "wires": [
            [
                "d1e5bf16732b7474",
                "2a2af41d1cd1833b",
                "1f52a9acd9b2ff35",
                "3303e42c564f15c8",
                "c6bddf61ca9a4465",
                "e54d9475624344a6"
            ]
        ]
    },
    {
        "id": "d915c9c1a6d72b81",
        "type": "junction",
        "z": "80362ddefbe410fa",
        "x": 320,
        "y": 1460,
        "wires": [
            [
                "8da8c14545bcd873",
                "60e00691273fe229",
                "b8de61775ac4d413",
                "64e5a8d63c0144e0",
                "3cb5d42be39adf6b",
                "6742ce984b0fc171"
            ]
        ]
    },
    {
        "id": "851107da290de35c",
        "type": "junction",
        "z": "80362ddefbe410fa",
        "x": 300,
        "y": 2540,
        "wires": [
            [
                "49c0ba223121158e",
                "fe0e3deac079a4c4",
                "6cb28b3b888b225e",
                "16d4618452eed414",
                "a68f65a400d0bb6e",
                "65dbaf0bf02b9d63",
                "fbec6f33d846e1a3",
                "b01d3895ea64c04a"
            ]
        ]
    },
    {
        "id": "0bfb55e4fe9e8595",
        "type": "junction",
        "z": "022b4db85aaf3abc",
        "d": true,
        "x": 1320,
        "y": 580,
        "wires": [
            [
                "e69079d4b5604113",
                "7cffef28a8101585",
                "7331c5e5ad375a29",
                "55fc38f89dee5d66",
                "d2142368d002d173",
                "1bcd29a88050ea0d",
                "dadca73176035e8e",
                "f554b5f5d0f517ca",
                "89b0cb330816e810",
                "10479e1eee7321b5"
            ]
        ]
    },
    {
        "id": "ca9f285f3d2548b1",
        "type": "junction",
        "z": "022b4db85aaf3abc",
        "x": 260,
        "y": 240,
        "wires": [
            [
                "243a8a5aa5b35074",
                "dd4548453e36f348",
                "aa11794099c189a6",
                "cf726ac01251ee6b",
                "3460298c36b5fddf"
            ]
        ]
    },
    {
        "id": "927d0201185d8226",
        "type": "junction",
        "z": "022b4db85aaf3abc",
        "x": 1080,
        "y": 260,
        "wires": [
            [
                "bfe2f380fa390c7b"
            ]
        ]
    },
    {
        "id": "6900a3972037d1fd",
        "type": "mqtt-broker",
        "name": "",
        "broker": "localhost",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "659036d37402c930",
        "type": "mqtt-broker",
        "name": "",
        "broker": "localhost",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "e39e6931f56bee45",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.50.2",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": 2000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "508bd054a75cba90",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.50.3",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": 2000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "44a7947291c9227a",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.49.2",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": 2000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "8473ea32a5d8f50e",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.49.3",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": "2000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e8257c92c5ac9def",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.46.2",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": "2000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "bbb7096bb7e73e42",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.46.3",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": "2000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "cd9af449ab56d106",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.31.2",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": 2000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": false,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "842e03518674f086",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.31.3",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": 2000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "0795889e0c58f9c0",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.47.2",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": "2000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "c63b7c3157e71798",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "172.16.47.3",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 50,
        "clientTimeout": "2000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": 200,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "262dfd1de0802d52",
        "type": "postgreSQLConfig",
        "name": "",
        "host": "localhost",
        "hostFieldType": "str",
        "port": "5432",
        "portFieldType": "num",
        "database": "postgres",
        "databaseFieldType": "str",
        "ssl": "false",
        "sslFieldType": "bool",
        "applicationName": "",
        "applicationNameType": "str",
        "max": "10",
        "maxFieldType": "num",
        "idle": "1000",
        "idleFieldType": "num",
        "connectionTimeout": "10000",
        "connectionTimeoutFieldType": "num",
        "user": "iplon",
        "userFieldType": "str",
        "password": "Cyber@Park",
        "passwordFieldType": "str"
    },
    {
        "id": "0b96cb9d434d59c0",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.87.101",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": false,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "ea571d30b091616d",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": 10,
        "rejectUnauthorized": true
    },
    {
        "id": "12e5b4a20ade9a35",
        "type": "Modbus-Client",
        "name": "",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.87.102",
        "tcpPort": 502,
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "305cedf81ae151ea",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.87.84",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "73460dc9bc32c56a",
        "type": "mqtt in",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "",
        "topic": "INC_INV1",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6900a3972037d1fd",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 180,
        "y": 540,
        "wires": [
            [
                "4829a5ec24a43bb7",
                "dfb7880d117d569f"
            ]
        ]
    },
    {
        "id": "4829a5ec24a43bb7",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "debug 2692",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 350,
        "y": 500,
        "wires": []
    },
    {
        "id": "dfb7880d117d569f",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "function 663",
        "func": "var obj = {};\nfor (var i=0; i< msg.payload.length; i++) {\n    var tag_val = msg.payload[i].bd + '.' + msg.payload[i].f\n    var value = msg.payload[i].value\n    global.set(tag_val, value)\n    obj.payload = {tag_val: tag_val, value: value}\n    node.send(obj)\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 540,
        "wires": [
            [
                "30607a38eac50efb"
            ]
        ]
    },
    {
        "id": "30607a38eac50efb",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "debug 2693",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 510,
        "y": 540,
        "wires": []
    },
    {
        "id": "7e06dde20744b4e5",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "g": "18882cf9eafa39f8",
        "name": "function 664",
        "func": "// Assuming you have three global values\nconst value1 = global.get(\"PAC_LIMIT_CMD\");\n// const value1 = 1500\nconst value2 = global.get(\"QAC_LIMIT_CMD\");\nconst value3 = global.get(\"QAC_REF_SEL_CMD\");\n\n\n// Create an object with the three values\nconst resultObject = {\n  PAC_LIMIT_CMD: value1,\n  QAC_LIMIT_CMD: value2,\n  QAC_REF_SEL: value3\n};\n\n// Set the resulting object as the message payload\n\nmsg.payload = resultObject\n\n// Return the modified message object\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 540,
        "wires": [
            [
                "cc69ec99eb343c90",
                "86f58beb437e5149"
            ]
        ]
    },
    {
        "id": "09728be7255809a1",
        "type": "inject",
        "z": "f313dfa39a2c857c",
        "g": "18882cf9eafa39f8",
        "name": "",
        "props": [],
        "repeat": "0.01",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 810,
        "y": 540,
        "wires": [
            [
                "7e06dde20744b4e5"
            ]
        ]
    },
    {
        "id": "cc69ec99eb343c90",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "18882cf9eafa39f8",
        "name": "debug 2694",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 500,
        "wires": []
    },
    {
        "id": "86f58beb437e5149",
        "type": "mqtt out",
        "z": "f313dfa39a2c857c",
        "g": "18882cf9eafa39f8",
        "name": "",
        "topic": "INC_INV1_WR",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "6900a3972037d1fd",
        "x": 1160,
        "y": 540,
        "wires": []
    },
    {
        "id": "271d08a96c0c2d7f",
        "type": "inject",
        "z": "f313dfa39a2c857c",
        "name": "",
        "props": [
            {
                "p": "device",
                "v": "INV",
                "vt": "str"
            },
            {
                "p": "paconoff",
                "v": "PAC_ON_OFF",
                "vt": "global"
            },
            {
                "p": "fonoff",
                "v": "Line1_ON_OFF",
                "vt": "global"
            },
            {
                "p": "selpc",
                "v": "SEL_PC_RX",
                "vt": "global"
            },
            {
                "p": "gridpac",
                "v": "MCR.VR_EM.PAC",
                "vt": "global"
            },
            {
                "p": "pacpc",
                "v": "PAC_PC_RX",
                "vt": "global"
            },
            {
                "p": "inverterOnline",
                "v": "71",
                "vt": "num"
            },
            {
                "p": "inverterOnlineQ",
                "v": "75",
                "vt": "num"
            },
            {
                "p": "paclimit",
                "v": "PAC_LIMIT_CMD",
                "vt": "global"
            },
            {
                "p": "maxcurrent",
                "v": "300000",
                "vt": "num"
            },
            {
                "p": "setcurrent",
                "v": "280000",
                "vt": "num"
            },
            {
                "p": "gridiac",
                "v": "MCR.VR_EM.IAC",
                "vt": "global"
            },
            {
                "p": "invpac",
                "v": "PLANT.VR_INV.PAC",
                "vt": "global"
            },
            {
                "p": "qaconoff",
                "v": "QAC_ON_OFF",
                "vt": "global"
            },
            {
                "p": "gridqac",
                "v": "MCR.VR_EM.QAC",
                "vt": "global"
            },
            {
                "p": "qacpc",
                "v": "QAC_PC_RX",
                "vt": "global"
            },
            {
                "p": "qaclimit",
                "v": "QAC_LIMIT_CMD",
                "vt": "global"
            },
            {
                "p": "setpf",
                "v": "0.945",
                "vt": "num"
            },
            {
                "p": "gridpf",
                "v": "MCR.EM01.PF",
                "vt": "global"
            },
            {
                "p": "maxpf",
                "v": "0.94",
                "vt": "num"
            },
            {
                "p": "invqac",
                "v": "PLANT.VR_INV.QAC",
                "vt": "global"
            },
            {
                "p": "pfonoff",
                "v": "PF_ON_OFF",
                "vt": "global"
            },
            {
                "p": "pfpc",
                "v": "PF_PC_RX",
                "vt": "global"
            },
            {
                "p": "uaconoff",
                "v": "UAC_ON_OFF",
                "vt": "global"
            },
            {
                "p": "uacpc",
                "v": "UAC_PC_RX1",
                "vt": "global"
            },
            {
                "p": "griduac",
                "v": "MCR.VR_EM.UAC",
                "vt": "global"
            },
            {
                "p": "facpc",
                "v": "FAC_PC_RX1",
                "vt": "global"
            },
            {
                "p": "faconoff",
                "v": "FAC_ON_OFF",
                "vt": "global"
            },
            {
                "p": "gridfac",
                "v": "MCR.VR_EM.FAC",
                "vt": "global"
            },
            {
                "p": "ramponoff",
                "v": "RAMP_ON_OFF",
                "vt": "global"
            },
            {
                "p": "lvrthvrtonoff",
                "v": "VRT_ON_OFF",
                "vt": "global"
            },
            {
                "p": "svgonoff",
                "v": "SVG_ON_OFF",
                "vt": "global"
            },
            {
                "p": "svgslot1pc",
                "v": "SVG_SLOT1_PC_RX1",
                "vt": "global"
            },
            {
                "p": "svgslot2pc",
                "v": "SVG_SLOT2_PC_RX1",
                "vt": "global"
            },
            {
                "p": "svgslot3pc",
                "v": "SVG_SLOT3_PC_RX1",
                "vt": "global"
            },
            {
                "p": "openplimit",
                "v": "PAC_LIMIT_CMD_RX",
                "vt": "global"
            },
            {
                "p": "openqlimit",
                "v": "QAC_REF_CMD_RX",
                "vt": "global"
            },
            {
                "p": "kp",
                "v": "0.25",
                "vt": "num"
            },
            {
                "p": "ti",
                "v": "10",
                "vt": "num"
            },
            {
                "p": "kd",
                "v": "0.01",
                "vt": "num"
            },
            {
                "p": "kpq",
                "v": "0.35",
                "vt": "num"
            },
            {
                "p": "tiq",
                "v": "10",
                "vt": "num"
            },
            {
                "p": "kdq",
                "v": "0.01",
                "vt": "num"
            },
            {
                "p": "Vrated",
                "v": "220",
                "vt": "num"
            },
            {
                "p": "Vdroop",
                "v": "5",
                "vt": "num"
            },
            {
                "p": "quonoff",
                "v": "QU_ON_OFF",
                "vt": "global"
            },
            {
                "p": "qacrefsel",
                "v": "2",
                "vt": "num"
            },
            {
                "p": "ratedPcapacity",
                "v": "250",
                "vt": "num"
            },
            {
                "p": "ratedFrequency",
                "v": "50",
                "vt": "num"
            },
            {
                "p": "VDdroop",
                "v": "1",
                "vt": "num"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": "1",
        "topic": "",
        "x": 390,
        "y": 180,
        "wires": [
            [
                "95da83be66b148b4",
                "a1b67f212f5afbd3"
            ]
        ]
    },
    {
        "id": "95da83be66b148b4",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "name": "debug 2690",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 120,
        "wires": []
    },
    {
        "id": "1a6f114418073679",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "name": "debug 2691",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 180,
        "wires": []
    },
    {
        "id": "4fd4ce1ca7a00507",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "name": "function 677",
        "func": "global.set(\"SEL_PC_RX\",1)\nglobal.set(\"Line1_ON_OFF\",1)\nglobal.set(\"QAC_ON_OFF\",0)\nglobal.set(\"QAC_PC_RX1\",0)\n\n//global.set(\"PAC_LIMIT_CMD_RX1\",1000)\n//global.set(\"PAC_LIMIT_CMD_RX2\",2000)\n//global.set(\"PAC_LIMIT_CMD_RX3\",3000)\n//global.set(\"PAC_LIMIT_CMD_RX4\",4000)\n//global.set(\"PAC_LIMIT_CMD_RX5\",5000)\n//global.set(\"PAC_LIMIT_CMD_RX6\",6000)\n//global.set(\"PAC_LIMIT_CMD_RX7\",7000)\n//global.set(\"PAC_LIMIT_CMD_RX8\",8000)\n//global.set(\"QAC_LIMIT_CMD2\",-215)\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "dc24f7def5e1612e",
        "type": "inject",
        "z": "f313dfa39a2c857c",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 390,
        "y": 280,
        "wires": [
            [
                "4fd4ce1ca7a00507"
            ]
        ]
    },
    {
        "id": "f905cf63c9836a83",
        "type": "comment",
        "z": "f313dfa39a2c857c",
        "name": "MASTER-1 ",
        "info": "",
        "x": 310,
        "y": 420,
        "wires": []
    },
    {
        "id": "c9543c425ccec80d",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "d": true,
        "name": "PPC_Logic",
        "func": "const caseReset = 4; // Threshold for resetting cases\nconst caseResetP = 8;\n// Function for File handling\nconst fd = global.get('fs');\n// Function to rename CSV files\nfunction renameCsvFiles(filePath) {\n    const files = fd.readdirSync(filePath).filter(file => file.endsWith('.csv'));\n    files.forEach(file => {\n        const oldPath = path.join(filePath, file);\n        const newPath = path.join(filePath, `${file.slice(0, -4)}.unsent`);\n        fd.renameSync(oldPath, newPath);\n    });\n}\n// Function to get epoch time\nfunction getEpochTime() {\n    // Get the current time and round down to the nearest 300 seconds\n    const now = Math.floor(Date.now() / 1000); // Convert to seconds\n    return now - (now % 300); // Round down to the nearest 300 seconds\n}\n// Function to log PPC Active Power Logic CSV\nfunction logCsv(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_01.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Reactive Power Logic CSV\nfunction logCsvQ(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_02.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Power Factor Logic CSV\nfunction logCsvPF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_05.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Voltage Logic CSV\nfunction logCsvU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_03.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Q/U Logic CSV\nfunction logCsvQU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_07.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Frequency Logic CSV\nfunction logCsvF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_04.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Ramp Logic CSV\nfunction logCsvR(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_06.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Set last file pack time\nconst TS = getEpochTime();\nflow.set('lastFilePackTime', TS);\n// Rename CSV files if needed\nif (flow.get('lastFilePackTime') < TS) {\n    renameCsvFiles('/mnt/jffs2/dglog');\n    flow.set('lastFilePackTime', TS);\n}\n// UI Settings value for P Control\nlet pacMaxSetCmd = global.get(\"PAC_MAX_SET_RX\")\nif (pacMaxSetCmd === undefined || isNaN(pacMaxSetCmd)) {\n    pacMaxSetCmd = 2772;\n}\nlet blkPacMaxCmd = global.get(\"BLOCK_PAC_MAX_SET_RX\")\nif (blkPacMaxCmd === undefined || isNaN(blkPacMaxCmd)) {\n    blkPacMaxCmd = 27720;\n}\nlet pacLLSetCmd = global.get(\"PAC_CL_SET_RX\")\nif (pacLLSetCmd === undefined || isNaN(pacLLSetCmd)) {\n    pacLLSetCmd = 2;\n}\nlet pacULSetCmd = global.get(\"PAC_ULL_SET_RX\")\nif (pacULSetCmd === undefined || isNaN(pacULSetCmd)) {\n    pacULSetCmd = 1;\n}\nconst pacGRSetCmd = global.get(\"PAC_GR_SET_RX\")\nconst pacTuneStCmd = global.get(\"PAC_TUNE_ST_CONST_RX\")\nconst pacIncconstCmd = global.get(\"PAC_INCR_SET_RX\")\nconst pacDecconstCmd = global.get(\"PAC_DECR_CONST_RX\")\n// UI Settings value for Q Control\nlet qacMaxSetCmd = global.get(\"QAC_MAX_SET_RX\")\nif (qacMaxSetCmd === undefined || isNaN(qacMaxSetCmd)) {\n    qacMaxSetCmd = 1500;\n}\nlet blkQacMaxCmd = global.get(\"BLOCK_QAC_MAX_SET_RX\")\nif (blkQacMaxCmd === undefined || isNaN(blkQacMaxCmd)) {\n    blkQacMaxCmd = 15000;\n}\nlet qacLLSetCmd = global.get(\"QAC_CL_SET_RX\")\nif (qacLLSetCmd === undefined || isNaN(qacLLSetCmd)) {\n    qacLLSetCmd = 2;\n}\nlet qacULSetCmd = global.get(\"QAC_ULL_SET_RX\")\nif (qacULSetCmd === undefined || isNaN(qacULSetCmd)) {\n    qacULSetCmd = 1;\n}\nconst qacGRSetCmd = global.get(\"QAC_GR_SET_RX\")\nlet tuneStep = global.get(\"QAC_TUNE_ST_CONST_RX\")\nconst qacIncConstCmd = global.get(\"QAC_INCR_SET_RX\")\nconst qacDecConstCmd = global.get(\"QAC_DECR_CONST_RX\")\n// UI Settings value for SVG Control\nconst svgSlot1StartHour = global.get(\"SVG_SLOT1_START_HOUR_RX1\")\nconst svgSlot2StartHour = global.get(\"SVG_SLOT2_START_HOUR_RX1\")\nconst svgSlot3StartHour = global.get(\"SVG_SLOT3_START_HOUR_RX1\")\nconst svgSlot4StartHour = global.get(\"SVG_SLOT4_START_HOUR_RX1\")\nconst svgSlot1StartMin = global.get(\"SVG_SLOT1_START_MIN_RX1\")\nconst svgSlot2StartMin = global.get(\"SVG_SLOT2_START_MIN_RX1\")\nconst svgSlot3StartMin = global.get(\"SVG_SLOT3_START_MIN_RX1\")\nconst svgSlot4StartMin = global.get(\"SVG_SLOT4_START_MIN_RX1\")\nconst svgSlot1StopHour = global.get(\"SVG_SLOT1_STOP_HOUR_RX1\")\nconst svgSlot2StopHour = global.get(\"SVG_SLOT2_STOP_HOUR_RX1\")\nconst svgSlot3StopHour = global.get(\"SVG_SLOT3_STOP_HOUR_RX1\")\nconst svgSlot4StopHour = global.get(\"SVG_SLOT4_STOP_HOUR_RX1\")\nconst svgSlot1StopMin = global.get(\"SVG_SLOT1_STOP_MIN_RX1\")\nconst svgSlot2StopMin = global.get(\"SVG_SLOT2_STOP_MIN_RX1\")\nconst svgSlot3StopMin = global.get(\"SVG_SLOT3_STOP_MIN_RX1\")\nconst svgSlot4StopMin = global.get(\"SVG_SLOT4_STOP_MIN_RX1\")\n// UI Settings Value for PF Control\nlet pfLLSetCmd = global.get(\"PF_LL_SET_RX\")\nif (pfLLSetCmd === undefined || isNaN(pfLLSetCmd)) {\n    pfLLSetCmd = 0.004;\n}\nlet pfULSetcmd = global.get(\"PF_TH_SET_RX\")\nif (pfULSetcmd === undefined || isNaN(pfULSetcmd)) {\n    pfULSetcmd = 0.004;\n}\nlet pfGRSetCmd2 = global.get(\"PF_GR_SET_RX2\")\nif (pfGRSetCmd2 === undefined || isNaN(pfGRSetCmd2)) {\n    pfGRSetCmd2 = 10;\n}\nlet pfGRSetCmd = global.get(\"PF_GR_SET_RX\")\nif (pfGRSetCmd === undefined || isNaN(pfGRSetCmd)) {\n    pfGRSetCmd = 10;\n}\nlet pfDecConstCmd = global.get(\"PF_DECR_CONST_RX\")\nif (pfDecConstCmd === undefined || isNaN(pfDecConstCmd)) {\n    pfDecConstCmd = 20;\n}\nlet pfIncConstCmd = global.get(\"PF_INCR_SET_RX\")\nif (pfIncConstCmd === undefined || isNaN(pfIncConstCmd)) {\n    pfIncConstCmd = 20;\n}\n// UI Settings Value for UAC Control\nlet quULSetCmd = global.get(\"UAC_ULL_SET_RX\")\nif (quULSetCmd === undefined || isNaN(quULSetCmd)) {\n    quULSetCmd = 1;\n}\nlet quLLSetCmd = global.get(\"UAC_CL_SET_RX\")\nif (quLLSetCmd === undefined || isNaN(quLLSetCmd)) {\n    quLLSetCmd = 1;\n}\nlet quGRSetCmd = global.get(\"UAC_GR_SET_RX\")\nif (quGRSetCmd === undefined || isNaN(quGRSetCmd)) {\n    quGRSetCmd = 0;\n}\nlet quTuneStCmd = global.get(\"UAC_TUNE_ST_CONST_RX\")\nif (quTuneStCmd === undefined || isNaN(quTuneStCmd)) {\n    quTuneStCmd = 2;\n}\nlet quIncConstCmd = global.get(\"UAC_INCR_SET_RX\")\nif (quIncConstCmd === undefined || isNaN(quIncConstCmd)) {\n    quIncConstCmd = 4;\n}\nlet quDecConstCmd = global.get(\"UAC_DECR_CONST_RX\")\nif (quDecConstCmd === undefined || isNaN(quDecConstCmd)) {\n    quDecConstCmd = 4;\n}\n// UI Settings Value for FAC Control\nlet facDeadBand = msg.facDeadBand\nif (facDeadBand === undefined || isNaN(facDeadBand)) {\n    facDeadBand = 0;\n}\nlet facLLSetCmd = global.get(\"FAC_LL_SET_CMD\")\nif (facLLSetCmd === undefined || isNaN(facLLSetCmd)) {\n    facLLSetCmd = 0.3;\n}\nlet facCULSetCmd = global.get(\"FAC_CUL_SET_CMD\")\nif (facCULSetCmd === undefined || isNaN(facCULSetCmd)) {\n    facCULSetCmd = 2.0;\n}\nlet facCLLSetCmd = global.get(\"FAC_CLL_SET_CMD\")\nif (facCLLSetCmd === undefined || isNaN(facCLLSetCmd)) {\n    facCLLSetCmd = 2.5;\n}\nlet facGRSetCmd = global.get(\"FAC_GR_SET_CMD\")\nif (facGRSetCmd === undefined || isNaN(facGRSetCmd)) {\n    facGRSetCmd = 0;\n}\nlet facTuneStCmd = global.get(\"FAC_TUNE_ST_CONST_CMD\")\nif (facTuneStCmd === undefined || isNaN(facTuneStCmd)) {\n    facTuneStCmd = 100;\n}\nlet facIncConstCmd = global.get(\"FAC_INCR_CONST_CMD\")\nif (facIncConstCmd === undefined || isNaN(facIncConstCmd)) {\n    facIncConstCmd = 1;\n}\nlet facDecConstCmd = global.get(\"FAC_DECR_CONST_CMD\")\nif (facDecConstCmd === undefined || isNaN(facDecConstCmd)) {\n    facDecConstCmd = 1;\n}\nlet fDroopCmd = msg.facDroop\nif (fDroopCmd === undefined || isNaN(fDroopCmd)) {\n    fDroopCmd = 5;\n}\n// UI Settings Value for RAMP Control\nconst rampTuneStCmd = global.get(\"RAMP_TUNE_ST_CONST_RX\")\nconst rampIncconstCmd = global.get(\"RAMP_INCR_CONST_RX\")\nconst rampDecconstCmd = global.get(\"RAMP_DECR_CONST_RX\")\nconst rampOnOffCmd = msg.ramponoff\n// UI Settings Value for VRT Control\nconst lvrthvrtULSetCmd = global.get(\"LVRT_HVRT_ULL_SET_RX\")\nconst lvrthvrtLLSetCmd = global.get(\"LVRT_HVRT_CL_SET_RX\")\n// Setpoint & Simulation Value for P Control\nconst dev = msg.device\nconst pacOnOffCmd = msg.paconoff\nconst fonoffcmd = msg.fonoff\nconst powselcmd = msg.selpc\nconst zePac = msg.gridpac * 1000\nconst zePMinLoad = (msg.pacpc * 1000)\nconst inverterOnline = msg.inverterOnline\nconst inverterOnlineQ = msg.inverterOnlineQ\nlet PAC_LIMIT = msg.paclimit\nif (PAC_LIMIT === undefined || isNaN(PAC_LIMIT)) {\n    PAC_LIMIT = 2772;\n}\nconst zeIacMaxCmd = msg.maxcurrent\nconst zeIacSetCmd = msg.setcurrent\nconst zeIac = msg.gridiac\nconst pvPac = msg.invpac\nconst Kp = msg.kp\nconst Ti = msg.ti\nconst Kd = msg.kd\nlet Inv_Setpoint\nlet P_error\nlet P_integral = flow.get('P_integral') || 0;\nlet P_derivative\nlet P_previous_error = flow.get('P_previous_error') || 0;\nconst zeSac = global.get(\"CR.VR_EM.SAC\")\n// Setpoint & Simulation Value for Q Control\nconst qaconoffcmd = msg.qaconoff\nconst zeQac = msg.gridqac * 1000\nlet zeMinLoad = ((msg.qacpc * 1000))\nlet QAC_LIMIT = msg.qaclimit\nif (QAC_LIMIT === undefined || isNaN(QAC_LIMIT)) {\n    QAC_LIMIT = 0;\n}\nconst zePfSetCmd = msg.setpf\nconst zepfMaxLoad = msg.maxpf\nlet zePf = msg.gridpf\nzePf = parseFloat(zePf.toFixed(3));\nconst pvQac = msg.invqac\nconst Kpq = msg.kpq\nconst Tiq = msg.tiq\nconst Kdq = msg.kdq\nlet Inv_Qsetpoint\nlet Q_error\n//let Q_integral\nlet Q_integral = flow.get('Q_integral') || 0;\n//if (Q_integral === undefined || isNaN(Q_integral)) { Q_integral = 0; }\nlet Q_derivative\nlet Q_previous_error = flow.get('Q_previous_error') || 0;\nlet qacRefSel = msg.qacrefsel\n// Setpint Value for SVG Control\nconst svgonoffcmd = msg.svgonoff\nconst svgslot1pccmd = msg.svgslot1pc\nconst svgslot2pccmd = msg.svgslot2pc\nconst svgslot3pccmd = msg.svgslot3pc\n// Setpoint & Simulation Value for PF Control\nconst pfonoffcmd = msg.pfonoff\nconst zePFMinLoad = msg.pfpc\nconst zePFThreshold = pfULSetcmd\n// Setpoint & Simulation Value for U Control\nconst uaconoffcmd = msg.uaconoff\nconst zeUMinLoad = msg.uacpc\nconst zeUac = msg.griduac\n//let zeUThreshold = (zeUMinLoad * (msg.VDdroop / 100))\n//let zeUCriticalLoad = zeUMinLoad - ((quLLSetCmd / 100) * zeUMinLoad);\nlet qacMaxSet\nlet ratedQCapacity\nconst ratedvoltage = msg.Vrated\nconst droopPercentage = msg.Vdroop\n//const dbPercentage = msg.VDdroop\nconst droopDeadbandPercentage = msg.VDdroop\n// Setpoint & Simulation Value for Q/U Control\nconst quonoffcmd = msg.quonoff\n// Voltage Droop Calculation\nconst dbThreshold = (droopDeadbandPercentage * ratedvoltage) / 100\nconst droopThreshold = (droopPercentage * ratedvoltage) / 100\nconst deadBandMax = ratedvoltage + dbThreshold\nconst deadBandMin = ratedvoltage - dbThreshold\nconst droopMax = ratedvoltage + droopThreshold\nconst droopMin = ratedvoltage - droopThreshold\n// Setpoint & Simulation Value for VRT Control\nconst lvrtHvrtOnOffCmd = msg.lvrthvrtonoff\nconst zelvrthvrtCriticalLoad = (zeUMinLoad * (lvrthvrtULSetCmd / 100));\nconst zelvrthvrtThreshold = zeUMinLoad - ((lvrthvrtLLSetCmd / 100) * zeUMinLoad);\n// Setpoint & Simulation Value for F Control\nconst faconoffcmd = msg.faconoff\nconst zeFMinLoad = msg.facpc\nconst zeFac = msg.gridfac\nconst zeFCriticalLoad = facLLSetCmd\nconst zeFUCriticalLoad = facCULSetCmd\nconst zeFLCriticalLoad = facCLLSetCmd\nconst zeFThreshold = facDeadBand\nlet pacLimitdel\n// Initialize pacLimit and other variables\nlet maxPacLimit = ((PAC_LIMIT));\nflow.set(\"maxPacLimit\", maxPacLimit);\n//let oldPacLimit1 = flow.get('oldPacLimit1') || maxPacLimit;\nlet oldPacLimit1\nlet minPacLimit = maxPacLimit;\nconst invPacLimit = ((PAC_LIMIT)); // Assuming this comes from msg\nconst zePCriticalLoad = zePMinLoad - ((pacLLSetCmd / 100) * blkPacMaxCmd)\nconst zePThreshold = (pacULSetCmd / 100) * blkPacMaxCmd\n// Update max and min limits based on invPacLimit\nif (!isNaN(invPacLimit)) {\n    if (invPacLimit > maxPacLimit) maxPacLimit = invPacLimit;\n    if (invPacLimit < minPacLimit) minPacLimit = invPacLimit;\n}\nlet pacLimit = maxPacLimit;\n// Initialize qacLimit and other variables\nlet maxQacLimit = ((QAC_LIMIT) / qacMaxSetCmd) * 100;\nlet minQacLimit = maxQacLimit;\nlet oldQacLimit1\nconst invQacLimit = ((QAC_LIMIT) / qacMaxSetCmd) * 100; // Assuming this comes from msg\nlet zeCriticalLoad = zeMinLoad - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeThreshold = (qacULSetCmd / 100) * blkQacMaxCmd\n//SVG Variables\nconst zeSvgSlot1MinLoad = svgslot1pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot1CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nconst zeSvgSlot2MinLoad = svgslot2pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot2CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nconst zeSvgSlot3MinLoad = svgslot3pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot3CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nlet qModeEnable\n// Update max and min limits based on invQacLimit\nif (!isNaN(invQacLimit)) {\n    if (invQacLimit > maxQacLimit) maxQacLimit = invQacLimit;\n    if (invQacLimit < minQacLimit) minQacLimit = invQacLimit;\n}\nlet qacLimit = (maxQacLimit * qacMaxSetCmd) / 100;\nqacLimit = parseFloat(qacLimit.toFixed(1));\n//let oldQacLimit = QAC_LIMIT / 10;\n//let qacLimitW = qacLimit;\n//let oldQacLimitW = qacLimit;\n//let pvQacW = qacLimit;\n//node.warn(`x:${maxQacLimit}`)\nmsg.pacLimitMWrite = undefined; // Initialize msg.pacLimitMWrite to undefined to identify if it remains unset\nmsg.qacLimitMWrite = undefined; // Initialize msg.qacLimitMWrite to undefined to identify if it remains unset\n// PPC P Control Casereset\nlet case1ZEP = flow.get('case1ZEP');\nif (case1ZEP === undefined || isNaN(case1ZEP)) {\n    case1ZEP = caseResetP;\n    flow.set(\"case1ZEP\", case1ZEP)\n}\nlet case2ZEP = flow.get('case2ZEP');\nif (case2ZEP === undefined || isNaN(case2ZEP)) {\n    case2ZEP = caseResetP;\n    flow.set(\"case2ZEP\", case2ZEP);\n}\nlet case3ZEP = flow.get('case3ZEP');\nif (case3ZEP === undefined || isNaN(case3ZEP)) {\n    case3ZEP = caseResetP;\n    flow.set(\"case3ZEP\", case3ZEP);\n}\nlet case4ZEP = flow.get('case4ZEP');\nif (case4ZEP === undefined || isNaN(case4ZEP)) {\n    case4ZEP = caseResetP;\n    flow.set(\"case4ZEP\", case4ZEP);\n}\nlet case5ZEP = flow.get('case5ZEP');\nif (case5ZEP === undefined || isNaN(case5ZEP)) {\n    case5ZEP = caseResetP;\n    flow.set(\"case5ZEP\", case5ZEP);\n}\n// PPC Q Control Casereset\nlet case1ZEQ = flow.get('case1ZEQ');\nif (case1ZEQ === undefined || isNaN(case1ZEQ)) {\n    case1ZEQ = caseReset;\n    flow.set(\"case1ZEQ\", case1ZEQ);\n}\nlet case2ZEQ = flow.get('case2ZEQ');\nif (case2ZEQ === undefined || isNaN(case2ZEQ)) {\n    case2ZEQ = caseReset;\n    flow.set(\"case2ZEQ\", case2ZEQ);\n}\nlet case3ZEQ = flow.get('case3ZEQ');\nif (case3ZEQ === undefined || isNaN(case3ZEQ)) {\n    case3ZEQ = caseReset;\n    flow.set(\"case3ZEQ\", case3ZEQ);\n}\nlet case4ZEQ = flow.get('case4ZEQ');\nif (case4ZEQ === undefined || isNaN(case4ZEQ)) {\n    case4ZEQ = caseReset;\n    flow.set(\"case4ZEQ\", case4ZEQ);\n}\nlet case5ZEQ = flow.get('case5ZEQ');\nif (case5ZEQ === undefined || isNaN(case5ZEQ)) {\n    case5ZEQ = caseReset;\n    flow.set(\"case5ZEQ\", case5ZEQ);\n}\n// PPC PF Control Casereset\nlet case1ZEPF = flow.get('case1ZEPF');\nif (case1ZEPF === undefined || isNaN(case1ZEPF)) {\n    case1ZEPF = caseReset;\n    flow.set(\"case1ZEPF\", case1ZEPF);\n}\nlet case2ZEPF = flow.get('case2ZEPF');\nif (case2ZEPF === undefined || isNaN(case2ZEPF)) {\n    case2ZEPF = caseReset;\n    flow.set(\"case2ZEPF\", case2ZEPF);\n}\nlet case3ZEPF = flow.get('case3ZEPF');\nif (case3ZEPF === undefined || isNaN(case3ZEPF)) {\n    case3ZEPF = caseReset;\n    flow.set(\"case3ZEPF\", case3ZEPF);\n}\nlet case4ZEPF = flow.get('case4ZEPF');\nif (case4ZEPF === undefined || isNaN(case4ZEPF)) {\n    case4ZEPF = caseReset;\n    flow.set(\"case4ZEPF\", case4ZEPF);\n}\nlet case5ZEPF = flow.get('case5ZEPF');\nif (case5ZEPF === undefined || isNaN(case5ZEPF)) {\n    case5ZEPF = caseReset;\n    flow.set(\"case5ZEPF\", case5ZEPF);\n}\n// PPC U Control Casereset\nlet case1ZEU = flow.get('case1ZEU');\nif (case1ZEU === undefined || isNaN(case1ZEU)) {\n    case1ZEU = caseReset;\n    flow.set(\"case1ZEU\", case1ZEU);\n}\nlet case2ZEU = flow.get('case2ZEU');\nif (case2ZEU === undefined || isNaN(case2ZEU)) {\n    case2ZEU = caseReset;\n    flow.set(\"case2ZEU\", case2ZEU);\n}\nlet case3ZEU = flow.get('case3ZEU');\nif (case3ZEU === undefined || isNaN(case3ZEU)) {\n    case3ZEU = caseReset;\n    flow.set(\"case3ZEU\", case3ZEU);\n}\nlet case4ZEU = flow.get('case4ZEU');\nif (case4ZEU === undefined || isNaN(case4ZEU)) {\n    case4ZEU = caseReset;\n    flow.set(\"case4ZEU\", case4ZEU);\n}\nlet case5ZEU = flow.get('case5ZEU');\nif (case5ZEU === undefined || isNaN(case5ZEU)) {\n    case5ZEU = caseReset;\n    flow.set(\"case5ZEU\", case5ZEU);\n}\nlet case6ZEU = flow.get('case6ZEU');\nif (case6ZEU === undefined || isNaN(case6ZEU)) {\n    case6ZEU = caseReset;\n    flow.set(\"case6ZEU\", case6ZEU);\n}\n// PPC F Control Casereset\nlet case1ZEF = flow.get('case1ZEF');\nif (case1ZEF === undefined || isNaN(case1ZEF)) {\n    case1ZEF = caseReset;\n    flow.set(\"case1ZEF\", case1ZEF);\n}\nlet case2ZEF = flow.get('case2ZEF');\nif (case2ZEF === undefined || isNaN(case2ZEF)) {\n    case2ZEF = caseReset;\n    flow.set(\"case2ZEF\", case2ZEF);\n}\nlet case3ZEF = flow.get('case3ZEF');\nif (case3ZEF === undefined || isNaN(case3ZEF)) {\n    case3ZEF = caseReset;\n    flow.set(\"case3ZEF\", case3ZEF);\n}\nlet case4ZEF = flow.get('case4ZEF');\nif (case4ZEF === undefined || isNaN(case4ZEF)) {\n    case4ZEF = caseReset;\n    flow.set(\"case4ZEF\", case4ZEF);\n}\nlet case5ZEF = flow.get('case5ZEF');\nif (case5ZEF === undefined || isNaN(case5ZEF)) {\n    case5ZEF = caseReset;\n    flow.set(\"case5ZEF\", case5ZEF);\n}\n\n// ------------------------------- Open Loop Logic Start ---------------------------------------------\nlet OLpacLimit = msg.openplimit\nlet OLqacLimit = msg.openqlimit\nif (powselcmd == 0) {\n    if ((OLpacLimit != undefined || !isNaN(OLpacLimit))) {\n        msg.pacLimitMWrite = OLpacLimit;\n        msg.case = \"Case 0: PACLIMIT has given from User\";\n    }\n    if ((qacRefSel != undefined || !isNaN(qacRefSel))) {\n        msg.qacRefSelMWrite = global.get(\"QAC_REF_SEL_RX\")\n    }\n    if ((OLqacLimit != undefined && !isNaN(OLqacLimit))) {\n        msg.qacLimitMWrite = OLqacLimit;\n        msg.caseq = \"Case 0: QACLIMIT has given from User\";\n    } else {\n        msg.qacLimitMWrite = 0\n        msg.caseq = \"Case 0: QACLIMIT has given from UI\";\n    }\n}\n// ---------------------------------- Open Loop Logic Stop ----------------------------------------------------\n// ---------------------------------- QAC Sel Mode Start----------------------------------------------------\nif (powselcmd == 1) {\n    if ((qacRefSel != undefined || !isNaN(qacRefSel || qacRefSel != 162))) {\n        msg.qacRefSelMWrite = 162\n    }\n}\n// ---------------------------------- QAC Sel Mode End --------------------------------------------------------\n// ---------------------------------------- Active Power Control Logic Start -------------------------------------------------------\n// ---------------------------------------- Active Power Control Logic Start -------------------------------------------------------\n//if (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && pacOnOffCmd == 1) {\nif (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && pacOnOffCmd == 1 && faconoffcmd == 0) {\n    if (zePac >= (zePMinLoad + zePThreshold) && (zeIac < zeIacSetCmd) && (maxPacLimit <= pacMaxSetCmd)) {\n\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n        //pacLimit = parseFloat(pacLimit.toFixed(1));\n         if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n      \n\n    \n        Inv_Setpoint = zePMinLoad;\n\n        P_error = pvPac - Inv_Setpoint;\n        P_integral = P_integral + (P_error * 0.1);\n        P_derivative = (P_error - P_previous_error) / 0.1\n        P_previous_error = P_error\n\n        P_error = parseFloat(P_error.toFixed(1));\n        P_integral = parseFloat(P_integral.toFixed(1));\n        P_derivative = parseFloat(P_derivative.toFixed(1));\n        P_previous_error = parseFloat(P_previous_error.toFixed(1));\n       \n        if (case1ZEP >= caseResetP) {\n\n        // Recalculate pacLimit with the control logic\n            pacLimit = (((pvPac) - (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)))) / inverterOnline)\n\n        // Round pacLimit to one decimal place\n       // pacLimit = parseFloat(pacLimit.toFixed(1));\n\n        // Ensure pacLimit doesn't exceed pacMaxSetCmd\n        if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n              \n            // Update 'oldPacLimit1' with the new 'pacLimit'\n            oldPacLimit1 = pacLimit;\n\n            // Round pacLimit to one decimal place\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n\n            // Reset case1ZEP and set flow context\n            case1ZEP = 0;\n            flow.set('case1ZEP', case1ZEP);\n\n            if (pacLimit <= 10) pacLimit = 10;\n\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.1.0 force down\";\n            const logMessage = `1.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n        } else {\n            // Increment case1ZEP and set flow context\n            case1ZEP++;\n            flow.set('case1ZEP', case1ZEP);\n\n            if (pacLimit <= 10) pacLimit = 10;\n\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.1.1 force down\";\n            const logMessage = `1.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldPacLimit1', oldPacLimit1);\n        flow.set('P_integral',P_integral);\n        flow.set('P_previous_error',P_previous_error);\n    }\n\n    // Case 2: < critical load\n    else if ((zePac <= zePMinLoad - zePThreshold) && zeIac < zeIacSetCmd && (maxPacLimit < pacMaxSetCmd)) {\n\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n       // pacLimit = parseFloat(pacLimit.toFixed(1));\n         if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;      \n\n            Inv_Setpoint = zePMinLoad ;\n            P_error = Inv_Setpoint - (pvPac);\n            P_integral = P_integral + (P_error * 0.1);\n            P_derivative = (P_error - P_previous_error) / 0.1\n            P_previous_error = P_error\n\n            P_error = parseFloat(P_error.toFixed(1));\n            P_integral = parseFloat(P_integral.toFixed(1));\n            P_derivative = parseFloat(P_derivative.toFixed(1));\n            P_previous_error = parseFloat(P_previous_error.toFixed(1));\n\n        if (case2ZEP >= caseResetP) {\n            // Calculate new pacLimit based on control logic\n            pacLimit = (((pvPac) + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)))) / inverterOnline)\n\n            // Update 'oldPacLimit1' with the new 'pacLimit'\n            oldPacLimit1 = pacLimit;\n\n            // Round pacLimit to one decimal place\n           // pacLimit = parseFloat(pacLimit.toFixed(1));\n\n           // node.warn(`invpac1: ${oldPacLimit1}`);\n            // Ensure pacLimit doesn't exceed pacMaxSetCmd\n            if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            if (pacLimit < 10) pacLimit = 10;\n\n            // Reset case2ZEP if necessary\n            case2ZEP = 0;\n            flow.set('case2ZEP', case2ZEP);\n\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.2.0 force UP\";\n            const logMessage = `1.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n\n        } else {\n            // Increment case2ZEP if caseReset is not reached\n            case2ZEP++;\n            flow.set('case2ZEP', case2ZEP);\n\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.2.1 force UP\";\n            const logMessage = `1.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldPacLimit1', oldPacLimit1);\n        flow.set('P_integral',P_integral);\n        flow.set('P_previous_error',P_previous_error);\n    }\n\n    // Case 3:  > Critical  & < lower ---tune up\n    \n    // Case 4: ZEP meter > 0 & ZEP meter < minload no change\n    else if (zeIac >= zeIacSetCmd && maxPacLimit < pacMaxSetCmd) {\n        if (zeIac > zeIacMaxCmd) {\n            let pacLimit = maxPacLimit - (pacTuneStCmd * pacMaxSetCmd / 1000);\n           // pacLimit = parseFloat(pacLimit.toFixed(1));\n         \n            if (case4ZEP >= caseReset) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.0 current\"\n                // const logMessage = `1.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                // logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.1 current\"\n                // const logMessage = `1.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                // logCsv(logMessage);\n            }\n        }\n        else {\n            pacLimit = pacLimit\n            if (case4ZEP >= caseReset) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.2 current\"\n                // const logMessage = `1.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                // logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.3 current\"\n                // const logMessage = `1.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                // logCsv(logMessage);\n            }\n        }\n          \n    }\n    // Case 5: Stable\n    // else if ((zePac <= zePMinLoad + zePThreshold && zePac >= zePMinLoad - zePThreshold || maxPacLimit <= pacMaxSetCmd )&& zeIac < zeIacSetCmd) {\n    else {   \n        pacLimit = oldPacLimit1;\n       // pacLimit = parseFloat(pacLimit.toFixed(1));\n        // oldPacLimit1 = parseFloat(oldPacLimit1.toFixed(1));\n       // qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('P_integral', 0);\n        flow.set('P_previous_error', 0);\n        if (case5ZEP >= caseReset) {\n            case5ZEP = 0;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.5.0 stable\"\n            const logMessage = `1.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        } else {\n            case5ZEP++;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.5.1 stable\"\n            const logMessage = `1.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        }\n    }\n}\n// ------------------------------------------ Active Power Control Logic End -------------------------------------------------------------------------------\n\n\n// ------------------------------------------ Active Power Control Logic End -------------------------------------------------------------------------------\n// ------------------------------------------ Reactive Power Control Logic Start ----------------------------------------------------------------------------\n//node.warn(`zeQac: ${zeQac}, qaconoffcmd: ${qaconoffcmd}`);\nif (!isNaN(zeQac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && (qaconoffcmd == 1 || svgonoffcmd == 1)) {\n    const now = new Date();\n    const min = now.getMinutes();\n    const hour = now.getHours();\n    //node.warn(`1:${zeQac}, 2:${powselcmd}, 3: ${inverterOnline}, , 4: ${fonoffcmd},5: ${qaconoffcmd}, 6: ${inverterOnline }`)\n    // Select the setpoint based on Slots\n    if (qaconoffcmd == 1 && svgonoffcmd == 1) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            zeCriticalLoad = zeSvgSlot1CriticalLoad;\n            zeMinLoad = zeSvgSlot1MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            zeCriticalLoad = zeSvgSlot2CriticalLoad;\n            zeMinLoad = zeSvgSlot2MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            zeCriticalLoad = zeSvgSlot3CriticalLoad;\n            zeMinLoad = zeSvgSlot3MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            zeCriticalLoad = zeCriticalLoad;\n            zeMinLoad = zeMinLoad;\n            qModeEnable = 1;\n        }\n    }\n    if (qaconoffcmd == 0 && svgonoffcmd == 1) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            zeCriticalLoad = zeSvgSlot1CriticalLoad;\n            zeMinLoad = zeSvgSlot1MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            zeCriticalLoad = zeSvgSlot2CriticalLoad;\n            zeMinLoad = zeSvgSlot2MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            zeCriticalLoad = zeSvgSlot3CriticalLoad;\n            zeMinLoad = zeSvgSlot3MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            qModeEnable = 0;\n        }\n    }\n    if (qaconoffcmd == 1 && svgonoffcmd == 0) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            zeCriticalLoad = zeCriticalLoad;\n            zeMinLoad = zeMinLoad;\n            qModeEnable = 1;\n        }\n    }\n    //node.warn(`svg_status,${hour}`)\n    //node.warn(`setpoint,${svgSlot4StartHour}`)\n    const prevQMinLoad = flow.get(\"prev_zeminQ\");\n    if (zeMinLoad !== prevQMinLoad) {\n        // Value changed  calculate and save\n        //Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminQ\", zeMinLoad);\n        //flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEQ\", 1);\n        flow.set(\"case2ZEQ\", 1);\n        oldQacLimit1 = qacLimit;\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n    } else {\n        oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    }\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    case1ZEQ = flow.get(\"case1ZEQ\")\n    case2ZEQ = flow.get(\"case2ZEQ\")\n    // Case 1: ZE meter < critical load (100VAR); Reactive Power supply to grid  && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    if (zeQac <= (zeMinLoad - zeThreshold) && (maxQacLimit >= -100) && (minQacLimit <= 100)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        if (case1ZEQ >= caseReset) {\n            Inv_Qsetpoint = zeMinLoad\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            //node.warn(`Qerrorcase1: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} , qacLimit: ${(qacLimit)}  `)\n            // if (qacLimit > -12 && qacLimit < 12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            // if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEQ = 0;\n            flow.set('case1ZEQ', case1ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.1.0\";\n            const logMessageQ = `2.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case1ZEQ++;\n            flow.set('case1ZEQ', case1ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.1.1\";\n            const logMessageQ = `2.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n        flow.set(\"Q_integral\", Q_integral);\n        flow.set(\"Q_previous_error\", Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n        //node.warn(`Qerrorcase1final: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} , qacLimit: ${(qacLimit)}  `)\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if ((zeQac >= (zeMinLoad + zeThreshold)) && (maxQacLimit >= -100) && (minQacLimit <= 100)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        if (case2ZEQ >= caseReset) {\n            Inv_Qsetpoint = zeMinLoad\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            // if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            // if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEQ = 0;\n            flow.set('case2ZEQ', case2ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.2.0\";\n            const logMessageQ = `2.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case2ZEQ++;\n            flow.set('case2ZEQ', case2ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.2.1\";\n            const logMessageQ = `2.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n        flow.set(\"Q_integral\", Q_integral);\n        flow.set(\"Q_previous_error\", Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n        //node.warn(`Qerrorcase2: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} `)\n    }\n    //case 5   && qModeEnable === 1\n    else if ((zeQac <= (zeMinLoad + zeThreshold)) && (zeQac >= (zeMinLoad - zeThreshold))) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEQ\", 1);\n        flow.set(\"case2ZEQ\", 1);\n        if (case5ZEQ >= caseReset) {\n            case5ZEQ = 0;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.0 stable\"\n            const logMessageQ = `2.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case5ZEQ++;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.1 stable\"\n            const logMessageQ = `2.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n    }\n}\n// --------------------------------------------------------- Reactive Power Control Logic End ----------------------------------------------------------------------\n// --------------------------------------------------------- Power Factor Control Logic Start ---------------------------------------------------------------------- */\nif (!isNaN(zePf) && powselcmd === 1 && inverterOnlineQ > 0 && fonoffcmd === 1 && pfonoffcmd === 1) {\n    //node.warn(`Final qacLimitMWrite: ${(maxQacLimit1)}, Case: ${zePFMinLoad + zePFThreshold}`)\n    const prevPFMinLoad = flow.get(\"prev_zeminPF\");\n    if (zePFMinLoad !== prevPFMinLoad) {\n        // Value changed  calculate and save\n        //Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminPF\", zePFMinLoad);\n        //flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEPF\", 1);\n        flow.set(\"case2ZEPF\", 1);\n        flow.set(\"case3ZEPF\", 1);\n        flow.set(\"case4ZEPF\", 1);\n        oldQacLimit1 = qacLimit;\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n    } else {\n        oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    }\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    case1ZEPF = flow.get(\"case1ZEPF\")\n    case2ZEPF = flow.get(\"case2ZEPF\")\n    case3ZEPF = flow.get(\"case3ZEPF\")\n    case4ZEPF = flow.get(\"case4ZEPF\")\n    //case1: 1st Quadrant Operation with Actual PF (+ve) is less than Setpoint so need to reduce the Reactive Power Supply or Abosrb from Grid and limit should go from 100% to -100%\n    if (zePf < (zePFMinLoad - zePFThreshold) && (zePac > 180) && zePFMinLoad > 0 && zePf > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`x:${zePFMinLoadnew}`)\n        if (case1ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.1.0\";\n            const logMessagePF = `5.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.1.1\";\n            const logMessagePF = `5.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//case2: Runs Only when Actual is -ve PF and Set is +ve PF for short time when P>0 \n    else if (zePf < (zePFMinLoad - zePFThreshold) && (zePac > 180) && zePf <= 1 && zePFMinLoad > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`y:${zePFMinLoadnew}`)\n        if (case1ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.7.0\";\n            const logMessagePF = `5.7.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.7.1\";\n            const logMessagePF = `5.7.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    } //Case 3: Runs Only when Actual is -ve PF and Set is +ve PF for short time when P<0\n    else if (zePf < (zePFMinLoad + zePFThreshold) && (zePac < 0) && zePf <= 1 && zePFMinLoad > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`z:${zePFMinLoadnew}`)\n        if (case2ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.6.0\";\n            const logMessagePF = `5.6.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.6.1\";\n            const logMessagePF = `5.6.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Maximum Demand Penalty Avoidance Case during Night Time or Improt conditions \n    else if (zeSac >= 1400 && zePac < 0) {\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit * 10;\n        msg.caseq = \"5.9.0\";\n        const logMessagePF = `5.9.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }//If there is not Much Active Power / DC available the Make Q Command as Zero to not force the Inverter.\n    else if (zePac <= 180 && zePac >= 0) {\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit * 10;\n        msg.caseq = \"5.9.1\";\n        const logMessagePF = `5.9.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }//Case4: Setpoint is less than PF actual and also PF setpoint is +ve and so Need to Delivery or Supply more Q to grid; Limits goes to -100 to + 100\n    else if (((zePf > (zePFThreshold + zePFMinLoad))) && zePf >= -1 && zePFMinLoad > 0 && minQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`a:${zePFMinLoadnew}`)\n        if (case2ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.2.0\";\n            const logMessagePF = `5.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.2.1\";\n            const logMessagePF = `5.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 5: Actual PF & PF Setpoints are -ve and Actual PF is > Setpoint and so reduce the Q Consumption; Limit goes from -100 to + 100\n    else if (zePf > (zePFThreshold + zePFMinLoad) && zePFMinLoad < 0 && zePf < 0 && maxQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad + zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad + zePFThreshold) * (zePFMinLoad + zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`b:${zePFMinLoadnew}`)\n        if (case3ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case3ZEPF = 0;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.3.0\";\n            const logMessagePF = `5.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case3ZEPF++;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.3.1\";\n            const logMessagePF = `5.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 6: Set Point is -ve PF and Actual is +ve PF and so limit should do from +100 to -100\n    else if ((zePf < zePFMinLoad || zePf >= ((-zePFThreshold) - (zePFMinLoad))) && (zePFMinLoad < 0) && (zePf >= -1) && (maxQacLimit < 100) && (minQacLimit > -101)) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`c:${zePFMinLoadnew}`)\n        //node.warn(`(1:${((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)) })`)\n        if (case4ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case4ZEPF = 0;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.4.0\";\n            const logMessagePF = `5.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case4ZEPF++;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.4.1\";\n            const logMessagePF = `5.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 7: Stable Case \n    else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        if (case5ZEPF >= caseReset) {\n            case5ZEPF = 0;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.5.0\"\n            const logMessagePF = `5.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case5ZEPF++;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.5.1\"\n            const logMessagePF = `5.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n    }\n}\n// ------------------------------------------------------ Power Factor Logic End -----------------------------------------------------------------------------\n// ------------------------------------------------------ Voltage Control Logic Start -------------------------------------------------------------------------\nif (!isNaN(zeUac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && (uaconoffcmd === 1 || lvrtHvrtOnOffCmd === 1)) {\n    ratedQCapacity = msg.ratedPcapacity * 0.33\n    oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    qacLimit = oldQacLimit1\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    //node.warn(`deadBandMax: ${zeUac}, droopMax: ${droopMax}`);\n    //node.warn(`deadBandMin: ${deadBandMin}, droopMin: ${droopMin}`);\n    //let zeUacold = flow.get(\"zeUacold\")\n    //if (zeUacold === undefined || isNaN(zeUacold)) { zeUacold = 132; }\n    if ((zeUac > (deadBandMax)) && (zeUac <= droopMax)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMax) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n        if ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold) || ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold))))) {\n            if (case1ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},Q_act:${zeQac},Q_CMD:${qacLimit}`)\n                if (zeQac > (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case1ZEU = 0;\n                flow.set(\"case1ZEU\", case1ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.1.0\"\n                const logMessageU = `3.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case1ZEU++;\n                flow.set(\"case1ZEU\", case1ZEU);\n                msg.qacLimitMWrite = oldQacLimit1 * 10;\n                msg.caseq = \"3.1.1\"\n                const logMessageU = `3.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.1.5\"\n            const logMessageU = `3.1.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if (zeUac < (deadBandMin) && zeUac >= droopMin) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMin) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n        if ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold) || ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold))))) {\n            //node.warn(`zeThreshold:${((Inv_Qsetpoint*1000) - zeThreshold)},Q_error:${((Inv_Qsetpoint*1000) + zeThreshold)}`)\n            if (case2ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},zeQaC:${zeQac}`)\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                if (zeQac > (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case2ZEU = 0;\n                flow.set(\"case2ZEU\", case2ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.2.0\"\n                const logMessageU = `3.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case2ZEU++;\n                flow.set(\"case2ZEU\", case2ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.2.1\"\n                const logMessageU = `3.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.2.5\"\n            const logMessageU = `3.2.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    // case 3 \n    /*else if ((zePac > 0) && (zeUac >= deadBandMin) && (zeUac <= deadBandMax)) {\n        if (zePac > 0 && uaconoffcmd === 1) {\n            qacMaxSet = 0\n            qacLimit = qacMaxSet * 1000\n            oldQacLimit1 = qacLimit\n            if (case3ZEU >= caseReset) {\n                case3ZEU = 0;\n                flow.set(\"oldQacLimit1\", oldQacLimit1);\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.0\"\n                const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case3ZEU++;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.1\"\n                const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n        }\n    }*/\n    else if ((zePac > 0) && (zeUac >= deadBandMin) && (zeUac <= deadBandMax)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMin) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100))) * 0\n        if ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold) || ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold))))) {\n            //node.warn(`zeThreshold:${((Inv_Qsetpoint*1000) - zeThreshold)},Q_error:${((Inv_Qsetpoint*1000) + zeThreshold)}`)\n            if (case3ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},zeQaC:${zeQac}`)\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                if (zeQac > 0) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < 0) {\n                    if (qacLimit < 12 && qacLimit > 0) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case3ZEU = 0;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.0\"\n                const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case3ZEU++;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.1\"\n                const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.3.5\"\n            const logMessageU = `3.3.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    //case 4\n    // case 5 \n    else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        case5ZEU++;\n        flow.set(\"case5ZEU\", case5ZEU);\n        msg.qacLimitMWrite = qacLimit * 10;\n        msg.caseq = \"3.5.0\"\n        const logMessageU = `3.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n        logCsvU(logMessageU);\n    }\n}\n// ------------------------------------------------------- Voltage Control Logic End -----------------------------------------------------------------------------------\n// ------------------------------- Frequency COntrol Start --------------------------------------------------\nif (!isNaN(zeFac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && faconoffcmd === 1) {\n    if ((zePac > 0) && (((zeFMinLoad - zeFThreshold) > zeFac) || ((zeFMinLoad + zeFThreshold) < zeFac)) && (zeIac < zeIacSetCmd)) {\n        //let delF = zeFMinLoad - zeFac ;\n        const ratedPcapacity = msg.ratedPcapacity\n        const ratedFrequency = msg.ratedFrequency\n        let delF = ratedFrequency - zeFac;\n        let zeFacOld = flow.get(\"zeFacOld\")\n        if (zeFacOld === undefined || isNaN(zeFacOld)) {\n            zeFacOld = 50;\n        }\n        oldPacLimit1 = flow.get(\"oldPacLimit1\")\n        if ((case1ZEF >= caseReset) && (zeFac != zeFacOld)) {\n            const pacLimitnew = (((zePac / 1000) + (((delF * ratedPcapacity) / (fDroopCmd * ratedFrequency)) * 100)) / inverterOnline)\n            //node.warn(`paclimit:${pacLimitnew}, zePac:${zePac} `) \n            pacLimit = (pacLimitnew * 1000)\n            oldPacLimit1 = pacLimit\n            node.warn(\"oldPacLimit1\" + oldPacLimit1)\n            zeFacOld = zeFac\n            case1ZEF = 0;\n            flow.set(\"zeFacOld\", zeFacOld)\n            flow.set(\"case1ZEF\", case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.1.0\"\n            const logMessageF = `4.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvF(logMessageF);\n        } else {\n            pacLimit = oldPacLimit1\n            case1ZEF++;\n            flow.set(\"case1ZEF\", case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.1.1 \"\n            const logMessageF = `4.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvF(logMessageF);\n        }\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n    } else if ((zeFMinLoad + zeFThreshold) == zeFac) {\n        flow.set(\"zeFacOld\", 50)\n        pacLimit = msg.facCapacityLimit * (blkPacMaxCmd)\n        case2ZEF++;\n        flow.set(\"case7ZEF\", case2ZEF);\n        msg.pacLimitMWrite = pacLimit * 10;\n        msg.case = \"4.5.0 \"\n        const logMessageF = `4.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n        logCsvF(logMessageF);\n    }\n}\n// -------------------------------------------------------Frequency Control End ----------------------------------------------------------------------------------\n// Save the pacLimit if it has been modified\nif (msg.pacLimitMWrite !== undefined) {\n    //node.warn(\"pacLimitMWrite was not set, setting default to Max limit\");\n    //msg.pacLimitMWrite = ..; // Setting a default value if none of the conditions met\n    //msg.case = \"Default Case: pacLimitMWrite was not set explicitly\";\n    global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n} else {\n    flow.set('P_integral', 0);\n    flow.set('P_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.pacLimitMWrite = 2772; // Setting a default value if none of the conditions met\n    global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n    flow.set('oldPacLimit1', msg.pacLimitMWrite / 10)\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\nlet actualQac\n// Save the qacLimit if it has been modified\nif (msg.qacLimitMWrite !== undefined) {\n    //actualQac = msg.qacLimitMWrite * inverterOnline;\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);\n} else {\n    flow.set('Q_integral', 0);\n    flow.set('Q_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacLimitMWrite = 0; // Setting a default value if none of the conditions met\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);\n    flow.set('oldQacLimit1', msg.qacLimitMWrite / 10)\n    msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\n/* if (msg.qacRefSelMWrite !== undefined) {\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n} else {\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacRefSelMWrite = 162; // Setting a default value if none of the conditions met\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n} */\n//node.warn(`Final pacLimitMWrite: ${msg.pacLimitMWrite}, Case: ${msg.case}`);\n//node.warn(`Final qacLimitMWrite: ${msg.qacLimitMWrite}, Case: ${msg.caseq}`);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 1270,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "2bf2d718bcd5124c",
        "type": "mqtt in",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "",
        "topic": "INC_INV2",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6900a3972037d1fd",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 180,
        "y": 640,
        "wires": [
            [
                "a95d2b7f8e7eda14",
                "be55ee41073e2b8f"
            ]
        ]
    },
    {
        "id": "a95d2b7f8e7eda14",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "debug 5",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 350,
        "y": 600,
        "wires": []
    },
    {
        "id": "be55ee41073e2b8f",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "function 3",
        "func": "var obj = {};\nfor (var i=0; i< msg.payload.length; i++) {\n    var tag_val = msg.payload[i].bd + '.' + msg.payload[i].f\n    var value = msg.payload[i].value\n    global.set(tag_val, value)\n    obj.payload = {tag_val: tag_val, value: value}\n    node.send(obj)\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 640,
        "wires": [
            [
                "ca473a81103b480e"
            ]
        ]
    },
    {
        "id": "ca473a81103b480e",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "debug 6",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 510,
        "y": 640,
        "wires": []
    },
    {
        "id": "6bd0562bc27918d9",
        "type": "mqtt in",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "",
        "topic": "INC_INV3",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6900a3972037d1fd",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 180,
        "y": 740,
        "wires": [
            [
                "497111be4e6b67e2",
                "5d53606328303e16"
            ]
        ]
    },
    {
        "id": "497111be4e6b67e2",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "debug 7",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 350,
        "y": 700,
        "wires": []
    },
    {
        "id": "5d53606328303e16",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "function 4",
        "func": "var obj = {};\nfor (var i=0; i< msg.payload.length; i++) {\n    var tag_val = msg.payload[i].bd + '.' + msg.payload[i].f\n    var value = msg.payload[i].value\n    global.set(tag_val, value)\n    obj.payload = {tag_val: tag_val, value: value}\n    node.send(obj)\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 740,
        "wires": [
            [
                "c7e73ddbf6cdd7e9"
            ]
        ]
    },
    {
        "id": "c7e73ddbf6cdd7e9",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "048fc7bc2feb5fda",
        "name": "debug 8",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 510,
        "y": 740,
        "wires": []
    },
    {
        "id": "d064234a989b3b38",
        "type": "inject",
        "z": "f313dfa39a2c857c",
        "g": "2e078411276e5df3",
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 810,
        "y": 700,
        "wires": [
            [
                "0c27b454767bbf24"
            ]
        ]
    },
    {
        "id": "02340cc8d02f1ab1",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "g": "2e078411276e5df3",
        "name": "debug 9",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1140,
        "y": 660,
        "wires": []
    },
    {
        "id": "f95a42d91f64ed9b",
        "type": "mqtt out",
        "z": "f313dfa39a2c857c",
        "g": "2e078411276e5df3",
        "name": "",
        "topic": "RM_COMM",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "305cedf81ae151ea",
        "x": 1150,
        "y": 700,
        "wires": []
    },
    {
        "id": "0c27b454767bbf24",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "g": "2e078411276e5df3",
        "name": "function 6",
        "func": "const RM_COMM = global.get(\"RM_COMM\") || {};\nlet payload = {};\n\nfor (let block in RM_COMM) {\n    const inv = RM_COMM[block] || {};\n\n    payload[block] = {\n        INV01: inv.INV01 ?? null,\n        INV02: inv.INV02 ?? null\n    };\n}\n\nmsg.payload = payload;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 700,
        "wires": [
            [
                "02340cc8d02f1ab1",
                "f95a42d91f64ed9b"
            ]
        ]
    },
    {
        "id": "56c8abf1c6909b83",
        "type": "inject",
        "z": "f313dfa39a2c857c",
        "d": true,
        "name": "inject",
        "props": [],
        "repeat": "",
        "crontab": "*/1 3-7 * * *",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 690,
        "y": 400,
        "wires": [
            [
                "48c3041570dc161f"
            ]
        ]
    },
    {
        "id": "48c3041570dc161f",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "d": true,
        "name": "Cron_func",
        "func": "const RM_COMM = global.get(\"RM_COMM\") || {};\nlet payload = {};\n\n// Get current hour\nconst now = new Date();\nconst hour = now.getHours();\n\n// Check if current time is between 3 AM and 8 AM (exclusive)\nconst isInTimeWindow = hour >= 4 && hour < 7;\n\nfor (let block in RM_COMM) {\n    const inv = RM_COMM[block] || {};\n\n    if (isInTimeWindow) {\n        // During 38 AM, force value to 1\n        payload[block] = {\n            INV01: 1,\n            INV02: 1\n        };\n        // node.warn(`Force 1 for ${block}.INV01`);\n    } else {\n        // Otherwise, use actual value\n        payload[block] = {\n            INV01: inv.INV01 ?? null,\n            INV02: inv.INV02 ?? null\n        };\n        //node.warn(`Actual value for ${block}.INV01  ${inv.INV01}`);\n    }\n}\n\nmsg.payload = payload;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 360,
        "wires": [
            [
                "a6d43d1be544f2df"
            ]
        ]
    },
    {
        "id": "a6d43d1be544f2df",
        "type": "debug",
        "z": "f313dfa39a2c857c",
        "d": true,
        "name": "debug",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1010,
        "y": 360,
        "wires": []
    },
    {
        "id": "6412e1c5c9b4c540",
        "type": "inject",
        "z": "f313dfa39a2c857c",
        "d": true,
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 690,
        "y": 360,
        "wires": [
            [
                "48c3041570dc161f"
            ]
        ]
    },
    {
        "id": "94d8d348d2bdf8eb",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "d": true,
        "name": "Cron_func",
        "func": "const RM_COMM = global.get(\"RM_COMM\") || {};\nlet payload = {};\n\n// Get current hour\nconst now = new Date();\nconst hour = now.getHours();\n\n// Between 3 AM and 8 AM (exclusive)\nconst isInTimeWindow = hour >= 3 && hour < 8;\n\nfor (let block in RM_COMM) {\n    const inv = RM_COMM[block] || {};\n\n    // if (isInTimeWindow) {\n    //     node.warn(`Force 1 for ${block}.INV01`);\n    // } else {\n    //     node.warn(`Actual value for ${block}.INV01  ${inv.INV01}`);\n    // }\n\n    payload[block] = {\n        INV01: isInTimeWindow ? 1 : (inv.INV01 ?? null),\n        INV02: isInTimeWindow ? 1 : (inv.INV02 ?? null)\n    };\n}\n\nmsg.payload = payload;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "6bc07be721c6aeb0",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "d": true,
        "name": "PPC_Logic_AP70",
        "func": "const caseReset = 2; // Threshold for resetting cases\n\n// Function for File handling\nconst fd = global.get('fs');\n\n// Function to rename CSV files\nfunction renameCsvFiles(filePath) {\n    const files = fd.readdirSync(filePath).filter(file => file.endsWith('.csv'));\n    files.forEach(file => {\n        const oldPath = path.join(filePath, file);\n        const newPath = path.join(filePath, `${file.slice(0, -4)}.unsent`);\n        fd.renameSync(oldPath, newPath);\n    });\n}\n\n// Function to get epoch time\nfunction getEpochTime() {\n    // Get the current time and round down to the nearest 300 seconds\n    const now = Math.floor(Date.now() / 1000); // Convert to seconds\n    return now - (now % 300); // Round down to the nearest 300 seconds\n}\n\n// Function to log PPC Active Power Logic CSV\nfunction logCsv(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_01.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Reactive Power Logic CSV\nfunction logCsvQ(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_02.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Power Factor Logic CSV\nfunction logCsvPF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_05.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Voltage Logic CSV\nfunction logCsvU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_03.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Q/U Logic CSV\nfunction logCsvQU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_07.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Frequency Logic CSV\nfunction logCsvF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_04.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Ramp Logic CSV\nfunction logCsvR(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_06.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Set last file pack time\nconst TS = getEpochTime();\nflow.set('lastFilePackTime', TS);\n\n// Rename CSV files if needed\nif (flow.get('lastFilePackTime') < TS) {\n    renameCsvFiles('/mnt/jffs2/dglog');\n    flow.set('lastFilePackTime', TS);\n}\n\n// UI Settings value for P Control\nlet pacMaxSetCmd = global.get(\"PAC_MAX_SET_RX1\")\nif (pacMaxSetCmd === undefined || isNaN(pacMaxSetCmd)) { pacMaxSetCmd = 20000; }\nlet blkPacMaxCmd = global.get(\"BLOCK_PAC_MAX_SET_RX1\")\nif (blkPacMaxCmd === undefined || isNaN(blkPacMaxCmd)) { blkPacMaxCmd = 20000; }\nlet pacLLSetCmd  = global.get(\"PAC_CL_SET_RX\")\nif (pacLLSetCmd === undefined || isNaN(pacLLSetCmd)) { pacLLSetCmd = 2; }\nlet pacULSetCmd  = global.get(\"PAC_ULL_SET_RX\")\nif (pacULSetCmd === undefined || isNaN(pacULSetCmd)) { pacULSetCmd = 1; }\nconst pacGRSetCmd  = global.get(\"PAC_GR_SET_RX\")\nconst pacTuneStCmd = global.get(\"PAC_TUNE_ST_CONST_RX\")\nconst pacIncconstCmd = global.get(\"PAC_INCR_SET_RX\")\nconst pacDecconstCmd = global.get(\"PAC_DECR_CONST_RX\")\n\n// UI Settings value for Q Control\nlet qacMaxSetCmd =  global.get(\"QAC_MAX_SET_RX1\")\nif (qacMaxSetCmd === undefined || isNaN(qacMaxSetCmd)) { qacMaxSetCmd = 6600; }\nlet blkQacMaxCmd =  global.get(\"BLOCK_QAC_MAX_SET_RX1\")\nif (blkQacMaxCmd === undefined || isNaN(blkQacMaxCmd)) { blkQacMaxCmd = 6600; }\nlet qacLLSetCmd =  global.get(\"QAC_CL_SET_RX\")\nif (qacLLSetCmd === undefined || isNaN(qacLLSetCmd)) { qacLLSetCmd = 2; }\nlet qacULSetCmd =  global.get(\"QAC_ULL_SET_RX\")\nif (qacULSetCmd === undefined || isNaN(qacULSetCmd)) { qacULSetCmd = 1; }\nconst qacGRSetCmd =  global.get(\"QAC_GR_SET_RX\")\nlet tuneStep =  global.get(\"QAC_TUNE_ST_CONST_RX\")\nconst qacIncConstCmd =  global.get(\"QAC_INCR_SET_RX\")\nconst qacDecConstCmd =  global.get(\"QAC_DECR_CONST_RX\")\n\n// UI Settings value for SVG Control\nconst svgSlot1StartHour = global.get(\"SVG_SLOT1_START_HOUR_RX1\")\nconst svgSlot2StartHour = global.get(\"SVG_SLOT2_START_HOUR_RX1\")\nconst svgSlot3StartHour = global.get(\"SVG_SLOT3_START_HOUR_RX1\")\nconst svgSlot4StartHour = global.get(\"SVG_SLOT4_START_HOUR_RX1\")\nconst svgSlot1StartMin = global.get(\"SVG_SLOT1_START_MIN_RX1\")\nconst svgSlot2StartMin = global.get(\"SVG_SLOT2_START_MIN_RX1\")\nconst svgSlot3StartMin = global.get(\"SVG_SLOT3_START_MIN_RX1\")\nconst svgSlot4StartMin = global.get(\"SVG_SLOT4_START_MIN_RX1\")\nconst svgSlot1StopHour = global.get(\"SVG_SLOT1_STOP_HOUR_RX1\")\nconst svgSlot2StopHour = global.get(\"SVG_SLOT2_STOP_HOUR_RX1\")\nconst svgSlot3StopHour = global.get(\"SVG_SLOT3_STOP_HOUR_RX1\")\nconst svgSlot4StopHour = global.get(\"SVG_SLOT4_STOP_HOUR_RX1\")\nconst svgSlot1StopMin = global.get(\"SVG_SLOT1_STOP_MIN_RX1\")\nconst svgSlot2StopMin = global.get(\"SVG_SLOT2_STOP_MIN_RX1\")\nconst svgSlot3StopMin = global.get(\"SVG_SLOT3_STOP_MIN_RX1\")\nconst svgSlot4StopMin = global.get(\"SVG_SLOT4_STOP_MIN_RX1\")\n\n// UI Settings Value for PF Control\nlet pfLLSetCmd = global.get(\"PF_LL_SET_RX\")\nif (pfLLSetCmd === undefined || isNaN(pfLLSetCmd)) { pfLLSetCmd = 0.004; }\nlet pfULSetcmd = global.get(\"PF_UL_SET_RX\")\nif (pfULSetcmd === undefined || isNaN(pfULSetcmd)) { pfULSetcmd = 0.004; }\nlet pfGRSetCmd2 = global.get(\"PF_GR_SET_RX2\")\nif (pfGRSetCmd2 === undefined || isNaN(pfGRSetCmd2)) { pfGRSetCmd2 = 10; }\nlet pfGRSetCmd = global.get(\"PF_GR_SET_RX\")\nif (pfGRSetCmd === undefined || isNaN(pfGRSetCmd)) { pfGRSetCmd = 10; }\nlet pfDecConstCmd = global.get(\"PF_DECR_CONST_RX\")\nif (pfDecConstCmd === undefined || isNaN(pfDecConstCmd)) { pfDecConstCmd = 20; }\nlet pfIncConstCmd = global.get(\"PF_INCR_SET_RX\")\nif (pfIncConstCmd === undefined || isNaN(pfIncConstCmd)) { pfIncConstCmd = 20; }\n\n// UI Settings Value for UAC Control\nlet quULSetCmd = global.get(\"UAC_ULL_SET_RX\") \nif (quULSetCmd === undefined || isNaN(quULSetCmd)) { quULSetCmd = 1; }\nlet quLLSetCmd = global.get(\"UAC_CL_SET_RX\") \nif (quLLSetCmd === undefined || isNaN(quLLSetCmd)) { quLLSetCmd = 1; }\nlet quGRSetCmd = global.get(\"UAC_GR_SET_RX\") \nif (quGRSetCmd === undefined || isNaN(quGRSetCmd)) { quGRSetCmd = 0; }\nlet quTuneStCmd = global.get(\"UAC_TUNE_ST_CONST_RX\") \nif (quTuneStCmd === undefined || isNaN(quTuneStCmd)) { quTuneStCmd = 2; }\nlet quIncConstCmd = global.get(\"UAC_INCR_SET_RX\") \nif (quIncConstCmd === undefined || isNaN(quIncConstCmd)) { quIncConstCmd = 4; }\nlet quDecConstCmd = global.get(\"UAC_DECR_CONST_RX\") \nif (quDecConstCmd === undefined || isNaN(quDecConstCmd)) { quDecConstCmd = 4; }\n\n// UI Settings Value for FAC Control\nlet facULSetCmd = global.get(\"FAC_UL_SET_CMD\")\nif (facULSetCmd === undefined || isNaN(facULSetCmd)) { facULSetCmd = 0; }\nlet facLLSetCmd = global.get(\"FAC_LL_SET_CMD\")\nif (facLLSetCmd === undefined || isNaN(facLLSetCmd)) { facLLSetCmd = 0.3; }\nlet facCULSetCmd = global.get(\"FAC_CUL_SET_CMD\")\nif (facCULSetCmd === undefined || isNaN(facCULSetCmd)) { facCULSetCmd = 2.0; }\nlet facCLLSetCmd = global.get(\"FAC_CLL_SET_CMD\")\nif (facCLLSetCmd === undefined || isNaN(facCLLSetCmd)) { facCLLSetCmd = 2.5; }\nlet facGRSetCmd = global.get(\"FAC_GR_SET_CMD\")\nif (facGRSetCmd === undefined || isNaN(facGRSetCmd)) { facGRSetCmd = 0; }\nlet facTuneStCmd = global.get(\"FAC_TUNE_ST_CONST_CMD\")\nif (facTuneStCmd === undefined || isNaN(facTuneStCmd)) { facTuneStCmd = 100; }\nlet facIncConstCmd = global.get(\"FAC_INCR_CONST_CMD\")\nif (facIncConstCmd === undefined || isNaN(facIncConstCmd)) { facIncConstCmd = 1; }\nlet facDecConstCmd = global.get(\"FAC_DECR_CONST_CMD\")\nif (facDecConstCmd === undefined || isNaN(facDecConstCmd)) { facDecConstCmd = 1; }\nlet fDroopCmd = global.get(\"FAC_DROOP_SET_RX\")\nif (fDroopCmd === undefined || isNaN(fDroopCmd)) { fDroopCmd = 5; }\n\n// UI Settings Value for RAMP Control\nconst rampTuneStCmd = global.get(\"RAMP_TUNE_ST_CONST_RX\")\nconst rampIncconstCmd = global.get(\"RAMP_INCR_CONST_RX\")\nconst rampDecconstCmd = global.get(\"RAMP_DECR_CONST_RX\")\nconst rampOnOffCmd = msg.ramponoff\n\n// UI Settings Value for VRT Control\nconst lvrthvrtULSetCmd = global.get(\"LVRT_HVRT_ULL_SET_RX\")\nconst lvrthvrtLLSetCmd = global.get(\"LVRT_HVRT_CL_SET_RX\")\n\n// Setpoint & Simulation Value for P Control\nconst dev = msg.device\nconst pacOnOffCmd = msg.paconoff\nconst fonoffcmd = msg.fonoff\nconst powselcmd = msg.selpc\nconst zePac = msg.gridpac\nconst zePMinLoad = (msg.pacpc * 1000) \nconst inverterOnline = msg.inverterOnline\nconst inverterOnlineQ = msg.inverterOnlineQ\nlet PAC_LIMIT = msg.paclimit\nif (PAC_LIMIT === undefined || isNaN(PAC_LIMIT)) { PAC_LIMIT = 1000; }\nconst zeIacMaxCmd = msg.maxcurrent\nconst zeIacSetCmd = msg.setcurrent\nconst zeIac = msg.gridiac\nconst pvPac = msg.invpac\nconst Kp = msg.kp\nconst Ti = msg.ti\nconst Kd = msg.kd\nlet Inv_Setpoint\nlet P_error\nlet P_integral = flow.get('P_integral') || 0;\nlet P_derivative\nlet P_previous_error = flow.get('P_previous_error') || 0;\n\nconst zeSac = global.get(\"CR.VR_EM.SAC\")\n\n\n// Setpoint & Simulation Value for Q Control\nconst qaconoffcmd = msg.qaconoff\nconst zeQac = msg.gridqac \nlet zeMinLoad = ((msg.qacpc * 1000))\nlet QAC_LIMIT = msg.qaclimit\nif (QAC_LIMIT === undefined || isNaN(QAC_LIMIT)) { QAC_LIMIT = 0; }\nconst zePfSetCmd = msg.setpf\nconst zepfMaxLoad = msg.maxpf\nlet zePf = msg.gridpf * 0.001\nzePf = parseFloat(zePf.toFixed(3));\nconst pvQac = msg.invqac \nconst Kpq = msg.kpq\nconst Tiq = msg.tiq\nconst Kdq = msg.kdq\nlet Inv_Qsetpoint\nlet Q_error\n//let Q_integral\nlet Q_integral = flow.get('Q_integral') || 0;\n//if (Q_integral === undefined || isNaN(Q_integral)) { Q_integral = 0; }\nlet Q_derivative\nlet Q_previous_error = flow.get('Q_previous_error') || 0;\nlet qacRefSel = msg.qacrefsel\n\n\n\n// Setpint Value for SVG Control\nconst svgonoffcmd = msg.svgonoff\nconst svgslot1pccmd = msg.svgslot1pc\nconst svgslot2pccmd = msg.svgslot2pc\nconst svgslot3pccmd = msg.svgslot3pc\n\n// Setpoint & Simulation Value for PF Control\nconst pfonoffcmd = msg.pfonoff\nconst zePFMinLoad = msg.pfpc\nconst zePFThreshold = pfULSetcmd\n\n// Setpoint & Simulation Value for U Control\nconst uaconoffcmd = msg.uaconoff\nconst zeUMinLoad = msg.uacpc\nconst zeUac = (msg.griduac * 0.01)\nlet zeUThreshold = (zeUMinLoad * (quULSetCmd/100))\nlet zeUCriticalLoad = zeUMinLoad - ((quLLSetCmd / 100) * zeUMinLoad);\nlet qacMaxSet\nlet ratedQCapacity\nconst ratedvoltage = msg.Vrated\nconst  droopPercentage = msg.Vdroop\nconst dbPercentage = quULSetCmd\nconst droopDeandbandPercentage = msg.VDdroop\n\n// Setpoint & Simulation Value for Q/U Control\nconst quonoffcmd = msg.quonoff\n\n// Voltage Droop Calculation\nconst dbThreshold = (dbPercentage * ratedvoltage) / 100\nconst droopThreshold = (droopDeandbandPercentage * ratedvoltage) / 100\nconst deadBandMax = ratedvoltage + dbThreshold\nconst deadBandMin = ratedvoltage - dbThreshold\nconst droopMax = ratedvoltage + droopThreshold\nconst droopMin = ratedvoltage - droopThreshold\n\n// Setpoint & Simulation Value for VRT Control\nconst lvrtHvrtOnOffCmd = msg.lvrthvrtonoff\nconst zelvrthvrtCriticalLoad = (zeUMinLoad * (lvrthvrtULSetCmd / 100));\nconst zelvrthvrtThreshold = zeUMinLoad - ((lvrthvrtLLSetCmd / 100) * zeUMinLoad);\n\n// Setpoint & Simulation Value for F Control\nconst faconoffcmd = msg.faconoff\nconst zeFMinLoad = msg.facpc\nconst zeFac = (msg.gridfac * 0.01)\nconst zeFCriticalLoad = facLLSetCmd\nconst zeFUCriticalLoad = facCULSetCmd\nconst zeFLCriticalLoad = facCLLSetCmd\nconst zeFThreshold = facULSetCmd \nlet pacLimitdel\n\n// Initialize pacLimit and other variables\nlet maxPacLimit = (PAC_LIMIT/10);\nlet oldPacLimit1 = flow.get('oldPacLimit1') || 0;\nlet oldQacLimit1 = flow.get('oldQacLimit1') || 0;\nlet oldQacLimit2 = flow.get('oldQacLimit2') || 0;\n\nlet minPacLimit = maxPacLimit;\nconst invPacLimit = (PAC_LIMIT / 10); // Assuming this comes from msg\n\nconst zePCriticalLoad = zePMinLoad - ((pacLLSetCmd / 100) * blkPacMaxCmd)\nconst zePThreshold = (pacULSetCmd / 100) * blkPacMaxCmd\n\n// Update max and min limits based on invPacLimit\nif (!isNaN(invPacLimit)) {\n    if (invPacLimit > maxPacLimit) maxPacLimit = invPacLimit;\n    if (invPacLimit < minPacLimit) minPacLimit = invPacLimit;\n}\n\nlet pacLimit = maxPacLimit;\nlet oldPacLimit = pacLimit;\n\n// Initialize qacLimit and other variables\nlet maxQacLimit = ((QAC_LIMIT / inverterOnlineQ) / qacMaxSetCmd) * 100;\nlet minQacLimit = maxQacLimit;\nconst invQacLimit = ((QAC_LIMIT / inverterOnlineQ) / qacMaxSetCmd) * 100; // Assuming this comes from msg\n\nlet zeCriticalLoad = zeMinLoad - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeThreshold = (qacULSetCmd / 100) * blkQacMaxCmd\n\n//SVG Variables\nconst zeSvgSlot1MinLoad = svgslot1pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot1CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\n\nconst zeSvgSlot2MinLoad = svgslot2pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot2CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\n\nconst zeSvgSlot3MinLoad = svgslot3pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot3CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\n\nlet qModeEnable\n\n// Update max and min limits based on invQacLimit\nif (!isNaN(invQacLimit)) {\n    if (invQacLimit > maxQacLimit) maxQacLimit = invQacLimit;\n    if (invQacLimit < minQacLimit) minQacLimit = invQacLimit;\n}\n\nlet qacLimit = maxQacLimit;\nlet oldQacLimit = QAC_LIMIT;\nlet qacLimitW = qacLimit;\nlet oldQacLimitW = qacLimit;\nlet pvQacW = qacLimit;\n\nmsg.pacLimitMWrite = undefined; // Initialize msg.pacLimitMWrite to undefined to identify if it remains unset\nmsg.qacLimitMWrite = undefined; // Initialize msg.qacLimitMWrite to undefined to identify if it remains unset\nmsg.qacRefSelMWrite = undefined; \n\n// PPC P Control Casereset\nlet case1ZEP = flow.get('case1ZEP');\nif (case1ZEP === undefined || isNaN(case1ZEP)) { case1ZEP = 5; }\nlet case2ZEP = flow.get('case2ZEP');\nif (case2ZEP === undefined || isNaN(case2ZEP)) { case2ZEP = 5; }\nlet case3ZEP = flow.get('case3ZEP');\nif (case3ZEP === undefined || isNaN(case3ZEP)) { case3ZEP = 5; }\nlet case4ZEP = flow.get('case4ZEP');\nif (case4ZEP === undefined || isNaN(case4ZEP)) { case4ZEP = 5; }\nlet case5ZEP = flow.get('case5ZEP');\nif (case5ZEP === undefined || isNaN(case5ZEP)) { case5ZEP = 5; }\n\n\n// PPC Q Control Casereset\nlet case1ZEQ = flow.get('case1ZEQ');\nif (case1ZEQ === undefined || isNaN(case1ZEQ)) { case1ZEQ = 5; }\nlet case2ZEQ = flow.get('case2ZEQ');\nif (case2ZEQ === undefined || isNaN(case2ZEQ)) { case2ZEQ = 5; }\nlet case3ZEQ = flow.get('case3ZEQ');\nif (case3ZEQ === undefined || isNaN(case3ZEQ)) { case3ZEQ = 5; }\nlet case4ZEQ = flow.get('case4ZEQ');\nif (case4ZEQ === undefined || isNaN(case4ZEQ)) { case4ZEQ = 5; }\nlet case5ZEQ = flow.get('case5ZEQ');\nif (case5ZEQ === undefined || isNaN(case5ZEQ)) { case5ZEQ = 5; }\n\n// PPC PF Control Casereset\nlet case1ZEPF = flow.get('case1ZEPF');\nif (case1ZEPF === undefined || isNaN(case1ZEPF)) { case1ZEPF = 5; }\nlet case2ZEPF = flow.get('case2ZEPF');\nif (case2ZEPF === undefined || isNaN(case2ZEPF)) { case2ZEPF = 5; }\nlet case3ZEPF = flow.get('case3ZEPF');\nif (case3ZEPF === undefined || isNaN(case3ZEPF)) { case3ZEPF = 5; }\nlet case4ZEPF = flow.get('case4ZEPF');\nif (case4ZEPF === undefined || isNaN(case4ZEPF)) { case4ZEPF = 5; }\nlet case5ZEPF = flow.get('case5ZEPF');\nif (case5ZEPF === undefined || isNaN(case5ZEPF)) { case5ZEPF = 5; }\n\n// PPC U Control Casereset\nlet case1ZEU = flow.get('case1ZEU');\nif (case1ZEU === undefined || isNaN(case1ZEU)) { case1ZEU = 5; }\nlet case2ZEU = flow.get('case2ZEU');\nif (case2ZEU === undefined || isNaN(case2ZEU)) { case2ZEU = 5; }\nlet case3ZEU = flow.get('case3ZEU');\nif (case3ZEU === undefined || isNaN(case3ZEU)) { case3ZEU = 5; }\nlet case4ZEU = flow.get('case4ZEU');\nif (case4ZEU === undefined || isNaN(case4ZEU)) { case4ZEU = 5; }\nlet case5ZEU = flow.get('case5ZEU');\nif (case5ZEU === undefined || isNaN(case5ZEU)) { case5ZEU = 5; }\nlet case6ZEU = flow.get('case6ZEU');\nif (case6ZEU === undefined || isNaN(case6ZEU)) { case6ZEU = 5; }\n\n// PPC QU Control Casereset\nlet case1ZEQU = flow.get('case1ZEQU');\nif (case1ZEQU === undefined || isNaN(case1ZEQU)) { case1ZEQU = 5; }\nlet case2ZEQU = flow.get('case2ZEQU');\nif (case2ZEQU === undefined || isNaN(case2ZEQU)) { case2ZEQU = 5; }\nlet case3ZEQU = flow.get('case3ZEQU');\nif (case3ZEQU === undefined || isNaN(case3ZEQU)) { case3ZEQU = 5; }\nlet case4ZEQU = flow.get('case4ZEQU');\nif (case4ZEQU === undefined || isNaN(case4ZEQU)) { case4ZEQU = 5; }\nlet case5ZEQU = flow.get('case5ZEQU');\nif (case5ZEQU === undefined || isNaN(case5ZEQU)) { case5ZEQU = 5; }\nlet case6ZEQU = flow.get('case6ZEQU');\nif (case6ZEQU === undefined || isNaN(case6ZEQU)) { case6ZEQU = 5; }\n\n// PPC F Control Casereset\nlet case1ZEF = flow.get('case1ZEF');\nif (case1ZEF === undefined || isNaN(case1ZEF)) { case1ZEF = 5; }\nlet case2ZEF = flow.get('case2ZEF');\nif (case2ZEF === undefined || isNaN(case2ZEF)) { case2ZEF = 5; }\nlet case3ZEF = flow.get('case3ZEF');\nif (case3ZEF === undefined || isNaN(case3ZEF)) { case3ZEF = 5; }\nlet case4ZEF = flow.get('case4ZEF');\nif (case4ZEF === undefined || isNaN(case4ZEF)) { case4ZEF = 5; }\nlet case5ZEF = flow.get('case5ZEF');\nif (case5ZEF === undefined || isNaN(case5ZEF)) { case5ZEF = 5; }\nlet case6ZEF = flow.get('case6ZEF');\nif (case6ZEF === undefined || isNaN(case6ZEF)) { case6ZEF = 5; }\nlet case7ZEF = flow.get('case7ZEF');\nif (case7ZEF === undefined || isNaN(case7ZEF)) { case7ZEF = 5; }\n\n// PPC R Control Casereset\nlet case1ZER = flow.get('case1ZER');\nif (case1ZER === undefined || isNaN(case1ZER)) { case1ZER = 5; }\nlet case2ZER = flow.get('case2ZER');\nif (case2ZER === undefined || isNaN(case2ZER)) { case2ZER = 5; }\nlet case3ZER = flow.get('case3ZER');\nif (case3ZER === undefined || isNaN(case3ZER)) { case3ZER = 5; }\nlet case4ZER = flow.get('case4ZER');\nif (case4ZER === undefined || isNaN(case4ZER)) { case4ZER = 5; }\nlet case5ZER = flow.get('case5ZER');\nif (case5ZER === undefined || isNaN(case5ZER)) { case5ZER = 5; }\n\n// ------------------------------- Open Loop Logic Start ---------------------------------------------\nlet OLpacLimit = msg.openplimit\nlet OLqacLimit = (msg.openqlimit / blkQacMaxCmd) * 100\nif (powselcmd == 0) { \n   if ((OLpacLimit != undefined || !isNaN(OLpacLimit))) {\n    msg.pacLimitMWrite = OLpacLimit * 100;\n    msg.case = \"Case 0: PACLIMIT has given from User\";}\n\t\n   if ((qacRefSel != undefined || !isNaN(qacRefSel))){\n   msg.qacRefSelMWrite = global.get (\"QAC_REF_SEL_RX\")}\n   if ((OLqacLimit != undefined || !isNaN(OLqacLimit))) {\n    msg.qacLimitMWrite = OLqacLimit;\n    msg.caseq = \"Case 0: QACLIMIT has given from User\";}}\n\n// ---------------------------------- Open Loop Logic Stop ----------------------------------------------------\n\n// ---------------------------------- QAC Sel Mode Start----------------------------------------------------\nif (powselcmd ==1){\nif ((qacRefSel != undefined || !isNaN(qacRefSel || qacRefSel != 2))) {\n    msg.qacRefSelMWrite = 2\n } \n}  \n// ---------------------------------- QAC Sel Mode End --------------------------------------------------------\n\n// ---------------------------------------- Active Power Control Logic Start -------------------------------------------------------\nif (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && pacOnOffCmd == 1) {\n    if (zePac >= (zePMinLoad + zePThreshold) && maxPacLimit > 0 && zeIac < zeIacSetCmd) {\n\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n         if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n      \n\n    \n        Inv_Setpoint = zePMinLoad;\n\n        P_error = pvPac - Inv_Setpoint;\n        P_integral = P_integral + (P_error * 0.1);\n        P_derivative = (P_error - P_previous_error) / 0.1\n        P_previous_error = P_error\n\n        P_error = parseFloat(P_error.toFixed(1));\n        P_integral = parseFloat(P_integral.toFixed(1));\n        P_derivative = parseFloat(P_derivative.toFixed(1));\n        P_previous_error = parseFloat(P_previous_error.toFixed(1));\n       \n        if (case1ZEP >= caseReset) {\n\n        // Recalculate pacLimit with the control logic\n            pacLimit = (((pvPac) - (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)))) / inverterOnline)\n\n        // Round pacLimit to one decimal place\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n\n        // Ensure pacLimit doesn't exceed pacMaxSetCmd\n        if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n              \n            // Update 'oldPacLimit1' with the new 'pacLimit'\n            oldPacLimit1 = pacLimit;\n\n            // Round pacLimit to one decimal place\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n\n            // Reset case1ZEP and set flow context\n            case1ZEP = 0;\n            flow.set('case1ZEP', case1ZEP);\n\n            if (pacLimit <= 30) pacLimit = 40;\n\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.1.0 force down\";\n            const logMessage = `1.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n        } else {\n            // Increment case1ZEP and set flow context\n            case1ZEP++;\n            flow.set('case1ZEP', case1ZEP);\n\n            if (pacLimit <= 30) pacLimit = 40;\n\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.1.1 force down\";\n            const logMessage = `1.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldPacLimit1', oldPacLimit1);\n        flow.set('P_integral',P_integral);\n        flow.set('P_previous_error',P_previous_error);\n    }\n\n    // Case 2: < critical load\n    else if ((zePac <= zePMinLoad - zePThreshold)  && zeIac < zeIacSetCmd) {\n\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n         if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;      \n\n            Inv_Setpoint = zePMinLoad ;\n            P_error = Inv_Setpoint - (pvPac);\n            P_integral = P_integral + (P_error * 0.1);\n            P_derivative = (P_error - P_previous_error) / 0.1\n            P_previous_error = P_error\n\n            P_error = parseFloat(P_error.toFixed(1));\n            P_integral = parseFloat(P_integral.toFixed(1));\n            P_derivative = parseFloat(P_derivative.toFixed(1));\n            P_previous_error = parseFloat(P_previous_error.toFixed(1));\n\n        if (case2ZEP >= caseReset) {\n            // Calculate new pacLimit based on control logic\n            pacLimit = (((pvPac) + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)))) / inverterOnline)\n\n            // Update 'oldPacLimit1' with the new 'pacLimit'\n            oldPacLimit1 = pacLimit;\n\n            // Round pacLimit to one decimal place\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n\n           // node.warn(`invpac1: ${oldPacLimit1}`);\n            // Ensure pacLimit doesn't exceed pacMaxSetCmd\n            if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            if (pacLimit < 30) pacLimit = 40;\n\n            // Reset case2ZEP if necessary\n            case2ZEP = 0;\n            flow.set('case2ZEP', case2ZEP);\n\n            if (pacLimit <= 30) pacLimit = 40;\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.2.0 force UP\";\n            const logMessage = `1.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n\n        } else {\n            // Increment case2ZEP if caseReset is not reached\n            case2ZEP++;\n            flow.set('case2ZEP', case2ZEP);\n\n            if (pacLimit <= 30) pacLimit = 40;\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.2.1 force UP\";\n            const logMessage = `1.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${P_error},${P_integral},${P_derivative},${P_previous_error},${pacLimit},`;\n            logCsv(logMessage);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldPacLimit1', oldPacLimit1);\n        flow.set('P_integral',P_integral);\n        flow.set('P_previous_error',P_previous_error);\n    }\n\n    // Case 3:  > Critical  & < lower ---tune up\n    \n    // Case 4: ZEP meter > 0 & ZEP meter < minload no change\n    else if (zeIac >= zeIacSetCmd && maxPacLimit < pacMaxSetCmd) {\n        if (zeIac > zeIacMaxCmd) {\n            let pacLimit = maxPacLimit - (pacTuneStCmd * pacMaxSetCmd / 1000);\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n         \n            if (case4ZEP >= caseReset) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 30) pacLimit = 40;\n                msg.pacLimitMWrite = pacLimit*10;\n                msg.case = \"1.4.0 current\"\n                const logMessage = `1.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit*10;\n                msg.case = \"1.4.1 current\"\n                const logMessage = `1.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            }\n        }\n        else {\n            pacLimit = pacLimit\n            if (case4ZEP >= caseReset) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 30) pacLimit = 40;\n                msg.pacLimitMWrite = pacLimit*10;\n                msg.case = \"1.4.2 current\"\n                const logMessage = `1.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit*10;\n                msg.case = \"1.4.3 current\"\n                const logMessage = `1.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            }\n        }\n          \n    }\n    // Case 5: Stable\n    else if ((zePac <= zePMinLoad + zePThreshold && zePac >= zePMinLoad - zePThreshold || maxPacLimit <= pacMaxSetCmd )&& zeIac < zeIacSetCmd) {\n        pacLimit = oldPacLimit1;\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        oldPacLimit1 = parseFloat(oldPacLimit1.toFixed(1));\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('P_integral', 0);\n        flow.set('P_previous_error', 0);\n        if (case5ZEP >= caseReset) {\n            case5ZEP = 0;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 30) pacLimit = 40;\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.5.0 stable\"\n            const logMessage = `1.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        } else {\n            case5ZEP++;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 30) pacLimit = 40;\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.5.1 stable\"\n            const logMessage = `1.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        }\n    }\n}\n// ------------------------------------------ Active Power Control Logic End -------------------------------------------------------------------------------\n\n\n// ------------------------------------------ Reactive Power Control Logic Start ----------------------------------------------------------------------------\nif (!isNaN(zeQac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && (qaconoffcmd == 1 || svgonoffcmd ==1)) {\n    const now = new Date();\n    const min = now.getMinutes();\n    const hour = now.getHours();\n\n    //node.warn(`1:${zeQac}, 2:${powselcmd}, 3: ${inverterOnline}, , 4: ${fonoffcmd},5: ${qaconoffcmd}, 6: ${inverterOnline }`)\n\n    // Select the setpoint based on Slots\n    if (qaconoffcmd == 1 && svgonoffcmd == 1) {\n    if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n        zeCriticalLoad = zeSvgSlot1CriticalLoad;\n        zeMinLoad = zeSvgSlot1MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n        zeCriticalLoad = zeSvgSlot2CriticalLoad;\n        zeMinLoad = zeSvgSlot2MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n        zeCriticalLoad = zeSvgSlot3CriticalLoad;\n        zeMinLoad = zeSvgSlot3MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n        zeCriticalLoad = zeCriticalLoad;\n        zeMinLoad = zeMinLoad;\n        qModeEnable = 1;\n    }\n}\n\nif (qaconoffcmd == 0 && svgonoffcmd == 1) {\n    if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n        zeCriticalLoad = zeSvgSlot1CriticalLoad;\n        zeMinLoad = zeSvgSlot1MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n        zeCriticalLoad = zeSvgSlot2CriticalLoad;\n        zeMinLoad = zeSvgSlot2MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n        zeCriticalLoad = zeSvgSlot3CriticalLoad;\n        zeMinLoad = zeSvgSlot3MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n        qModeEnable = 0;\n    }\n}\n\nif (qaconoffcmd == 1 && svgonoffcmd == 0) {\n    if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n        qModeEnable = 0;\n    }\n    if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n        qModeEnable = 0;\n    }\n    if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n        qModeEnable = 0;\n    }\n    if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n        zeCriticalLoad = zeCriticalLoad;\n        zeMinLoad = zeMinLoad;\n        qModeEnable = 1;\n    }\n}\n    //node.warn(`svg_status,${hour}`)\n    //node.warn(`setpoint,${svgSlot4StartHour}`)\n\n    // Case 1: ZE meter < critical load (100VAR); Reactive Power supply to grid  && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    if (zeQac <= (zeMinLoad - zeThreshold) && (maxQacLimit > -100)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zeMinLoad \n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case1ZEQ >= caseReset) { \n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline ) \n\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n\n            oldQacLimit1 = qacLimit\n            case1ZEQ = 0;\n            flow.set('case1ZEQ', case1ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.1.0\";\n            const logMessageQ = `2.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvQ(logMessageQ);\n            } \n            else {\n                case1ZEQ++;\n                flow.set('case1ZEQ', case1ZEQ);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"2.1.1\";\n                const logMessageQ = `2.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n                logCsvQ(logMessageQ);\n            }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if ((zeQac >= (zeMinLoad + zeThreshold)) && (minQacLimit < 100) ) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zeMinLoad \n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case2ZEQ >= caseReset) {\n        \n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n        \n        if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n        if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        oldQacLimit1 = qacLimit           \n        case2ZEQ = 0;\n        flow.set('case2ZEQ', case2ZEQ);\n        msg.qacLimitMWrite = qacLimit;\n        msg.caseq = \"2.2.0\";\n        const logMessageQ = `2.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n        logCsvQ(logMessageQ);\n        }\n        else {\n            case2ZEQ++;\n            flow.set('case2ZEQ', case2ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.2.1\";\n            const logMessageQ = `2.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvQ(logMessageQ);\n            }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n    }\n    // Case 3: ZE meter > minload & ZE meter < 10  tune up && qModeEnable === 1\n\n    /*/case 4 : ZE meter > 0 & ZE meter < minload  no change && qModeEnable === 1\n    else if (((zePf < 0 && zePf >= -zePfSetCmd) || (zePf > 0 && zePf <= zePfSetCmd)) ) {\n        oldQacLimit = parseFloat((oldQacLimit * qacMaxSetCmd / 100).toFixed(1));\n        qacLimit = parseFloat((qacLimit * qacMaxSetCmd / 100).toFixed(1));\n        oldQacLimit1 = qacLimit\n\n        if ((zePf <= zepfMaxLoad && zePf >= -zepfMaxLoad) && maxQacLimit >= 0) {\n            qacLimit = parseFloat(((maxQacLimit * qacMaxSetCmd / 100) + (tuneStep * qacMaxSetCmd / 1000)).toFixed(1));\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            qacLimitW = parseFloat(((1 * (qacLimit / qacMaxSetCmd) * 100)).toFixed(1));\n            pvQacW = 1 * pvQac;\n            oldQacLimit1 = qacLimit\n\n            if (case4ZEQ >= caseReset) {\n                case4ZEQ = 0;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"2.4.0\";\n                const logMessageQ = `2.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            } else {\n                case4ZEQ++;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"2.4.1\";\n                const logMessageQ = `2.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            }\n        } else if ((zePf <= zepfMaxLoad && zePf >= -zepfMaxLoad) && maxQacLimit < 0) {\n            qacLimit = parseFloat(((maxQacLimit * qacMaxSetCmd / 100) - (tuneStep * qacMaxSetCmd / 1000)).toFixed(1));\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            qacLimitW = parseFloat(((1 * (qacLimit / qacMaxSetCmd) * 100)).toFixed(1));\n            pvQacW = 1 * pvQac;\n            oldQacLimit1 = qacLimit\n\n            if (case4ZEQ >= caseReset) {\n                case4ZEQ = 0;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"2.4.2\";\n                const logMessageQ = `2.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            } else {\n                case4ZEQ++;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"2.4.3\";\n                const logMessageQ = `2.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            }\n        }\n\n        flow.set('oldQacLimit1', oldQacLimit1);\n    }*/\n\n    //case 5   && qModeEnable === 1\n    else if ((zeQac <= (zeMinLoad + zeThreshold)) && (zeQac >= (zeMinLoad - zeThreshold))  ) {\n        \n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        if (case5ZEQ >= caseReset) {\n            case5ZEQ = 0;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.0 stable\"\n            const logMessageQ = `2.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case5ZEQ++;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.1 stable\"\n            const logMessageQ = `2.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n\n        }\n\n    }\n}\n// --------------------------------------------------------- Reactive Power Control Logic End ----------------------------------------------------------------------\n\n/* -------------------------------------------------------Power Factor Day Logic Start ------------------------------------------\n\nif (!isNaN(zePf) && powselcmd === 1 && inverterOnlineQ > 0 && fonoffcmd === 1 && pfonoffcmd === 1 && (zePac == 0)) {\n  \n    let oldQacLimit1 = flow.get(\"oldQacLimit1\")\n    let zePFMinLoadnew\n\n\n    if (zePac > 0 && zePFMinLoad != zePf) {\n\n        if (case4ZEPF >= caseReset) {\n            zePFMinLoadnew = ((((zePac / 1000) / (zePFMinLoad)) * Math.sqrt(1 - ((zePFMinLoad) * (zePFMinLoad))) - (zeQac/1000)) / inverterOnlineQ);\n            qacLimit = (zePFMinLoadnew * 1000)\n\n            qacLimit = parseFloat(qacLimit.toFixed(3));\n\n            //node.warn(`qacLimit:${qacLimit}, zePac:${zePac}`)\n\n            if (((-1) * qacLimit) > qacMaxSetCmd) { qacLimit = (-1 * qacMaxSetCmd) }\n            if (qacLimit > qacMaxSetCmd) { qacLimit = (-1 * qacMaxSetCmd) }\n            oldQacLimit1 = qacLimit\n\n            case4ZEPF = 0;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.1.0\";\n            const logMessagePF = `5.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n\n        }\n        else {\n            qacLimit = oldQacLimit1\n            case4ZEPF++;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.1.1\";\n            const logMessagePF = `5.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n\n        }\n        flow.set(\"oldQacLimit1\", oldQacLimit1)\n    } else if (zePFMinLoad == zePf) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(3));\n        if (case5ZEPF >= caseReset) {\n            case5ZEPF = 0;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.5.0\"\n            const logMessagePF = `5.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n\n        } else {\n            case5ZEPF++;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.5.1\"\n            const logMessagePF = `5.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n\n        }\n    }\n}\n\n// --------------------------------------------------------- Power Factor Control Logic Start ---------------------------------------------------------------------- */\n\nif (!isNaN(zePf) && powselcmd === 1 && inverterOnlineQ > 0 && fonoffcmd === 1 && pfonoffcmd === 1 ) {\n    //node.warn(`Final qacLimitMWrite: ${(QAC_LIMIT)}, Case: ${maxQacLimit}`)\n    if (zePf < (zePFMinLoad - zePFThreshold) && (zePac > 180) && zePFMinLoad > 0 && maxQacLimit > -103 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zePFMinLoadnew\n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case1ZEPF >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.1.0\";\n            const logMessagePF = `5.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.1.1\";\n            const logMessagePF = `5.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n\n    } else if (zePf < (zePFMinLoad - zePFThreshold) && (zePac < 0) && zePf < 0 && zePFMinLoad > 0 && maxQacLimit > -103 && maxQacLimit < 100 && zeSac < 1400) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zePFMinLoadnew\n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case1ZEPF >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -250;\n            //if (qacLimit > -200) qacLimit = -230;\n            if (qacLimit > qacMaxSetCmd) qacLimit = 250;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.7.0\";\n            const logMessagePF = `5.7.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.7.1\";\n            const logMessagePF = `5.7.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n\n    } else if (zePf < (zePFMinLoad - zePFThreshold) && (zePac < 0) && zePf > 0 && zePFMinLoad > 0 && maxQacLimit > -103 && maxQacLimit < 100 && zeSac < 1400) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zePFMinLoadnew\n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case2ZEPF >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit > qacMaxSetCmd) qacLimit = 250;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -250;\n            if ((qacLimit < 0) && (qacLimit > -10)) qacLimit = -10;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.6.0\";\n            const logMessagePF = `5.6.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.6.1\";\n            const logMessagePF = `5.6.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n    } \n    else if (zeSac >= 1400 && zePac < 0 ){\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit;\n        msg.caseq = \"5.9.0\";\n        const logMessagePF = `5.9.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }\n    else if (zePac <= 180 && zePac >=0) {\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit;\n        msg.caseq = \"5.9.1\";\n        const logMessagePF = `5.9.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }\n    \n    else if (((zePf > (zePFThreshold + zePFMinLoad))) && zePf >= -1 && zePFMinLoad > 0 && maxQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zePFMinLoadnew\n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case2ZEPF >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if ((qacLimit < 0) && (qacLimit > -10)) qacLimit = -10;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.2.0\";\n            const logMessagePF = `5.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.2.1\";\n            const logMessagePF = `5.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n    } else if (zePf > (zePFThreshold + zePFMinLoad) && zePFMinLoad < 0 && zePf < 0 && maxQacLimit < 101 && maxQacLimit > -103) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad + zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad + zePFThreshold) * (zePFMinLoad + zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zePFMinLoadnew\n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case3ZEPF >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n\n            oldQacLimit1 = qacLimit\n            case3ZEPF = 0;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.3.0\";\n            const logMessagePF = `5.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        else {\n            case3ZEPF++;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.3.1\";\n            const logMessagePF = `5.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n\n    }\n\n    else if ((zePf < zePFMinLoad || zePf >= ((-zePFThreshold) - (zePFMinLoad))) && (zePFMinLoad < 0) && (zePf >= -1) && (maxQacLimit < 100) && (maxQacLimit > -101)) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = zePFMinLoadnew\n\n        //node.warn(`(1:${((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)) })`)\n\n        Q_error = Inv_Qsetpoint - zeQac\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if (case4ZEPF >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case4ZEPF = 0;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.4.0\";\n            const logMessagePF = `5.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        else {\n            case4ZEPF++;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.4.1\";\n            const logMessagePF = `5.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${Q_previous_error},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n    }\n    else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        if (case5ZEPF >= caseReset) {\n            case5ZEPF = 0;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.5.0\"\n            const logMessagePF = `5.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case5ZEPF++;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.5.1\"\n            const logMessagePF = `5.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n\n        }\n    }\n}\n\n// ------------------------------------------------------ Power Factor Logic End -----------------------------------------------------------------------------\n\n\n// ------------------------------------------------------ Voltage Control Logic Start -------------------------------------------------------------------------\nif (!isNaN(zeUac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && (uaconoffcmd === 1 || lvrtHvrtOnOffCmd === 1 )) {\n    \n    ratedQCapacity = msg.ratedPcapacity * 0.33\n    //oldQacLimit = parseFloat(oldQacLimit.toFixed(0));\n    qacLimit = oldQacLimit1\n    \n    //node.warn(`deadBandMax: ${deadBandMax}, droopMax: ${droopMax}`);\n    //node.warn(`deadBandMin: ${deadBandMin}, droopMin: ${droopMin}`);\n\n    //let zeUacold = flow.get(\"zeUacold\")\n\n    //if (zeUacold === undefined || isNaN(zeUacold)) { zeUacold = 132; }\n\n  \n    if (zeUac > (deadBandMax) && zeUac <= droopMax) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = ((zeUac - deadBandMax) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n\n        Q_error = (Inv_Qsetpoint*1000) - zeQac \n\n        //node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error}`)\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if ((zeQac >= ((Inv_Qsetpoint*1000) + zeThreshold) || ((zeQac <= ((Inv_Qsetpoint*1000) - zeThreshold) ) ))) {\n\n        if (case1ZEU >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n\n            oldQacLimit1 = qacLimit\n            case1ZEU = 0;\n            flow.set('case1ZEU', case1ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.1.0\"\n            const logMessageU = `3.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        } else {\n            case1ZEU++;\n            flow.set('case1ZEU', case1ZEU);\n            msg.qacLimitMWrite = oldQacLimit1;\n            msg.caseq = \"3.1.1 \"\n            const logMessageU = `3.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        }\n        else {\n             qacLimit = oldQacLimit1\n             qacLimit = parseFloat(qacLimit.toFixed(1));\n              flow.set('Q_integral', 0);\n              flow.set('Q_previous_error', 0);\n            case5ZEU++;\n            flow.set('case5ZEU', case5ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.1.5 \"\n            const logMessageU = `3.1.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n\n        }\n\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if (zeUac < (deadBandMin) && zeUac >= droopMin) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n\n        Inv_Qsetpoint = ((zeUac - deadBandMin) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n\n        Q_error = (Inv_Qsetpoint * 1000) - zeQac\n\n        //node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error}`)\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        if ((zeQac <= ((Inv_Qsetpoint*1000) - zeThreshold) || ((zeQac >= ((Inv_Qsetpoint*1000) + zeThreshold) ) ))) {\n\n         node.warn(`zeThreshold:${((Inv_Qsetpoint*1000) - zeThreshold)},Q_error:${((Inv_Qsetpoint*1000) + zeThreshold)}`)\n        \n        if (case2ZEU >= caseReset) {\n\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEU = 0;\n            flow.set('case2ZEU', case2ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.2.0\"\n            const logMessageU = `3.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        } else {\n            case2ZEU++;\n            flow.set('case2ZEU', case2ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.2.1 \"\n            const logMessageU = `3.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n    }\n\n    else {\n             qacLimit = oldQacLimit1\n             qacLimit = parseFloat(qacLimit.toFixed(1));\n              flow.set('Q_integral', 0);\n              flow.set('Q_previous_error', 0);\n            case5ZEU++;\n            flow.set('case5ZEU', case5ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.1.5 \"\n            const logMessageU = `3.2.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n\n        }\n\n    }\n   // case 3 \n    else if ((zePac > 0) && (zeUac >= deadBandMin) && (zeUac <= deadBandMax)) {\n        if (zePac > 0 && uaconoffcmd === 1) {\n            qacMaxSet = 0\n            qacLimit = qacMaxSet * 1000\n\t\t\n            if (case3ZEU >= caseReset) {\n            case3ZEU = 0;\n            flow.set('case3ZEU', case3ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.3.0\"\n            const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        } else {\n            case3ZEU++;\n            flow.set('case3ZEU', case3ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.3.1 \"\n            const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU); }\n        }\n    } \n\n // case 4\n    \n// case 5 \n     else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n            case5ZEU++;\n            flow.set('case5ZEU', case5ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.5.0 \"\n            const logMessageU = `3.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit},${oldQacLimit},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n// ------------------------------------------------------- Voltage Control Logic End -----------------------------------------------------------------------------------\n// ------------------------------- Frequency COntrol Start --------------------------------------------------\n\nif (!isNaN(zeFac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && faconoffcmd === 1 ) {\n\t\n\t if ((zePac > 0) && (((zeFMinLoad - zeFThreshold)  > zeFac) || ((zeFMinLoad + zeFThreshold)  < zeFac))&& (zeIac < zeIacSetCmd)) {\n\t\t \n\t\t //let delF = zeFMinLoad - zeFac ;\n\t\t \n\t\t const ratedPcapacity = msg.ratedPcapacity\n \n\t\t const ratedFrequency = msg.ratedFrequency\n\n         let delF = ratedFrequency - zeFac ;\n\n         let zeFacOld = flow.get(\"zeFacOld\")\n         if (zeFacOld === undefined || isNaN(zeFacOld)) { zeFacOld = 50; }\n\t\t \n         if ((case1ZEF >= caseReset) && (zeFac != zeFacOld)) {\n\t\t\t \n\t\t\tconst pacLimitnew = (((zePac/1000) + (((delF * ratedPcapacity)/(fDroopCmd * ratedFrequency)) * 100))/ inverterOnline)\n\t\t\t \n            //node.warn(`paclimit:${pacLimitnew}, zePac:${zePac} `) \n\t\t\tpacLimit = (pacLimitnew * 1000) \t\n\t\t\toldPacLimit1 = pacLimit\n            zeFacOld = zeFac\n             flow.set(\"zeFacOld\", zeFacOld)\n\t\t\tcase1ZEF = 0;\n            flow.set('case1ZEF', case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;  \n            msg.case = \"4.1.0\"\n            const logMessageF = `4.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } \n\t\t\n\t\telse {\n\t\t\tpacLimit = oldPacLimit1\n            case1ZEF++;\n            flow.set('case1ZEF', case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.1.1 \"\n            const logMessageF = `4.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n\t\t\t\n\t\t\tflow.set('oldPacLimit1', oldPacLimit1);\n     } \n\t\n\t else if ((zeFMinLoad + zeFThreshold)  == zeFac){\n            flow.set(\"zeFacOld\", 50)\n            pacLimit = 0.50 * (pacMaxSetCmd/2)\n\t\t\tcase7ZEF++;\n            flow.set('case7ZEF', case7ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.5.0 \"\n            const logMessageF = `4.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n}\n}\n\n// -------------------------------------------------------Voltage Droop Control Start ----------------------------------------------------------------------------------\n\n\n\n// ---------------------------------------- Ramp Control Logic Start -------------------------------------------------------\nif (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && rampOnOffCmd == 1) {\n    if (zePac >= (zePMinLoad + zePThreshold) && maxPacLimit > 0 && zeIac < zeIacSetCmd) {\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        let oldPacLimit = parseFloat(maxPacLimit.toFixed(1));\n        if (oldPacLimit <= pacLimit) {\n            pacLimit = oldPacLimit - parseFloat((rampDecconstCmd * pacMaxSetCmd / 1000).toFixed(1));\n            if (case1ZER >= caseReset) {\n                case1ZER = 0;\n                flow.set('case1ZER', case1ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.1.0 force down\"\n                const logMessageR = `6.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                msg.pacLimitMWrite = pacLimit;\n                case1ZER++;\n                flow.set('case1ZER', case1ZER);\n                msg.case = \"6.1.1 force down\"\n                const logMessageR = `6.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        } else {\n            if (case1ZER >= caseReset) {\n                case1ZER = 0;\n                flow.set('case1ZER', case1ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.1.2 force down\"\n                const logMessageR = `6.1.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                msg.pacLimitMWrite = pacLimit;\n                case1ZER++;\n                flow.set('case1ZER', case1ZER);\n                msg.case = \"6.1.3 force down\"\n                const logMessageR = `6.1.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n    }\n    // Case 2: < critical load\n    else if (zePac <= zePMinLoad - zePThreshold && minPacLimit < pacMaxSetCmd && zeIac < zeIacSetCmd) {\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        oldPacLimit = parseFloat(minPacLimit.toFixed(1));\n\n        if (oldPacLimit >= pacLimit) {\n            pacLimit = oldPacLimit + parseFloat((rampIncconstCmd * pacMaxSetCmd / 1000).toFixed(1));\n            if (pacLimit > pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            if (case2ZER >= caseReset) {\n                case2ZER = 0;\n                flow.set('case2ZER', case2ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.0 force UP\"\n                const logMessageR = `6.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case2ZER++;\n                flow.set('case2ZER', case2ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.1 force UP\"\n                const logMessageR = `6.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        } else {\n            if (case2ZER >= caseReset) {\n                case2ZER = 0;\n                flow.set('case2ZER', case2ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.2 force UP\"\n                const logMessageR = `6.2.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case2ZER++;\n                flow.set('case2ZER', case2ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.3 force UP\"\n                const logMessageR = `6.2.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n    }\n\n    // Case 4: ZEP meter > 0 & ZEP meter < minload no change\n    else if (zeIac >= zeIacSetCmd && maxPacLimit < pacMaxSetCmd) {\n        if (zeIac > zeIacMaxCmd) {\n            let pacLimit = maxPacLimit - (rampTuneStCmd * pacMaxSetCmd / 1000);\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            if (case4ZER >= caseReset) {\n                case4ZER = 0;\n                flow.set('case4ZER', case4ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.0 current\"\n                const logMessageR = `6.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case4ZER++;\n                flow.set('case4ZER', case4ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.1 current\"\n                const logMessageR = `6.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n        else {\n            pacLimit = pacLimit\n            if (case4ZER >= caseReset) {\n                case4ZER = 0;\n                flow.set('case4ZER', case4ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.2 current\"\n                const logMessageR = `6.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case4ZER++;\n                flow.set('case4ZER', case4ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.3 current\"\n                const logMessageR = `6.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n    }\n    // Case 5: Stable\n    else if ((zePac <= zePMinLoad + zePThreshold && zePac >= zePMinLoad - zePThreshold || maxPacLimit <= pacMaxSetCmd) && zeIac < zeIacSetCmd) {\n        pacLimit = pacLimit\n        if (case5ZER >= caseReset) {\n            case5ZER = 0;\n            flow.set('case5ZER', case5ZER);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"6.5.0 stable\"\n            const logMessageR = `6.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvR(logMessageR);\n        } else {\n            case5ZER++;\n            flow.set('case5ZER', case5ZER);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"6.5.1 stable\"\n            const logMessageR = `6.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvR(logMessageR);\n        }\n    }\n}\n// ------------------------------------------ Ramp Control Logic End -------------------------------------------------------------------------------\n\n// ------------------------------------------------------ Voltage Control Logic Start -------------------------------------------------------------------------\nif (!isNaN(zeUac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && (quonoffcmd === 1 || lvrtHvrtOnOffCmd === 1)) {\n\n    if (quonoffcmd == 1 && lvrtHvrtOnOffCmd == 1) {\n        zeUThreshold = zeUThreshold;\n        zeUCriticalLoad = zeUCriticalLoad;\n    }\n\n    if (quonoffcmd == 0 && lvrtHvrtOnOffCmd == 1) {\n        zeUThreshold = zelvrthvrtThreshold;\n        zeUCriticalLoad = zelvrthvrtCriticalLoad;\n    }\n\n    if (quonoffcmd == 1 && lvrtHvrtOnOffCmd == 0) {\n        zeUThreshold = zeUThreshold;\n        zeUCriticalLoad = zeUCriticalLoad;\n    }\n    //node.warn(`zeUThreshold: ${zeUThreshold}, zeUMinLoad: ${zeUMinLoad}`);\n    if (zeUac > (zeUMinLoad + zeUThreshold) && (zePf > zePfSetCmd || zePf < -zePfSetCmd)) {\n        if (zePac > 0 && (quonoffcmd === 1)) {\n            if (zeUac > (1.01 * zeUMinLoad) && zeUac <= (1.02 * zeUMinLoad)) { qacMaxSet = ((pvQac - (0.2030 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac > (1.02 * zeUMinLoad) && zeUac <= (1.03 * zeUMinLoad)) { qacMaxSet = ((pvQac - (0.2506 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac > (1.03 * zeUMinLoad) && zeUac <= (1.04 * zeUMinLoad)) { qacMaxSet = ((pvQac - (0.2917 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac > (1.04 * zeUMinLoad) && zeUac <= (1.05 * zeUMinLoad)) { qacMaxSet = ((pvQac - (0.3287 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac > (1.05 * zeUMinLoad)) { qacMaxSet = ((pvQac - (0.3287 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n        }\n        else if (zePac <= 0 && quonoffcmd === 1) {\n            if (zeUac > (1.05 * zeUMinLoad)) { qacMaxSet = -100; }\n            else if (zeUac >= (1.01 * zeUMinLoad) && zeUac <= (1.05 * zeUMinLoad)) { qacMaxSet = -100; }\n        }\n\n        qacMaxSet = parseFloat(qacMaxSet.toFixed(2));\n        qacLimit = qacMaxSet;\n        //node.warn(`chck,${qacMaxSet}, chck2,${oldQacLimit}`)\n        qacLimit = parseFloat(qacLimit.toFixed(2));\n        qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n        oldQacLimitW = (oldQacLimit /blkQacMaxCmd) * 100\n        if (qacLimit < -100) qacLimit = -100;\n        if (oldQacLimitW < qacLimit) {\n            qacLimit = oldQacLimitW + quIncConstCmd;\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case1ZEQU >= caseReset) {\n                case1ZEQU = 0;\n                flow.set('case1ZEQU', case1ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.1.0\"\n                const logMessageQU = `7.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case1ZEQU++;\n                flow.set('case1ZEQU', case1ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.1.1 \"\n                const logMessageQU = `7.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else if (oldQacLimit > qacMaxSet) {\n            qacLimitW =parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case1ZEQU >= caseReset) {\n                case1ZEQU = 0;\n                flow.set('case1ZEQU', case1ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.1.2\"\n                const logMessageQU = `7.1.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case1ZEQU++;\n                flow.set('case1ZEQU', case1ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.1.3 \"\n                const logMessageQU = `7.1.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else {\n            case1ZEQU++;\n            flow.set('case1ZEQU', case1ZEQU);\n            msg.qacLimitMWrite = qacLimitW;\n            msg.caseq = \"7.1.4\"\n            const logMessageQU = `7.1.4,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQU(logMessageQU);\n        }\n    }\n\n    // case 2\n    else if (zeUac < zeUCriticalLoad && (zePf > zePfSetCmd || zePf < -zePfSetCmd)) {\n        if (zePac > 0 && (quonoffcmd === 1)) {\n            if (zeUac < (0.95 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.3287 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.95 * zeUMinLoad) && zeUac < (0.96 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.3287 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.96 * zeUMinLoad) && zeUac < (0.97 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.2917 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.97 * zeUMinLoad) && zeUac < (0.98 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.2506 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.98 * zeUMinLoad) && zeUac < (0.99 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.2030 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n        }\n        else if (zePac <= 0 && quonoffcmd === 1) {\n            if (zeUac < (0.95 * zeUMinLoad)) {\n                qacMaxSet = 100;\n            } else if (zeUac >= (0.95 * zeUMinLoad) && zeUac <= (0.99 * zeUMinLoad)) {\n                qacMaxSet = 100;\n            }\n        }\n        //node.warn(`zeUac: ${((pvQac + (0.2030 * zePac) + zeQac) / (inverterOnline * qacMaxSetCmd)) * 100}, qacMaxSet: ${qacMaxSet}`);\n        qacMaxSet = parseFloat(qacMaxSet.toFixed(2));\n        qacLimit = qacMaxSet;\n        if (qacLimit > 100) qacLimit = 100;\n\n        qacLimit = parseFloat(qacLimit.toFixed(2));\n        qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n        oldQacLimitW = (oldQacLimit /blkQacMaxCmd) * 100\n\n        if (oldQacLimitW > qacLimit) {\n            qacLimit = oldQacLimitW - quDecConstCmd;\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case2ZEQU >= caseReset) {\n                case2ZEQU = 0;\n                flow.set('case2ZEQU', case2ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.2.0\"\n                const logMessageQU = `7.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case2ZEQU++;\n                flow.set('case2ZEQU', case2ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.2.1 \"\n                const logMessageQU = `7.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else if (minQacLimit < qacMaxSet) {\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case2ZEQU >= caseReset) {\n                case2ZEQU = 0;\n                flow.set('case2ZEQU', case2ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.2.2\"\n                const logMessageQU = `7.2.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case2ZEQU++;\n                flow.set('case2ZEQU', case2ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.2.3 \"\n                const logMessageQU = `7.2.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else {\n            case2ZEQU++;\n            flow.set('case2ZEQU', case2ZEQU);\n            msg.qacLimitMWrite = qacLimitW;\n            msg.caseq = \"7.2.4 \"\n            const logMessageQU = `7.2.4,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQU(logMessageQU);\n        }\n    }\n\n    // case 3 \n    else if (zeUac < (zeUMinLoad - zeUThreshold) && (zePf > zePfSetCmd || zePf < -zePfSetCmd)) {\n        if (zePac > 0 && quonoffcmd === 1) {\n            if (zeUac < (0.95 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.3287 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.95 * zeUMinLoad) && zeUac < (0.96 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.3287 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.96 * zeUMinLoad) && zeUac < (0.97 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.2917 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.97 * zeUMinLoad) && zeUac < (0.98 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.2506 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.98 * zeUMinLoad) && zeUac < (0.99 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.2030 * zePac) - zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n        }\n        else if (zePac <= 0 && quonoffcmd === 1) {\n            if (zeUac < (0.95 * zeUMinLoad)) {\n                qacMaxSet = 100;\n            } else if (zeUac >= (0.95 * zeUMinLoad) && zeUac <= (0.99 * zeUMinLoad)) {\n                qacMaxSet = 100;\n            }\n        }\n        //node.warn(`qacMaxSet: ${qacMaxSet}, zeUMinLoad: ${zeUMinLoad}`);\n        qacMaxSet = parseFloat(qacMaxSet.toFixed(2));\n        qacLimit = qacMaxSet;\n        if (qacLimit > 100) qacLimit = 100;\n\n        qacLimit = parseFloat(qacLimit.toFixed(2));\n        qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n        oldQacLimitW = (oldQacLimit /blkQacMaxCmd) * 100\n\n        if (oldQacLimitW > qacLimit) {\n            qacLimit = oldQacLimitW - quDecConstCmd;\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case3ZEQU >= caseReset) {\n                case3ZEQU = 0;\n                flow.set('case3ZEQU', case3ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.3.0\"\n                const logMessageQU = `7.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case3ZEQU++;\n                flow.set('case3ZEQU', case3ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.3.1 \"\n                const logMessageQU = `7.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else if (minQacLimit < qacMaxSet) {\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case3ZEQU >= caseReset) {\n                case3ZEQU = 0;\n                flow.set('case3ZEQU', case3ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.3.2\"\n                const logMessageQU = `7.3.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case3ZEQU++;\n                flow.set('case3ZEQU', case3ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.3.3 \"\n                const logMessageQU = `7.3.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else {\n            case3ZEQU++;\n            flow.set('case3ZEQU', case3ZEQU);\n            msg.qacLimitMWrite = qacLimitW;\n            msg.caseq = \"7.3.4 \"\n            const logMessageQU = `7.3.4,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQU(logMessageQU);\n        }\n    }\n\n    // case 4\n    else if (zeUac >= (zeUMinLoad - zeUThreshold) && zeUac <= (zeUMinLoad + zeUThreshold) && (zePf > zePfSetCmd || zePf < -zePfSetCmd)) {\n        //node.warn(`inside,${zeUMinLoad - zeUThreshold}`)\n        if (zeUac > zeUMinLoad && maxQacLimit < 0) {\n            qacLimit = parseFloat(maxQacLimit - quTuneStCmd);\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case6ZEQU >= caseReset) {\n                case6ZEQU = 0;\n                flow.set('case6ZEQU', case6ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.6.0\"\n                const logMessageQU = `7.6.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case6ZEQU++;\n                flow.set('case6ZEQU', case6ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.6.1 \"\n                const logMessageQU = `7.6.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else if (zeUac < zeUMinLoad && maxQacLimit > 0) {\n            qacLimit = parseFloat(maxQacLimit + quTuneStCmd);\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case6ZEQU >= caseReset) {\n                case6ZEQU = 0;\n                flow.set('case6ZEQU', case6ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.6.2\"\n                const logMessageQU = `7.6.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case6ZEQU++;\n                flow.set('case6ZEQU', case6ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.6.3 \"\n                const logMessageQU = `7.6.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        } else {\n            case6ZEQU++;\n            flow.set('case6ZEQU', case6ZEQU);\n            msg.qacLimitMWrite = qacLimitW;\n            msg.caseq = \"7.6.4 \"\n            const logMessageQU = `7.6.4,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQU(logMessageQU);\n        }\n    }\n\n    // case 5 \n    else if (((zePf < 0 && zePf >= -zePfSetCmd) || (zePf > 0 && zePf <= zePfSetCmd))) {\n        if (zePac > 0 && quonoffcmd === 1) {\n            if (zeUac < (0.99 * zeUMinLoad)) { qacMaxSet = ((pvQac + (0.3287 * zePac) + zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac > (1.01 * zeUMinLoad)) { qacMaxSet = ((pvQac - (0.3287 * zePac) + zeQac) / (inverterOnline * qacMaxSetCmd)) * 100; }\n            else if (zeUac >= (0.99 * zeUMinLoad) && zeUac < (1.01 * zeUMinLoad)) { qacMaxSet = 0; }\n        }\n        else if (zePac <= 0 && quonoffcmd === 1) {\n            qacMaxSet = 0;\n        }\n        qacMaxSet = parseFloat(qacMaxSet.toFixed(2));\n\n        if (qacMaxSet > 100) qacMaxSet = 100;\n        if (qacMaxSet < -100) qacMaxSet = -100;\n        qacLimit = qacMaxSet\n        qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n\n        if (((zePf <= zepfMaxLoad) && (zePf >= -zepfMaxLoad)) && (((maxQacLimit < 0) && (zeUac > (zeUMinLoad + zeUThreshold))) || ((maxQacLimit < 0) && (zeUac < (zeUMinLoad - zeUThreshold))) || ((maxQacLimit < 0) && (zeUac > (zeUMinLoad - zeUThreshold)) && (zeUac < (zeUMinLoad + zeUThreshold))))) {\n            qacLimit = parseFloat(maxQacLimit - quTuneStCmd);\n            if (qacMaxSet > 100) qacMaxSet = 100;\n            if (qacLimit < qacMaxSet) qacLimit = qacMaxSet;\n            if ((qacLimit < 0 && qacLimit > -1) || (qacLimit < 1 && qacLimit > 0)) qacLimit = 0;\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case4ZEQU >= caseReset) {\n                case4ZEQU = 0;\n                flow.set('case4ZEQU', case4ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.4.0\"\n                const logMessageQU = `7.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case4ZEQU++;\n                flow.set('case4ZEQU', case4ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.4.1 \"\n                const logMessageQU = `7.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        }\n        else if (((zePf <= zepfMaxLoad) && (zePf >= -zepfMaxLoad)) && (((maxQacLimit > 0) && (zeUac > (zeUMinLoad + zeUThreshold))) || ((maxQacLimit > 0) && (zeUac < (zeUMinLoad - zeUThreshold))) || ((maxQacLimit > 0) && (zeUac > (zeUMinLoad - zeUThreshold)) && (zeUac < (zeUMinLoad + zeUThreshold))))) {\n            qacLimit = parseFloat(maxQacLimit + quTuneStCmd);\n            if (qacMaxSet < -100) qacMaxSet = -100;\n            if (qacLimit > qacMaxSet) qacLimit = qacMaxSet;\n            if ((qacLimit < 0 && qacLimit > -1) || (qacLimit < 1 && qacLimit > 0)) qacLimit = 0;\n            qacLimitW = parseFloat((qacLimit * (qacMaxSetCmd / 100)).toFixed(2));\n            if (case4ZEQU >= caseReset) {\n                case4ZEQU = 0;\n                flow.set('case4ZEQU', case4ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.4.2\"\n                const logMessageQU = `7.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            } else {\n                case4ZEQU++;\n                flow.set('case4ZEQU', case4ZEQU);\n                msg.qacLimitMWrite = qacLimitW;\n                msg.caseq = \"7.4.3 \"\n                const logMessageQU = `7.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQU(logMessageQU);\n            }\n        }\n    } else {\n        qacLimit = qacLimit\n        case5ZEQU++;\n        flow.set('case5ZEQU', case5ZEQU);\n        msg.qacLimitMWrite = qacLimitW;\n        msg.caseq = \"7.5.0 \"\n        const logMessageQU = `7.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n        logCsvQU(logMessageQU);\n    }\n}\n// ------------------------------------------------------- Voltage Control Logic End -----------------------------------------------------------------------------------\n\n// Save the pacLimit if it has been modified\nif (msg.pacLimitMWrite !== undefined) {\n       //node.warn(\"pacLimitMWrite was not set, setting default to Max limit\");\n   //msg.pacLimitMWrite = ..; // Setting a default value if none of the conditions met\n    //msg.case = \"Default Case: pacLimitMWrite was not set explicitly\";\n     global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n     var flag = global.get(\"logic_flag\")\n     if(flag == 1){\n        var time = new Date().getTime()\n        global.set(\"PAC_LIMIT_timestamp\", time)\n        global.set(\"logic_flag\",0)\n         global.set(\"mqtt_flag\", 1)\n\n     }\n} else {\n    flow.set('P_integral', 0);\n    flow.set('P_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.pacLimitMWrite = 20000; // Setting a default value if none of the conditions met\n    global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\n\n// Save the qacLimit if it has been modified\nif (msg.qacLimitMWrite !== undefined) {\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);  \n} else {\n    flow.set('Q_integral', 0);\n    flow.set('Q_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacLimitMWrite = 0; // Setting a default value if none of the conditions met\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);\n    msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\n\nif (msg.qacRefSelMWrite !== undefined) {\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n} else {\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacRefSelMWrite = 2; // Setting a default value if none of the conditions met\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\n\n//node.warn(`Final pacLimitMWrite: ${msg.pacLimitMWrite}, Case: ${msg.case}`);\n//node.warn(`Final qacLimitMWrite: ${msg.qacLimitMWrite}, Case: ${msg.caseq}`);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 1270,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "a1b67f212f5afbd3",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "name": "PPC_Logic",
        "func": "const caseReset = 4; // Threshold for resetting cases\nconst caseResetP = 8;\n// Function for File handling\nconst fd = global.get('fs');\n// Function to rename CSV files\nfunction renameCsvFiles(filePath) {\n    const files = fd.readdirSync(filePath).filter(file => file.endsWith('.csv'));\n    files.forEach(file => {\n        const oldPath = path.join(filePath, file);\n        const newPath = path.join(filePath, `${file.slice(0, -4)}.unsent`);\n        fd.renameSync(oldPath, newPath);\n    });\n}\n// Function to get epoch time\nfunction getEpochTime() {\n    // Get the current time and round down to the nearest 300 seconds\n    const now = Math.floor(Date.now() / 1000); // Convert to seconds\n    return now - (now % 300); // Round down to the nearest 300 seconds\n}\n// Function to log PPC Active Power Logic CSV\nfunction logCsv(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_01.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Reactive Power Logic CSV\nfunction logCsvQ(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_02.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Power Factor Logic CSV\nfunction logCsvPF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_05.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Voltage Logic CSV\nfunction logCsvU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_03.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Q/U Logic CSV\nfunction logCsvQU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_07.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Frequency Logic CSV\nfunction logCsvF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_04.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Ramp Logic CSV\nfunction logCsvR(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_06.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Set last file pack time\nconst TS = getEpochTime();\nflow.set('lastFilePackTime', TS);\n// Rename CSV files if needed\nif (flow.get('lastFilePackTime') < TS) {\n    renameCsvFiles('/mnt/jffs2/dglog');\n    flow.set('lastFilePackTime', TS);\n}\n// UI Settings value for P Control\nlet pacMaxSetCmd = global.get(\"PAC_MAX_SET_RX\")\nif (pacMaxSetCmd === undefined || isNaN(pacMaxSetCmd)) {\n    pacMaxSetCmd = 2772;\n}\nlet blkPacMaxCmd = global.get(\"BLOCK_PAC_MAX_SET_RX\")\nif (blkPacMaxCmd === undefined || isNaN(blkPacMaxCmd)) {\n    blkPacMaxCmd = 27720;\n}\nlet pacLLSetCmd = global.get(\"PAC_CL_SET_RX\")\nif (pacLLSetCmd === undefined || isNaN(pacLLSetCmd)) {\n    pacLLSetCmd = 2;\n}\nlet pacULSetCmd = global.get(\"PAC_ULL_SET_RX\")\nif (pacULSetCmd === undefined || isNaN(pacULSetCmd)) {\n    pacULSetCmd = 1;\n}\nconst pacGRSetCmd = global.get(\"PAC_GR_SET_RX\")\nconst pacTuneStCmd = global.get(\"PAC_TUNE_ST_CONST_RX\")\nconst pacIncconstCmd = global.get(\"PAC_INCR_SET_RX\")\nconst pacDecconstCmd = global.get(\"PAC_DECR_CONST_RX\")\n// UI Settings value for Q Control\nlet qacMaxSetCmd = global.get(\"QAC_MAX_SET_RX\")\nif (qacMaxSetCmd === undefined || isNaN(qacMaxSetCmd)) {\n    qacMaxSetCmd = 1500;\n}\nlet blkQacMaxCmd = global.get(\"BLOCK_QAC_MAX_SET_RX\")\nif (blkQacMaxCmd === undefined || isNaN(blkQacMaxCmd)) {\n    blkQacMaxCmd = 15000;\n}\nlet qacLLSetCmd = global.get(\"QAC_CL_SET_RX\")\nif (qacLLSetCmd === undefined || isNaN(qacLLSetCmd)) {\n    qacLLSetCmd = 2;\n}\nlet qacULSetCmd = global.get(\"QAC_ULL_SET_RX\")\nif (qacULSetCmd === undefined || isNaN(qacULSetCmd)) {\n    qacULSetCmd = 1;\n}\nconst qacGRSetCmd = global.get(\"QAC_GR_SET_RX\")\nlet tuneStep = global.get(\"QAC_TUNE_ST_CONST_RX\")\nconst qacIncConstCmd = global.get(\"QAC_INCR_SET_RX\")\nconst qacDecConstCmd = global.get(\"QAC_DECR_CONST_RX\")\n// UI Settings value for SVG Control\nconst svgSlot1StartHour = global.get(\"SVG_SLOT1_START_HOUR_RX1\")\nconst svgSlot2StartHour = global.get(\"SVG_SLOT2_START_HOUR_RX1\")\nconst svgSlot3StartHour = global.get(\"SVG_SLOT3_START_HOUR_RX1\")\nconst svgSlot4StartHour = global.get(\"SVG_SLOT4_START_HOUR_RX1\")\nconst svgSlot1StartMin = global.get(\"SVG_SLOT1_START_MIN_RX1\")\nconst svgSlot2StartMin = global.get(\"SVG_SLOT2_START_MIN_RX1\")\nconst svgSlot3StartMin = global.get(\"SVG_SLOT3_START_MIN_RX1\")\nconst svgSlot4StartMin = global.get(\"SVG_SLOT4_START_MIN_RX1\")\nconst svgSlot1StopHour = global.get(\"SVG_SLOT1_STOP_HOUR_RX1\")\nconst svgSlot2StopHour = global.get(\"SVG_SLOT2_STOP_HOUR_RX1\")\nconst svgSlot3StopHour = global.get(\"SVG_SLOT3_STOP_HOUR_RX1\")\nconst svgSlot4StopHour = global.get(\"SVG_SLOT4_STOP_HOUR_RX1\")\nconst svgSlot1StopMin = global.get(\"SVG_SLOT1_STOP_MIN_RX1\")\nconst svgSlot2StopMin = global.get(\"SVG_SLOT2_STOP_MIN_RX1\")\nconst svgSlot3StopMin = global.get(\"SVG_SLOT3_STOP_MIN_RX1\")\nconst svgSlot4StopMin = global.get(\"SVG_SLOT4_STOP_MIN_RX1\")\n// UI Settings Value for PF Control\nlet pfLLSetCmd = global.get(\"PF_LL_SET_RX\")\nif (pfLLSetCmd === undefined || isNaN(pfLLSetCmd)) {\n    pfLLSetCmd = 0.004;\n}\nlet pfULSetcmd = global.get(\"PF_TH_SET_RX\")\nif (pfULSetcmd === undefined || isNaN(pfULSetcmd)) {\n    pfULSetcmd = 0.004;\n}\nlet pfGRSetCmd2 = global.get(\"PF_GR_SET_RX2\")\nif (pfGRSetCmd2 === undefined || isNaN(pfGRSetCmd2)) {\n    pfGRSetCmd2 = 10;\n}\nlet pfGRSetCmd = global.get(\"PF_GR_SET_RX\")\nif (pfGRSetCmd === undefined || isNaN(pfGRSetCmd)) {\n    pfGRSetCmd = 10;\n}\nlet pfDecConstCmd = global.get(\"PF_DECR_CONST_RX\")\nif (pfDecConstCmd === undefined || isNaN(pfDecConstCmd)) {\n    pfDecConstCmd = 20;\n}\nlet pfIncConstCmd = global.get(\"PF_INCR_SET_RX\")\nif (pfIncConstCmd === undefined || isNaN(pfIncConstCmd)) {\n    pfIncConstCmd = 20;\n}\n// UI Settings Value for UAC Control\nlet quULSetCmd = global.get(\"UAC_ULL_SET_RX\")\nif (quULSetCmd === undefined || isNaN(quULSetCmd)) {\n    quULSetCmd = 1;\n}\nlet quLLSetCmd = global.get(\"UAC_CL_SET_RX\")\nif (quLLSetCmd === undefined || isNaN(quLLSetCmd)) {\n    quLLSetCmd = 1;\n}\nlet quGRSetCmd = global.get(\"UAC_GR_SET_RX\")\nif (quGRSetCmd === undefined || isNaN(quGRSetCmd)) {\n    quGRSetCmd = 0;\n}\nlet quTuneStCmd = global.get(\"UAC_TUNE_ST_CONST_RX\")\nif (quTuneStCmd === undefined || isNaN(quTuneStCmd)) {\n    quTuneStCmd = 2;\n}\nlet quIncConstCmd = global.get(\"UAC_INCR_SET_RX\")\nif (quIncConstCmd === undefined || isNaN(quIncConstCmd)) {\n    quIncConstCmd = 4;\n}\nlet quDecConstCmd = global.get(\"UAC_DECR_CONST_RX\")\nif (quDecConstCmd === undefined || isNaN(quDecConstCmd)) {\n    quDecConstCmd = 4;\n}\n// UI Settings Value for FAC Control\nlet facDeadBand = msg.facDeadBand\nif (facDeadBand === undefined || isNaN(facDeadBand)) {\n    facDeadBand = 0;\n}\nlet facLLSetCmd = global.get(\"FAC_LL_SET_CMD\")\nif (facLLSetCmd === undefined || isNaN(facLLSetCmd)) {\n    facLLSetCmd = 0.3;\n}\nlet facCULSetCmd = global.get(\"FAC_CUL_SET_CMD\")\nif (facCULSetCmd === undefined || isNaN(facCULSetCmd)) {\n    facCULSetCmd = 2.0;\n}\nlet facCLLSetCmd = global.get(\"FAC_CLL_SET_CMD\")\nif (facCLLSetCmd === undefined || isNaN(facCLLSetCmd)) {\n    facCLLSetCmd = 2.5;\n}\nlet facGRSetCmd = global.get(\"FAC_GR_SET_CMD\")\nif (facGRSetCmd === undefined || isNaN(facGRSetCmd)) {\n    facGRSetCmd = 0;\n}\nlet facTuneStCmd = global.get(\"FAC_TUNE_ST_CONST_CMD\")\nif (facTuneStCmd === undefined || isNaN(facTuneStCmd)) {\n    facTuneStCmd = 100;\n}\nlet facIncConstCmd = global.get(\"FAC_INCR_CONST_CMD\")\nif (facIncConstCmd === undefined || isNaN(facIncConstCmd)) {\n    facIncConstCmd = 1;\n}\nlet facDecConstCmd = global.get(\"FAC_DECR_CONST_CMD\")\nif (facDecConstCmd === undefined || isNaN(facDecConstCmd)) {\n    facDecConstCmd = 1;\n}\nlet fDroopCmd = msg.facDroop\nif (fDroopCmd === undefined || isNaN(fDroopCmd)) {\n    fDroopCmd = 5;\n}\n// UI Settings Value for RAMP Control\nconst rampTuneStCmd = global.get(\"RAMP_TUNE_ST_CONST_RX\")\nconst rampIncconstCmd = global.get(\"RAMP_INCR_CONST_RX\")\nconst rampDecconstCmd = global.get(\"RAMP_DECR_CONST_RX\")\nconst rampOnOffCmd = msg.ramponoff\n// UI Settings Value for VRT Control\nconst lvrthvrtULSetCmd = global.get(\"LVRT_HVRT_ULL_SET_RX\")\nconst lvrthvrtLLSetCmd = global.get(\"LVRT_HVRT_CL_SET_RX\")\n// Setpoint & Simulation Value for P Control\nconst dev = msg.device\nconst pacOnOffCmd = msg.paconoff\nconst fonoffcmd = msg.fonoff\nconst powselcmd = msg.selpc\nconst zePac = msg.gridpac * 1000\nconst zePMinLoad = (msg.pacpc * 1000)\nconst inverterOnline = msg.inverterOnline\nconst inverterOnlineQ = msg.inverterOnlineQ\nlet PAC_LIMIT = msg.paclimit\nif (PAC_LIMIT === undefined || isNaN(PAC_LIMIT)) {\n    PAC_LIMIT = 2772;\n}\nconst zeIacMaxCmd = msg.maxcurrent\nconst zeIacSetCmd = msg.setcurrent\nconst zeIac = msg.gridiac\nconst pvPac = msg.invpac\nconst Kp = msg.kp\nconst Ti = msg.ti\nconst Kd = msg.kd\nlet Inv_Setpoint\nlet P_error\nlet P_integral = flow.get('P_integral') || 0;\nlet P_derivative\nlet P_previous_error = flow.get('P_previous_error') || 0;\nconst zeSac = global.get(\"CR.VR_EM.SAC\")\n// Setpoint & Simulation Value for Q Control\nconst qaconoffcmd = msg.qaconoff\nconst zeQac = msg.gridqac * 1000\nlet zeMinLoad = ((msg.qacpc * 1000))\nlet QAC_LIMIT = msg.qaclimit\nif (QAC_LIMIT === undefined || isNaN(QAC_LIMIT)) {\n    QAC_LIMIT = 0;\n}\nconst zePfSetCmd = msg.setpf\nconst zepfMaxLoad = msg.maxpf\nlet zePf = msg.gridpf\nzePf = parseFloat(zePf.toFixed(3));\nconst pvQac = msg.invqac\nconst Kpq = msg.kpq\nconst Tiq = msg.tiq\nconst Kdq = msg.kdq\nlet Inv_Qsetpoint\nlet Q_error\n//let Q_integral\nlet Q_integral = flow.get('Q_integral') || 0;\n//if (Q_integral === undefined || isNaN(Q_integral)) { Q_integral = 0; }\nlet Q_derivative\nlet Q_previous_error = flow.get('Q_previous_error') || 0;\nlet qacRefSel = msg.qacrefsel\n// Setpint Value for SVG Control\nconst svgonoffcmd = msg.svgonoff\nconst svgslot1pccmd = msg.svgslot1pc\nconst svgslot2pccmd = msg.svgslot2pc\nconst svgslot3pccmd = msg.svgslot3pc\n// Setpoint & Simulation Value for PF Control\nconst pfonoffcmd = msg.pfonoff\nconst zePFMinLoad = msg.pfpc\nconst zePFThreshold = pfULSetcmd\n// Setpoint & Simulation Value for U Control\nconst uaconoffcmd = msg.uaconoff\nconst zeUMinLoad = msg.uacpc\nconst zeUac = msg.griduac\n//let zeUThreshold = (zeUMinLoad * (msg.VDdroop / 100))\n//let zeUCriticalLoad = zeUMinLoad - ((quLLSetCmd / 100) * zeUMinLoad);\nlet qacMaxSet\nlet ratedQCapacity\nconst ratedvoltage = msg.Vrated\nconst droopPercentage = msg.Vdroop\n//const dbPercentage = msg.VDdroop\nconst droopDeadbandPercentage = msg.VDdroop\n// Setpoint & Simulation Value for Q/U Control\nconst quonoffcmd = msg.quonoff\n// Voltage Droop Calculation\nconst dbThreshold = (droopDeadbandPercentage * ratedvoltage) / 100\nconst droopThreshold = (droopPercentage * ratedvoltage) / 100\nconst deadBandMax = ratedvoltage + dbThreshold\nconst deadBandMin = ratedvoltage - dbThreshold\nconst droopMax = ratedvoltage + droopThreshold\nconst droopMin = ratedvoltage - droopThreshold\n// Setpoint & Simulation Value for VRT Control\nconst lvrtHvrtOnOffCmd = msg.lvrthvrtonoff\nconst zelvrthvrtCriticalLoad = (zeUMinLoad * (lvrthvrtULSetCmd / 100));\nconst zelvrthvrtThreshold = zeUMinLoad - ((lvrthvrtLLSetCmd / 100) * zeUMinLoad);\n// Setpoint & Simulation Value for F Control\nconst faconoffcmd = msg.faconoff\nconst zeFMinLoad = msg.facpc\nconst zeFac = msg.gridfac\nconst zeFCriticalLoad = facLLSetCmd\nconst zeFUCriticalLoad = facCULSetCmd\nconst zeFLCriticalLoad = facCLLSetCmd\nconst zeFThreshold = facDeadBand\nlet pacLimitdel\n// Initialize pacLimit and other variables\nlet maxPacLimit = ((PAC_LIMIT));\nflow.set(\"maxPacLimit\", maxPacLimit);\n//let oldPacLimit1 = flow.get('oldPacLimit1') || maxPacLimit;\nlet oldPacLimit1\nlet minPacLimit = maxPacLimit;\nconst invPacLimit = ((PAC_LIMIT)); // Assuming this comes from msg\nconst zePCriticalLoad = zePMinLoad - ((pacLLSetCmd / 100) * blkPacMaxCmd)\nconst zePThreshold = (pacULSetCmd / 100) * blkPacMaxCmd\n// Update max and min limits based on invPacLimit\nif (!isNaN(invPacLimit)) {\n    if (invPacLimit > maxPacLimit) maxPacLimit = invPacLimit;\n    if (invPacLimit < minPacLimit) minPacLimit = invPacLimit;\n}\nlet pacLimit = maxPacLimit;\n// Initialize qacLimit and other variables\nlet maxQacLimit = ((QAC_LIMIT) / qacMaxSetCmd) * 100;\nlet minQacLimit = maxQacLimit;\nlet oldQacLimit1\nconst invQacLimit = ((QAC_LIMIT) / qacMaxSetCmd) * 100; // Assuming this comes from msg\nlet zeCriticalLoad = zeMinLoad - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeThreshold = (qacULSetCmd / 100) * blkQacMaxCmd\n//SVG Variables\nconst zeSvgSlot1MinLoad = svgslot1pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot1CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nconst zeSvgSlot2MinLoad = svgslot2pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot2CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nconst zeSvgSlot3MinLoad = svgslot3pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot3CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nlet qModeEnable\n// Update max and min limits based on invQacLimit\nif (!isNaN(invQacLimit)) {\n    if (invQacLimit > maxQacLimit) maxQacLimit = invQacLimit;\n    if (invQacLimit < minQacLimit) minQacLimit = invQacLimit;\n}\nlet qacLimit = (maxQacLimit * qacMaxSetCmd) / 100;\nqacLimit = parseFloat(qacLimit.toFixed(1));\n//let oldQacLimit = QAC_LIMIT / 10;\n//let qacLimitW = qacLimit;\n//let oldQacLimitW = qacLimit;\n//let pvQacW = qacLimit;\n//node.warn(`x:${maxQacLimit}`)\nmsg.pacLimitMWrite = undefined; // Initialize msg.pacLimitMWrite to undefined to identify if it remains unset\nmsg.qacLimitMWrite = undefined; // Initialize msg.qacLimitMWrite to undefined to identify if it remains unset\n// PPC P Control Casereset\nlet case1ZEP = flow.get('case1ZEP');\nif (case1ZEP === undefined || isNaN(case1ZEP)) {\n    case1ZEP = caseResetP;\n    flow.set(\"case1ZEP\", case1ZEP)\n}\nlet case2ZEP = flow.get('case2ZEP');\nif (case2ZEP === undefined || isNaN(case2ZEP)) {\n    case2ZEP = caseResetP;\n    flow.set(\"case2ZEP\", case2ZEP);\n}\nlet case3ZEP = flow.get('case3ZEP');\nif (case3ZEP === undefined || isNaN(case3ZEP)) {\n    case3ZEP = caseResetP;\n    flow.set(\"case3ZEP\", case3ZEP);\n}\nlet case4ZEP = flow.get('case4ZEP');\nif (case4ZEP === undefined || isNaN(case4ZEP)) {\n    case4ZEP = caseResetP;\n    flow.set(\"case4ZEP\", case4ZEP);\n}\nlet case5ZEP = flow.get('case5ZEP');\nif (case5ZEP === undefined || isNaN(case5ZEP)) {\n    case5ZEP = caseResetP;\n    flow.set(\"case5ZEP\", case5ZEP);\n}\n// PPC Q Control Casereset\nlet case1ZEQ = flow.get('case1ZEQ');\nif (case1ZEQ === undefined || isNaN(case1ZEQ)) {\n    case1ZEQ = caseReset;\n    flow.set(\"case1ZEQ\", case1ZEQ);\n}\nlet case2ZEQ = flow.get('case2ZEQ');\nif (case2ZEQ === undefined || isNaN(case2ZEQ)) {\n    case2ZEQ = caseReset;\n    flow.set(\"case2ZEQ\", case2ZEQ);\n}\nlet case3ZEQ = flow.get('case3ZEQ');\nif (case3ZEQ === undefined || isNaN(case3ZEQ)) {\n    case3ZEQ = caseReset;\n    flow.set(\"case3ZEQ\", case3ZEQ);\n}\nlet case4ZEQ = flow.get('case4ZEQ');\nif (case4ZEQ === undefined || isNaN(case4ZEQ)) {\n    case4ZEQ = caseReset;\n    flow.set(\"case4ZEQ\", case4ZEQ);\n}\nlet case5ZEQ = flow.get('case5ZEQ');\nif (case5ZEQ === undefined || isNaN(case5ZEQ)) {\n    case5ZEQ = caseReset;\n    flow.set(\"case5ZEQ\", case5ZEQ);\n}\n// PPC PF Control Casereset\nlet case1ZEPF = flow.get('case1ZEPF');\nif (case1ZEPF === undefined || isNaN(case1ZEPF)) {\n    case1ZEPF = caseReset;\n    flow.set(\"case1ZEPF\", case1ZEPF);\n}\nlet case2ZEPF = flow.get('case2ZEPF');\nif (case2ZEPF === undefined || isNaN(case2ZEPF)) {\n    case2ZEPF = caseReset;\n    flow.set(\"case2ZEPF\", case2ZEPF);\n}\nlet case3ZEPF = flow.get('case3ZEPF');\nif (case3ZEPF === undefined || isNaN(case3ZEPF)) {\n    case3ZEPF = caseReset;\n    flow.set(\"case3ZEPF\", case3ZEPF);\n}\nlet case4ZEPF = flow.get('case4ZEPF');\nif (case4ZEPF === undefined || isNaN(case4ZEPF)) {\n    case4ZEPF = caseReset;\n    flow.set(\"case4ZEPF\", case4ZEPF);\n}\nlet case5ZEPF = flow.get('case5ZEPF');\nif (case5ZEPF === undefined || isNaN(case5ZEPF)) {\n    case5ZEPF = caseReset;\n    flow.set(\"case5ZEPF\", case5ZEPF);\n}\n// PPC U Control Casereset\nlet case1ZEU = flow.get('case1ZEU');\nif (case1ZEU === undefined || isNaN(case1ZEU)) {\n    case1ZEU = caseReset;\n    flow.set(\"case1ZEU\", case1ZEU);\n}\nlet case2ZEU = flow.get('case2ZEU');\nif (case2ZEU === undefined || isNaN(case2ZEU)) {\n    case2ZEU = caseReset;\n    flow.set(\"case2ZEU\", case2ZEU);\n}\nlet case3ZEU = flow.get('case3ZEU');\nif (case3ZEU === undefined || isNaN(case3ZEU)) {\n    case3ZEU = caseReset;\n    flow.set(\"case3ZEU\", case3ZEU);\n}\nlet case4ZEU = flow.get('case4ZEU');\nif (case4ZEU === undefined || isNaN(case4ZEU)) {\n    case4ZEU = caseReset;\n    flow.set(\"case4ZEU\", case4ZEU);\n}\nlet case5ZEU = flow.get('case5ZEU');\nif (case5ZEU === undefined || isNaN(case5ZEU)) {\n    case5ZEU = caseReset;\n    flow.set(\"case5ZEU\", case5ZEU);\n}\nlet case6ZEU = flow.get('case6ZEU');\nif (case6ZEU === undefined || isNaN(case6ZEU)) {\n    case6ZEU = caseReset;\n    flow.set(\"case6ZEU\", case6ZEU);\n}\n// PPC F Control Casereset\nlet case1ZEF = flow.get('case1ZEF');\nif (case1ZEF === undefined || isNaN(case1ZEF)) {\n    case1ZEF = caseReset;\n    flow.set(\"case1ZEF\", case1ZEF);\n}\nlet case2ZEF = flow.get('case2ZEF');\nif (case2ZEF === undefined || isNaN(case2ZEF)) {\n    case2ZEF = caseReset;\n    flow.set(\"case2ZEF\", case2ZEF);\n}\nlet case3ZEF = flow.get('case3ZEF');\nif (case3ZEF === undefined || isNaN(case3ZEF)) {\n    case3ZEF = caseReset;\n    flow.set(\"case3ZEF\", case3ZEF);\n}\nlet case4ZEF = flow.get('case4ZEF');\nif (case4ZEF === undefined || isNaN(case4ZEF)) {\n    case4ZEF = caseReset;\n    flow.set(\"case4ZEF\", case4ZEF);\n}\nlet case5ZEF = flow.get('case5ZEF');\nif (case5ZEF === undefined || isNaN(case5ZEF)) {\n    case5ZEF = caseReset;\n    flow.set(\"case5ZEF\", case5ZEF);\n}\n\n// ------------------------------- Open Loop Logic Start ---------------------------------------------\nlet OLpacLimit = msg.openplimit\nlet OLqacLimit = msg.openqlimit\nif (powselcmd == 0) {\n    if ((OLpacLimit != undefined || !isNaN(OLpacLimit))) {\n        msg.pacLimitMWrite = OLpacLimit;\n        msg.case = \"Case 0: PACLIMIT has given from User\";\n    }\n    if ((qacRefSel != undefined || !isNaN(qacRefSel))) {\n        msg.qacRefSelMWrite = global.get(\"QAC_REF_SEL_RX\")\n    }\n    if ((OLqacLimit != undefined && !isNaN(OLqacLimit))) {\n        msg.qacLimitMWrite = OLqacLimit;\n        msg.caseq = \"Case 0: QACLIMIT has given from User\";\n    } else {\n        msg.qacLimitMWrite = 0\n        msg.caseq = \"Case 0: QACLIMIT has given from UI\";\n    }\n}\n// ---------------------------------- Open Loop Logic Stop ----------------------------------------------------\n// ---------------------------------- QAC Sel Mode Start----------------------------------------------------\nif (powselcmd == 1) {\n    if ((qacRefSel != undefined || !isNaN(qacRefSel || qacRefSel != 162))) {\n        msg.qacRefSelMWrite = 162\n    }\n}\n// ---------------------------------- QAC Sel Mode End --------------------------------------------------------\n// ---------------------------------------- Active Power Control Logic Start -------------------------------------------------------\n//node.warn(`zePac: ${zePac}, fonoffcmd: ${fonoffcmd}`);\nif (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && pacOnOffCmd == 1 && faconoffcmd == 0) {\n    const KpOld = 0.07\n    const TiOld = 10\n    const KdOld = 0.01\n    const RR_Intial = 5.88;\n    const Diff_Intial = 3000;\n    const prevPMinLoad = flow.get(\"prev_zeminP\");\n    const Diff_old = flow.get(\"Diff_old\");\n    let Diff_New\n    let PPID\n    if (zePMinLoad !== prevPMinLoad) {\n        // Value changed  calculate and save\n        Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminP\", zePMinLoad);\n        flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"P_integral\", 0);\n        flow.set(\"P_previous_error\", 0);\n        flow.set(\"firstPIDRunCase1\", true);\n        flow.set(\"firstPIDRunCase2\", true);\n        flow.set(\"case1ZEP\", 2);\n        flow.set(\"case2ZEP\", 2);\n        oldPacLimit1 = pacLimit;\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n    } else {\n        Diff_New = Diff_old\n        oldPacLimit1 = flow.get(\"oldPacLimit1\");\n    }\n    P_integral = flow.get(\"P_integral\")\n    P_previous_error = flow.get(\"P_previous_error\")\n    P_error = flow.get(\"P_error\")\n    P_derivative = flow.get(\"P_derivative\")\n    PPID = flow.get(\"PID\")\n    case1ZEP = flow.get(\"case1ZEP\")\n    case2ZEP = flow.get(\"case2ZEP\")\n    const RR_old = RR_Intial / (Diff_Intial / Diff_New);\n    const RR_new = 10;\n    //const Kp = KpOld * (RR_new / RR_old) ** 1;  /*Need to update the logic that at any point of time static Kp, Ti, Kd can't exceed by dynamic calculated Kp, ti  Kd*/\n    //const Ti = TiOld * (RR_old / RR_new) ** 1;\n    //const Kd = KdOld * (RR_new / RR_old) ** 0.5;\n    const Kp = 0.35\n    const Ti = 10\n    const Kd = 0.01\n    flow.set(\"Kp\", Kp)\n    flow.set(\"Ti\", Ti)\n    flow.set(\"Kd\", Kd)\n    if (zePac >= (zePMinLoad + zePThreshold) && (zeIac < zeIacSetCmd) && (maxPacLimit <= pacMaxSetCmd)) {\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n        //node.warn(pacLimit)\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        if (case1ZEP >= caseResetP) {\n            Inv_Setpoint = zePMinLoad;\n            P_error = zePac - Inv_Setpoint;\n            P_integral = P_integral + (P_error * 0.1);\n            P_derivative = (P_error - P_previous_error) / 0.1\n            P_previous_error = P_error\n            P_error = parseFloat(P_error.toFixed(1));\n            P_integral = parseFloat(P_integral.toFixed(1));\n            P_derivative = parseFloat(P_derivative.toFixed(1));\n            P_previous_error = parseFloat(P_previous_error.toFixed(1));\n            //node.warn(`pvPac: ${pvPac}`);\n            let firstPIDRunCase1 = flow.get(\"firstPIDRunCase1\");\n            if (typeof firstPIDRunCase1 === \"undefined\") {\n                firstPIDRunCase1 = true;\n            }\n            if (firstPIDRunCase1) {\n                pacLimit = (((pvPac) - (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))) / inverterOnline)\n                flow.set(\"firstPIDRunCase1\", false);\n            } else {\n                pacLimit = oldPacLimit1 - (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)) / inverterOnline)\n            }\n            //if (pacLimit < (Inv_Setpoint / inverterOnline)) { pacLimit = oldPacLimit1 }\n            if (pacLimit <= 10) pacLimit = 10;\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            case1ZEP = 0;\n            flow.set('case1ZEP', case1ZEP);\n            PPID = (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))\n            oldPacLimit1 = pacLimit;\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.1.0 force down\";\n            const logMessage = `1.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        } else {\n            // Increment case1ZEP and set flow context\n            case1ZEP++;\n            flow.set('case1ZEP', case1ZEP);\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.1.1 force down\";\n            const logMessage = `1.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n        flow.set(\"P_integral\", P_integral);\n        flow.set(\"P_previous_error\", P_previous_error);\n        flow.set(\"P_error\", P_error);\n        flow.set(\"P_derivative\", P_derivative);\n        flow.set(\"PPID\", PPID);\n    }\n    // Case 2: < critical load\n    else if ((zePac <= zePMinLoad - zePThreshold) && zeIac < zeIacSetCmd && (maxPacLimit <= pacMaxSetCmd)) {\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        if (case2ZEP >= caseResetP) {\n            Inv_Setpoint = zePMinLoad;\n            P_error = Inv_Setpoint - (zePac);\n            P_integral = P_integral + (P_error * 0.1);\n            P_derivative = (P_error - P_previous_error) / 0.1\n            P_previous_error = P_error\n            P_error = parseFloat(P_error.toFixed(1));\n            P_integral = parseFloat(P_integral.toFixed(1));\n            P_derivative = parseFloat(P_derivative.toFixed(1));\n            P_previous_error = parseFloat(P_previous_error.toFixed(1));\n            let firstPIDRunCase2 = flow.get(\"firstPIDRunCase2\");\n            if (typeof firstPIDRunCase2 === \"undefined\") {\n                firstPIDRunCase2 = true;\n            }\n            if (firstPIDRunCase2) {\n                pacLimit = (((pvPac) + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))) / inverterOnline)\n                flow.set(\"firstPIDRunCase2\", false);\n            } else {\n                pacLimit = oldPacLimit1 + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)) / inverterOnline)\n            }\n            if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            PPID = (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))\n            oldPacLimit1 = pacLimit\n            case2ZEP = 0;\n            flow.set('case2ZEP', case2ZEP);\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.2.0 force UP\";\n            const logMessage = `1.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        } else {\n            // Increment case2ZEP if caseReset is not reached\n            case2ZEP++;\n            flow.set('case2ZEP', case2ZEP);\n            if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.2.1 force UP\";\n            const logMessage = `1.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n        flow.set(\"P_integral\", P_integral);\n        flow.set(\"P_previous_error\", P_previous_error);\n        flow.set(\"P_error\", P_error);\n        flow.set(\"P_derivative\", P_derivative);\n        flow.set(\"PPID\", PPID);\n    }\n    // Case 3:  > Critical  & < lower ---tune up\n    // Case 4: ZEP meter > 0 & ZEP meter < minload no change\n    else if (zeIac >= zeIacSetCmd && maxPacLimit < pacMaxSetCmd) {\n        if (zeIac > zeIacMaxCmd) {\n            let pacLimit = maxPacLimit - (pacTuneStCmd * pacMaxSetCmd / 1000);\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            if (case4ZEP >= caseReset) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10;\n                msg.pacLimitMWrite = pacLimit ;\n                msg.case = \"1.4.0 current\"\n                const logMessage = `1.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10;\n                msg.pacLimitMWrite = pacLimit ;\n                msg.case = \"1.4.1 current\"\n                const logMessage = `1.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            }\n        } else {\n            pacLimit = pacLimit\n            if (case4ZEP >= caseResetP) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10;\n                msg.pacLimitMWrite = pacLimit ;\n                msg.case = \"1.4.2 current\"\n                const logMessage = `1.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.3 current\"\n                const logMessage = `1.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            }\n        }\n    }\n    // Case 5: Stable\n    // else if ((zePac <= zePMinLoad + zePThreshold && zePac >= zePMinLoad - zePThreshold || maxPacLimit <= pacMaxSetCmd )&& zeIac < zeIacSetCmd) {\n    else {\n        pacLimit = oldPacLimit1;\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        oldPacLimit1 = parseFloat(oldPacLimit1.toFixed(1));\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"P_integral\", 0);\n        flow.set(\"P_previous_error\", 0);\n        flow.set(\"case1ZEP\", 2);\n        flow.set(\"case2ZEP\", 2);\n        flow.set(\"firstPIDRunCase1\", true);\n        flow.set(\"firstPIDRunCase2\", true);\n        if (case5ZEP >= caseReset) {\n            case5ZEP = 0;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.5.0 stable\"\n            const logMessage = `1.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        } else {\n            case5ZEP++;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 0) pacLimit = 0;\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.5.1 stable\"\n            const logMessage = `1.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        }\n    }\n}\n// ------------------------------------------ Active Power Control Logic End -------------------------------------------------------------------------------\n// ------------------------------------------ Reactive Power Control Logic Start ----------------------------------------------------------------------------\n//node.warn(`zeQac: ${zeQac}, qaconoffcmd: ${qaconoffcmd}`);\nif (!isNaN(zeQac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && (qaconoffcmd == 1 || svgonoffcmd == 1)) {\n    const now = new Date();\n    const min = now.getMinutes();\n    const hour = now.getHours();\n    //node.warn(`1:${zeQac}, 2:${powselcmd}, 3: ${inverterOnline}, , 4: ${fonoffcmd},5: ${qaconoffcmd}, 6: ${inverterOnline }`)\n    // Select the setpoint based on Slots\n    if (qaconoffcmd == 1 && svgonoffcmd == 1) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            zeCriticalLoad = zeSvgSlot1CriticalLoad;\n            zeMinLoad = zeSvgSlot1MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            zeCriticalLoad = zeSvgSlot2CriticalLoad;\n            zeMinLoad = zeSvgSlot2MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            zeCriticalLoad = zeSvgSlot3CriticalLoad;\n            zeMinLoad = zeSvgSlot3MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            zeCriticalLoad = zeCriticalLoad;\n            zeMinLoad = zeMinLoad;\n            qModeEnable = 1;\n        }\n    }\n    if (qaconoffcmd == 0 && svgonoffcmd == 1) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            zeCriticalLoad = zeSvgSlot1CriticalLoad;\n            zeMinLoad = zeSvgSlot1MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            zeCriticalLoad = zeSvgSlot2CriticalLoad;\n            zeMinLoad = zeSvgSlot2MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            zeCriticalLoad = zeSvgSlot3CriticalLoad;\n            zeMinLoad = zeSvgSlot3MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            qModeEnable = 0;\n        }\n    }\n    if (qaconoffcmd == 1 && svgonoffcmd == 0) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            zeCriticalLoad = zeCriticalLoad;\n            zeMinLoad = zeMinLoad;\n            qModeEnable = 1;\n        }\n    }\n    //node.warn(`svg_status,${hour}`)\n    //node.warn(`setpoint,${svgSlot4StartHour}`)\n    const prevQMinLoad = flow.get(\"prev_zeminQ\");\n    if (zeMinLoad !== prevQMinLoad) {\n        // Value changed  calculate and save\n        //Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminQ\", zeMinLoad);\n        //flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEQ\", 1);\n        flow.set(\"case2ZEQ\", 1);\n        oldQacLimit1 = qacLimit;\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n    } else {\n        oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    }\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    case1ZEQ = flow.get(\"case1ZEQ\")\n    case2ZEQ = flow.get(\"case2ZEQ\")\n    // Case 1: ZE meter < critical load (100VAR); Reactive Power supply to grid  && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    if (zeQac <= (zeMinLoad - zeThreshold) && (maxQacLimit >= -100) && (minQacLimit <= 100)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        if (case1ZEQ >= caseReset) {\n            Inv_Qsetpoint = zeMinLoad\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            //node.warn(`Qerrorcase1: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} , qacLimit: ${(qacLimit)}  `)\n            // if (qacLimit > -12 && qacLimit < 12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEQ = 0;\n            flow.set('case1ZEQ', case1ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.1.0\";\n            const logMessageQ = `2.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case1ZEQ++;\n            flow.set('case1ZEQ', case1ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.1.1\";\n            const logMessageQ = `2.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n        flow.set(\"Q_integral\", Q_integral);\n        flow.set(\"Q_previous_error\", Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n        //node.warn(`Qerrorcase1final: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} , qacLimit: ${(qacLimit)}  `)\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if ((zeQac >= (zeMinLoad + zeThreshold)) && (maxQacLimit >= -100) && (minQacLimit <= 100)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        if (case2ZEQ >= caseReset) {\n            Inv_Qsetpoint = zeMinLoad\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            // if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEQ = 0;\n            flow.set('case2ZEQ', case2ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.2.0\";\n            const logMessageQ = `2.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case2ZEQ++;\n            flow.set('case2ZEQ', case2ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.2.1\";\n            const logMessageQ = `2.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n        flow.set(\"Q_integral\", Q_integral);\n        flow.set(\"Q_previous_error\", Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n        //node.warn(`Qerrorcase2: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} `)\n    }\n    //case 5   && qModeEnable === 1\n    else if ((zeQac <= (zeMinLoad + zeThreshold)) && (zeQac >= (zeMinLoad - zeThreshold))) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEQ\", 1);\n        flow.set(\"case2ZEQ\", 1);\n        if (case5ZEQ >= caseReset) {\n            case5ZEQ = 0;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.0 stable\"\n            const logMessageQ = `2.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case5ZEQ++;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.1 stable\"\n            const logMessageQ = `2.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n    }\n}\n// --------------------------------------------------------- Reactive Power Control Logic End ----------------------------------------------------------------------\n// --------------------------------------------------------- Power Factor Control Logic Start ---------------------------------------------------------------------- */\nif (!isNaN(zePf) && powselcmd === 1 && inverterOnlineQ > 0 && fonoffcmd === 1 && pfonoffcmd === 1) {\n    //node.warn(`Final qacLimitMWrite: ${(maxQacLimit1)}, Case: ${zePFMinLoad + zePFThreshold}`)\n    const prevPFMinLoad = flow.get(\"prev_zeminPF\");\n    if (zePFMinLoad !== prevPFMinLoad) {\n        // Value changed  calculate and save\n        //Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminPF\", zePFMinLoad);\n        //flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEPF\", 1);\n        flow.set(\"case2ZEPF\", 1);\n        flow.set(\"case3ZEPF\", 1);\n        flow.set(\"case4ZEPF\", 1);\n        oldQacLimit1 = qacLimit;\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n    } else {\n        oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    }\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    case1ZEPF = flow.get(\"case1ZEPF\")\n    case2ZEPF = flow.get(\"case2ZEPF\")\n    case3ZEPF = flow.get(\"case3ZEPF\")\n    case4ZEPF = flow.get(\"case4ZEPF\")\n    //case1: 1st Quadrant Operation with Actual PF (+ve) is less than Setpoint so need to reduce the Reactive Power Supply or Abosrb from Grid and limit should go from 100% to -100%\n    if (zePf < (zePFMinLoad - zePFThreshold) && (zePac > 180) && zePFMinLoad > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`x:${zePFMinLoadnew}`)\n        if (case1ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.1.0\";\n            const logMessagePF = `5.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.1.1\";\n            const logMessagePF = `5.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//case2: Runs Only when Actual is -ve PF and Set is +ve PF for short time when P>0 \n    else if (zePf < (zePFMinLoad - zePFThreshold) && (zePac > 180) && zePf <= 1 && zePFMinLoad > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`y:${zePFMinLoadnew}`)\n        if (case1ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.7.0\";\n            const logMessagePF = `5.7.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.7.1\";\n            const logMessagePF = `5.7.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    } //Case 3: Runs Only when Actual is -ve PF and Set is +ve PF for short time when P<0\n    else if (zePf < (zePFMinLoad + zePFThreshold) && (zePac < 0) && zePf <= 1 && zePFMinLoad > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`z:${zePFMinLoadnew}`)\n        if (case2ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.6.0\";\n            const logMessagePF = `5.6.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.6.1\";\n            const logMessagePF = `5.6.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Maximum Demand Penalty Avoidance Case during Night Time or Improt conditions \n    else if (zeSac >= 1400 && zePac < 0) {\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit ;\n        msg.caseq = \"5.9.0\";\n        const logMessagePF = `5.9.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }//If there is not Much Active Power / DC available the Make Q Command as Zero to not force the Inverter.\n    else if (zePac <= 180 && zePac >= 0) {\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit ;\n        msg.caseq = \"5.9.1\";\n        const logMessagePF = `5.9.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }//Case4: Setpoint is less than PF actual and also PF setpoint is +ve and so Need to Delivery or Supply more Q to grid; Limits goes to -100 to + 100\n    else if (((zePf > (zePFThreshold + zePFMinLoad))) && zePf >= -1 && zePFMinLoad > 0 && minQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`a:${zePFMinLoadnew}`)\n        if (case2ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.2.0\";\n            const logMessagePF = `5.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.2.1\";\n            const logMessagePF = `5.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 5: Actual PF & PF Setpoints are -ve and Actual PF is > Setpoint and so reduce the Q Consumption; Limit goes from -100 to + 100\n    else if (zePf > (zePFThreshold + zePFMinLoad) && zePFMinLoad < 0 && zePf < 0 && maxQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad + zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad + zePFThreshold) * (zePFMinLoad + zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`b:${zePFMinLoadnew}`)\n        if (case3ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case3ZEPF = 0;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.3.0\";\n            const logMessagePF = `5.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case3ZEPF++;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.3.1\";\n            const logMessagePF = `5.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 6: Set Point is -ve PF and Actual is +ve PF and so limit should do from +100 to -100\n    else if ((zePf < zePFMinLoad || zePf >= ((-zePFThreshold) - (zePFMinLoad))) && (zePFMinLoad < 0) && (zePf >= -1) && (maxQacLimit < 100) && (minQacLimit > -101)) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`c:${zePFMinLoadnew}`)\n        //node.warn(`(1:${((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)) })`)\n        if (case4ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case4ZEPF = 0;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.4.0\";\n            const logMessagePF = `5.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case4ZEPF++;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.4.1\";\n            const logMessagePF = `5.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 7: Stable Case \n    else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        if (case5ZEPF >= caseReset) {\n            case5ZEPF = 0;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"5.5.0\"\n            const logMessagePF = `5.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case5ZEPF++;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"5.5.1\"\n            const logMessagePF = `5.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n    }\n}\n// ------------------------------------------------------ Power Factor Logic End -----------------------------------------------------------------------------\n// ------------------------------------------------------ Voltage Control Logic Start -------------------------------------------------------------------------\nif (!isNaN(zeUac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && (uaconoffcmd === 1 || lvrtHvrtOnOffCmd === 1)) {\n    ratedQCapacity = msg.ratedPcapacity * 0.33\n    oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    qacLimit = oldQacLimit1\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    //node.warn(`deadBandMax: ${zeUac}, droopMax: ${droopMax}`);\n    //node.warn(`deadBandMin: ${deadBandMin}, droopMin: ${droopMin}`);\n    //let zeUacold = flow.get(\"zeUacold\")\n    //if (zeUacold === undefined || isNaN(zeUacold)) { zeUacold = 132; }\n    if ((zeUac > (deadBandMax)) && (zeUac <= droopMax)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMax) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n        if ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold) || ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold))))) {\n            if (case1ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},Q_act:${zeQac},Q_CMD:${qacLimit}`)\n                if (zeQac > (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case1ZEU = 0;\n                flow.set(\"case1ZEU\", case1ZEU);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"3.1.0\"\n                const logMessageU = `3.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case1ZEU++;\n                flow.set(\"case1ZEU\", case1ZEU);\n                msg.qacLimitMWrite = oldQacLimit1;\n                msg.caseq = \"3.1.1\"\n                const logMessageU = `3.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.1.5\"\n            const logMessageU = `3.1.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if (zeUac < (deadBandMin) && zeUac >= droopMin) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMin) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n        if ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold) || ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold))))) {\n            //node.warn(`zeThreshold:${((Inv_Qsetpoint*1000) - zeThreshold)},Q_error:${((Inv_Qsetpoint*1000) + zeThreshold)}`)\n            if (case2ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},zeQaC:${zeQac}`)\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                if (zeQac > (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case2ZEU = 0;\n                flow.set(\"case2ZEU\", case2ZEU);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"3.2.0\"\n                const logMessageU = `3.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case2ZEU++;\n                flow.set(\"case2ZEU\", case2ZEU);\n                msg.qacLimitMWrite = qacLimit ;\n                msg.caseq = \"3.2.1\"\n                const logMessageU = `3.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"3.2.5\"\n            const logMessageU = `3.2.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    // case 3 \n    /*else if ((zePac > 0) && (zeUac >= deadBandMin) && (zeUac <= deadBandMax)) {\n        if (zePac > 0 && uaconoffcmd === 1) {\n            qacMaxSet = 0\n            qacLimit = qacMaxSet * 1000\n            oldQacLimit1 = qacLimit\n            if (case3ZEU >= caseReset) {\n                case3ZEU = 0;\n                flow.set(\"oldQacLimit1\", oldQacLimit1);\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.0\"\n                const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case3ZEU++;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.1\"\n                const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n        }\n    }*/\n    else if ((zePac > 0) && (zeUac >= deadBandMin) && (zeUac <= deadBandMax)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMin) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100))) * 0\n        if ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold) || ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold))))) {\n            //node.warn(`zeThreshold:${((Inv_Qsetpoint*1000) - zeThreshold)},Q_error:${((Inv_Qsetpoint*1000) + zeThreshold)}`)\n            if (case3ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},zeQaC:${zeQac}`)\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                if (zeQac > 0) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < 0) {\n                    if (qacLimit < 12 && qacLimit > 0) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case3ZEU = 0;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit ;\n                msg.caseq = \"3.3.0\"\n                const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case3ZEU++;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit ;\n                msg.caseq = \"3.3.1\"\n                const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.3.5\"\n            const logMessageU = `3.3.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    //case 4\n    // case 5 \n    else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        case5ZEU++;\n        flow.set(\"case5ZEU\", case5ZEU);\n        msg.qacLimitMWrite = qacLimit;\n        msg.caseq = \"3.5.0\"\n        const logMessageU = `3.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n        logCsvU(logMessageU);\n    }\n}\n// ------------------------------------------------------- Voltage Control Logic End -----------------------------------------------------------------------------------\n// ------------------------------- Frequency COntrol Start --------------------------------------------------\nif (!isNaN(zeFac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && faconoffcmd === 1) {\n    if ((zePac > 0) && (((zeFMinLoad - zeFThreshold) > zeFac) || ((zeFMinLoad + zeFThreshold) < zeFac)) && (zeIac < zeIacSetCmd)) {\n        //let delF = zeFMinLoad - zeFac ;\n        const ratedPcapacity = msg.ratedPcapacity\n        const ratedFrequency = msg.ratedFrequency\n        let delF = ratedFrequency - zeFac;\n        let zeFacOld = flow.get(\"zeFacOld\")\n        if (zeFacOld === undefined || isNaN(zeFacOld)) {\n            zeFacOld = 50;\n        }\n        oldPacLimit1 = flow.get(\"oldPacLimit1\")\n        if ((case1ZEF >= caseReset) && (zeFac != zeFacOld)) {\n            const pacLimitnew = (((zePac / 1000) + (((delF * ratedPcapacity) / (fDroopCmd * ratedFrequency)) * 100)) / inverterOnline)\n            //node.warn(`paclimit:${pacLimitnew}, zePac:${zePac} `) \n            pacLimit = (pacLimitnew * 1000)\n            oldPacLimit1 = pacLimit\n            node.warn(\"oldPacLimit1\" + oldPacLimit1)\n            zeFacOld = zeFac\n            case1ZEF = 0;\n            flow.set(\"zeFacOld\", zeFacOld)\n            flow.set(\"case1ZEF\", case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.1.0\"\n            const logMessageF = `4.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvF(logMessageF);\n        } else {\n            pacLimit = oldPacLimit1\n            case1ZEF++;\n            flow.set(\"case1ZEF\", case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.1.1 \"\n            const logMessageF = `4.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvF(logMessageF);\n        }\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n    } else if ((zeFMinLoad + zeFThreshold) == zeFac) {\n        flow.set(\"zeFacOld\", 50)\n        pacLimit = msg.facCapacityLimit * (blkPacMaxCmd)\n        case2ZEF++;\n        flow.set(\"case7ZEF\", case2ZEF);\n        msg.pacLimitMWrite = pacLimit * 10;\n        msg.case = \"4.5.0 \"\n        const logMessageF = `4.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n        logCsvF(logMessageF);\n    }\n}\n// -------------------------------------------------------Frequency Control End ----------------------------------------------------------------------------------\n// Save the pacLimit if it has been modified\nif (msg.pacLimitMWrite !== undefined) {\n    //node.warn(\"pacLimitMWrite was not set, setting default to Max limit\");\n    //msg.pacLimitMWrite = ..; // Setting a default value if none of the conditions met\n    //msg.case = \"Default Case: pacLimitMWrite was not set explicitly\";\n    global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n} else {\n    flow.set('P_integral', 0);\n    flow.set('P_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.pacLimitMWrite = 2772; // Setting a default value if none of the conditions met\n    global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n    flow.set('oldPacLimit1', msg.pacLimitMWrite / 10)\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\nlet actualQac\n// Save the qacLimit if it has been modified\nif (msg.qacLimitMWrite !== undefined) {\n    //actualQac = msg.qacLimitMWrite * inverterOnline;\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);\n} else {\n    flow.set('Q_integral', 0);\n    flow.set('Q_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacLimitMWrite = 0; // Setting a default value if none of the conditions met\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);\n    flow.set('oldQacLimit1', msg.qacLimitMWrite / 10)\n    msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\n/* if (msg.qacRefSelMWrite !== undefined) {\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n} else {\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacRefSelMWrite = 162; // Setting a default value if none of the conditions met\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n} */\n//node.warn(`Final pacLimitMWrite: ${msg.pacLimitMWrite}, Case: ${msg.case}`);\n//node.warn(`Final qacLimitMWrite: ${msg.qacLimitMWrite}, Case: ${msg.caseq}`);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 570,
        "y": 180,
        "wires": [
            [
                "1a6f114418073679"
            ]
        ]
    },
    {
        "id": "7233716fca04faac",
        "type": "function",
        "z": "f313dfa39a2c857c",
        "name": "PPC_Logic",
        "func": "const caseReset = 4; // Threshold for resetting cases\nconst caseResetP = 8;\n// Function for File handling\nconst fd = global.get('fs');\n// Function to rename CSV files\nfunction renameCsvFiles(filePath) {\n    const files = fd.readdirSync(filePath).filter(file => file.endsWith('.csv'));\n    files.forEach(file => {\n        const oldPath = path.join(filePath, file);\n        const newPath = path.join(filePath, `${file.slice(0, -4)}.unsent`);\n        fd.renameSync(oldPath, newPath);\n    });\n}\n// Function to get epoch time\nfunction getEpochTime() {\n    // Get the current time and round down to the nearest 300 seconds\n    const now = Math.floor(Date.now() / 1000); // Convert to seconds\n    return now - (now % 300); // Round down to the nearest 300 seconds\n}\n// Function to log PPC Active Power Logic CSV\nfunction logCsv(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_01.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Reactive Power Logic CSV\nfunction logCsvQ(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_02.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Power Factor Logic CSV\nfunction logCsvPF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_05.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Voltage Logic CSV\nfunction logCsvU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_03.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Q/U Logic CSV\nfunction logCsvQU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_07.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Frequency Logic CSV\nfunction logCsvF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_04.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Function to log PPC Ramp Logic CSV\nfunction logCsvR(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_06.csv`;\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n// Set last file pack time\nconst TS = getEpochTime();\nflow.set('lastFilePackTime', TS);\n// Rename CSV files if needed\nif (flow.get('lastFilePackTime') < TS) {\n    renameCsvFiles('/mnt/jffs2/dglog');\n    flow.set('lastFilePackTime', TS);\n}\n// UI Settings value for P Control\nlet pacMaxSetCmd = global.get(\"PAC_MAX_SET_RX\")\nif (pacMaxSetCmd === undefined || isNaN(pacMaxSetCmd)) {\n    pacMaxSetCmd = 2772;\n}\nlet blkPacMaxCmd = global.get(\"BLOCK_PAC_MAX_SET_RX\")\nif (blkPacMaxCmd === undefined || isNaN(blkPacMaxCmd)) {\n    blkPacMaxCmd = 27720;\n}\nlet pacLLSetCmd = global.get(\"PAC_CL_SET_RX\")\nif (pacLLSetCmd === undefined || isNaN(pacLLSetCmd)) {\n    pacLLSetCmd = 2;\n}\nlet pacULSetCmd = global.get(\"PAC_ULL_SET_RX\")\nif (pacULSetCmd === undefined || isNaN(pacULSetCmd)) {\n    pacULSetCmd = 1;\n}\nconst pacGRSetCmd = global.get(\"PAC_GR_SET_RX\")\nconst pacTuneStCmd = global.get(\"PAC_TUNE_ST_CONST_RX\")\nconst pacIncconstCmd = global.get(\"PAC_INCR_SET_RX\")\nconst pacDecconstCmd = global.get(\"PAC_DECR_CONST_RX\")\n// UI Settings value for Q Control\nlet qacMaxSetCmd = global.get(\"QAC_MAX_SET_RX\")\nif (qacMaxSetCmd === undefined || isNaN(qacMaxSetCmd)) {\n    qacMaxSetCmd = 1500;\n}\nlet blkQacMaxCmd = global.get(\"BLOCK_QAC_MAX_SET_RX\")\nif (blkQacMaxCmd === undefined || isNaN(blkQacMaxCmd)) {\n    blkQacMaxCmd = 15000;\n}\nlet qacLLSetCmd = global.get(\"QAC_CL_SET_RX\")\nif (qacLLSetCmd === undefined || isNaN(qacLLSetCmd)) {\n    qacLLSetCmd = 2;\n}\nlet qacULSetCmd = global.get(\"QAC_ULL_SET_RX\")\nif (qacULSetCmd === undefined || isNaN(qacULSetCmd)) {\n    qacULSetCmd = 1;\n}\nconst qacGRSetCmd = global.get(\"QAC_GR_SET_RX\")\nlet tuneStep = global.get(\"QAC_TUNE_ST_CONST_RX\")\nconst qacIncConstCmd = global.get(\"QAC_INCR_SET_RX\")\nconst qacDecConstCmd = global.get(\"QAC_DECR_CONST_RX\")\n// UI Settings value for SVG Control\nconst svgSlot1StartHour = global.get(\"SVG_SLOT1_START_HOUR_RX1\")\nconst svgSlot2StartHour = global.get(\"SVG_SLOT2_START_HOUR_RX1\")\nconst svgSlot3StartHour = global.get(\"SVG_SLOT3_START_HOUR_RX1\")\nconst svgSlot4StartHour = global.get(\"SVG_SLOT4_START_HOUR_RX1\")\nconst svgSlot1StartMin = global.get(\"SVG_SLOT1_START_MIN_RX1\")\nconst svgSlot2StartMin = global.get(\"SVG_SLOT2_START_MIN_RX1\")\nconst svgSlot3StartMin = global.get(\"SVG_SLOT3_START_MIN_RX1\")\nconst svgSlot4StartMin = global.get(\"SVG_SLOT4_START_MIN_RX1\")\nconst svgSlot1StopHour = global.get(\"SVG_SLOT1_STOP_HOUR_RX1\")\nconst svgSlot2StopHour = global.get(\"SVG_SLOT2_STOP_HOUR_RX1\")\nconst svgSlot3StopHour = global.get(\"SVG_SLOT3_STOP_HOUR_RX1\")\nconst svgSlot4StopHour = global.get(\"SVG_SLOT4_STOP_HOUR_RX1\")\nconst svgSlot1StopMin = global.get(\"SVG_SLOT1_STOP_MIN_RX1\")\nconst svgSlot2StopMin = global.get(\"SVG_SLOT2_STOP_MIN_RX1\")\nconst svgSlot3StopMin = global.get(\"SVG_SLOT3_STOP_MIN_RX1\")\nconst svgSlot4StopMin = global.get(\"SVG_SLOT4_STOP_MIN_RX1\")\n// UI Settings Value for PF Control\nlet pfLLSetCmd = global.get(\"PF_LL_SET_RX\")\nif (pfLLSetCmd === undefined || isNaN(pfLLSetCmd)) {\n    pfLLSetCmd = 0.004;\n}\nlet pfULSetcmd = global.get(\"PF_TH_SET_RX\")\nif (pfULSetcmd === undefined || isNaN(pfULSetcmd)) {\n    pfULSetcmd = 0.004;\n}\nlet pfGRSetCmd2 = global.get(\"PF_GR_SET_RX2\")\nif (pfGRSetCmd2 === undefined || isNaN(pfGRSetCmd2)) {\n    pfGRSetCmd2 = 10;\n}\nlet pfGRSetCmd = global.get(\"PF_GR_SET_RX\")\nif (pfGRSetCmd === undefined || isNaN(pfGRSetCmd)) {\n    pfGRSetCmd = 10;\n}\nlet pfDecConstCmd = global.get(\"PF_DECR_CONST_RX\")\nif (pfDecConstCmd === undefined || isNaN(pfDecConstCmd)) {\n    pfDecConstCmd = 20;\n}\nlet pfIncConstCmd = global.get(\"PF_INCR_SET_RX\")\nif (pfIncConstCmd === undefined || isNaN(pfIncConstCmd)) {\n    pfIncConstCmd = 20;\n}\n// UI Settings Value for UAC Control\nlet quULSetCmd = global.get(\"UAC_ULL_SET_RX\")\nif (quULSetCmd === undefined || isNaN(quULSetCmd)) {\n    quULSetCmd = 1;\n}\nlet quLLSetCmd = global.get(\"UAC_CL_SET_RX\")\nif (quLLSetCmd === undefined || isNaN(quLLSetCmd)) {\n    quLLSetCmd = 1;\n}\nlet quGRSetCmd = global.get(\"UAC_GR_SET_RX\")\nif (quGRSetCmd === undefined || isNaN(quGRSetCmd)) {\n    quGRSetCmd = 0;\n}\nlet quTuneStCmd = global.get(\"UAC_TUNE_ST_CONST_RX\")\nif (quTuneStCmd === undefined || isNaN(quTuneStCmd)) {\n    quTuneStCmd = 2;\n}\nlet quIncConstCmd = global.get(\"UAC_INCR_SET_RX\")\nif (quIncConstCmd === undefined || isNaN(quIncConstCmd)) {\n    quIncConstCmd = 4;\n}\nlet quDecConstCmd = global.get(\"UAC_DECR_CONST_RX\")\nif (quDecConstCmd === undefined || isNaN(quDecConstCmd)) {\n    quDecConstCmd = 4;\n}\n// UI Settings Value for FAC Control\nlet facDeadBand = msg.facDeadBand\nif (facDeadBand === undefined || isNaN(facDeadBand)) {\n    facDeadBand = 0;\n}\nlet facLLSetCmd = global.get(\"FAC_LL_SET_CMD\")\nif (facLLSetCmd === undefined || isNaN(facLLSetCmd)) {\n    facLLSetCmd = 0.3;\n}\nlet facCULSetCmd = global.get(\"FAC_CUL_SET_CMD\")\nif (facCULSetCmd === undefined || isNaN(facCULSetCmd)) {\n    facCULSetCmd = 2.0;\n}\nlet facCLLSetCmd = global.get(\"FAC_CLL_SET_CMD\")\nif (facCLLSetCmd === undefined || isNaN(facCLLSetCmd)) {\n    facCLLSetCmd = 2.5;\n}\nlet facGRSetCmd = global.get(\"FAC_GR_SET_CMD\")\nif (facGRSetCmd === undefined || isNaN(facGRSetCmd)) {\n    facGRSetCmd = 0;\n}\nlet facTuneStCmd = global.get(\"FAC_TUNE_ST_CONST_CMD\")\nif (facTuneStCmd === undefined || isNaN(facTuneStCmd)) {\n    facTuneStCmd = 100;\n}\nlet facIncConstCmd = global.get(\"FAC_INCR_CONST_CMD\")\nif (facIncConstCmd === undefined || isNaN(facIncConstCmd)) {\n    facIncConstCmd = 1;\n}\nlet facDecConstCmd = global.get(\"FAC_DECR_CONST_CMD\")\nif (facDecConstCmd === undefined || isNaN(facDecConstCmd)) {\n    facDecConstCmd = 1;\n}\nlet fDroopCmd = msg.facDroop\nif (fDroopCmd === undefined || isNaN(fDroopCmd)) {\n    fDroopCmd = 5;\n}\n// UI Settings Value for RAMP Control\nconst rampTuneStCmd = global.get(\"RAMP_TUNE_ST_CONST_RX\")\nconst rampIncconstCmd = global.get(\"RAMP_INCR_CONST_RX\")\nconst rampDecconstCmd = global.get(\"RAMP_DECR_CONST_RX\")\nconst rampOnOffCmd = msg.ramponoff\n// UI Settings Value for VRT Control\nconst lvrthvrtULSetCmd = global.get(\"LVRT_HVRT_ULL_SET_RX\")\nconst lvrthvrtLLSetCmd = global.get(\"LVRT_HVRT_CL_SET_RX\")\n// Setpoint & Simulation Value for P Control\nconst dev = msg.device\nconst pacOnOffCmd = msg.paconoff\nconst fonoffcmd = msg.fonoff\nconst powselcmd = msg.selpc\nconst zePac = msg.gridpac * 1000\nconst zePMinLoad = (msg.pacpc * 1000)\nconst inverterOnline = msg.inverterOnline\nconst inverterOnlineQ = msg.inverterOnlineQ\nlet PAC_LIMIT = msg.paclimit\nif (PAC_LIMIT === undefined || isNaN(PAC_LIMIT)) {\n    PAC_LIMIT = 2772;\n}\nconst zeIacMaxCmd = msg.maxcurrent\nconst zeIacSetCmd = msg.setcurrent\nconst zeIac = msg.gridiac\nconst pvPac = msg.invpac\nconst Kp = msg.kp\nconst Ti = msg.ti\nconst Kd = msg.kd\nlet Inv_Setpoint\nlet P_error\nlet P_integral = flow.get('P_integral') || 0;\nlet P_derivative\nlet P_previous_error = flow.get('P_previous_error') || 0;\nconst zeSac = global.get(\"CR.VR_EM.SAC\")\n// Setpoint & Simulation Value for Q Control\nconst qaconoffcmd = msg.qaconoff\nconst zeQac = msg.gridqac * 1000\nlet zeMinLoad = ((msg.qacpc * 1000))\nlet QAC_LIMIT = msg.qaclimit\nif (QAC_LIMIT === undefined || isNaN(QAC_LIMIT)) {\n    QAC_LIMIT = 0;\n}\nconst zePfSetCmd = msg.setpf\nconst zepfMaxLoad = msg.maxpf\nlet zePf = msg.gridpf\nzePf = parseFloat(zePf.toFixed(3));\nconst pvQac = msg.invqac\nconst Kpq = msg.kpq\nconst Tiq = msg.tiq\nconst Kdq = msg.kdq\nlet Inv_Qsetpoint\nlet Q_error\n//let Q_integral\nlet Q_integral = flow.get('Q_integral') || 0;\n//if (Q_integral === undefined || isNaN(Q_integral)) { Q_integral = 0; }\nlet Q_derivative\nlet Q_previous_error = flow.get('Q_previous_error') || 0;\nlet qacRefSel = msg.qacrefsel\n// Setpint Value for SVG Control\nconst svgonoffcmd = msg.svgonoff\nconst svgslot1pccmd = msg.svgslot1pc\nconst svgslot2pccmd = msg.svgslot2pc\nconst svgslot3pccmd = msg.svgslot3pc\n// Setpoint & Simulation Value for PF Control\nconst pfonoffcmd = msg.pfonoff\nconst zePFMinLoad = msg.pfpc\nconst zePFThreshold = pfULSetcmd\n// Setpoint & Simulation Value for U Control\nconst uaconoffcmd = msg.uaconoff\nconst zeUMinLoad = msg.uacpc\nconst zeUac = msg.griduac\n//let zeUThreshold = (zeUMinLoad * (msg.VDdroop / 100))\n//let zeUCriticalLoad = zeUMinLoad - ((quLLSetCmd / 100) * zeUMinLoad);\nlet qacMaxSet\nlet ratedQCapacity\nconst ratedvoltage = msg.Vrated\nconst droopPercentage = msg.Vdroop\n//const dbPercentage = msg.VDdroop\nconst droopDeadbandPercentage = msg.VDdroop\n// Setpoint & Simulation Value for Q/U Control\nconst quonoffcmd = msg.quonoff\n// Voltage Droop Calculation\nconst dbThreshold = (droopDeadbandPercentage * ratedvoltage) / 100\nconst droopThreshold = (droopPercentage * ratedvoltage) / 100\nconst deadBandMax = ratedvoltage + dbThreshold\nconst deadBandMin = ratedvoltage - dbThreshold\nconst droopMax = ratedvoltage + droopThreshold\nconst droopMin = ratedvoltage - droopThreshold\n// Setpoint & Simulation Value for VRT Control\nconst lvrtHvrtOnOffCmd = msg.lvrthvrtonoff\nconst zelvrthvrtCriticalLoad = (zeUMinLoad * (lvrthvrtULSetCmd / 100));\nconst zelvrthvrtThreshold = zeUMinLoad - ((lvrthvrtLLSetCmd / 100) * zeUMinLoad);\n// Setpoint & Simulation Value for F Control\nconst faconoffcmd = msg.faconoff\nconst zeFMinLoad = msg.facpc\nconst zeFac = msg.gridfac\nconst zeFCriticalLoad = facLLSetCmd\nconst zeFUCriticalLoad = facCULSetCmd\nconst zeFLCriticalLoad = facCLLSetCmd\nconst zeFThreshold = facDeadBand\nlet pacLimitdel\n// Initialize pacLimit and other variables\nlet maxPacLimit = ((PAC_LIMIT));\nflow.set(\"maxPacLimit\", maxPacLimit);\n//let oldPacLimit1 = flow.get('oldPacLimit1') || maxPacLimit;\nlet oldPacLimit1\nlet minPacLimit = maxPacLimit;\nconst invPacLimit = ((PAC_LIMIT)); // Assuming this comes from msg\nconst zePCriticalLoad = zePMinLoad - ((pacLLSetCmd / 100) * blkPacMaxCmd)\nconst zePThreshold = (pacULSetCmd / 100) * blkPacMaxCmd\n// Update max and min limits based on invPacLimit\nif (!isNaN(invPacLimit)) {\n    if (invPacLimit > maxPacLimit) maxPacLimit = invPacLimit;\n    if (invPacLimit < minPacLimit) minPacLimit = invPacLimit;\n}\nlet pacLimit = maxPacLimit;\n// Initialize qacLimit and other variables\nlet maxQacLimit = ((QAC_LIMIT) / qacMaxSetCmd) * 100;\nlet minQacLimit = maxQacLimit;\nlet oldQacLimit1\nconst invQacLimit = ((QAC_LIMIT) / qacMaxSetCmd) * 100; // Assuming this comes from msg\nlet zeCriticalLoad = zeMinLoad - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeThreshold = (qacULSetCmd / 100) * blkQacMaxCmd\n//SVG Variables\nconst zeSvgSlot1MinLoad = svgslot1pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot1CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nconst zeSvgSlot2MinLoad = svgslot2pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot2CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nconst zeSvgSlot3MinLoad = svgslot3pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot3CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\nlet qModeEnable\n// Update max and min limits based on invQacLimit\nif (!isNaN(invQacLimit)) {\n    if (invQacLimit > maxQacLimit) maxQacLimit = invQacLimit;\n    if (invQacLimit < minQacLimit) minQacLimit = invQacLimit;\n}\nlet qacLimit = (maxQacLimit * qacMaxSetCmd) / 100;\nqacLimit = parseFloat(qacLimit.toFixed(1));\n//let oldQacLimit = QAC_LIMIT / 10;\n//let qacLimitW = qacLimit;\n//let oldQacLimitW = qacLimit;\n//let pvQacW = qacLimit;\n//node.warn(`x:${maxQacLimit}`)\nmsg.pacLimitMWrite = undefined; // Initialize msg.pacLimitMWrite to undefined to identify if it remains unset\nmsg.qacLimitMWrite = undefined; // Initialize msg.qacLimitMWrite to undefined to identify if it remains unset\n// PPC P Control Casereset\nlet case1ZEP = flow.get('case1ZEP');\nif (case1ZEP === undefined || isNaN(case1ZEP)) {\n    case1ZEP = caseResetP;\n    flow.set(\"case1ZEP\", case1ZEP)\n}\nlet case2ZEP = flow.get('case2ZEP');\nif (case2ZEP === undefined || isNaN(case2ZEP)) {\n    case2ZEP = caseResetP;\n    flow.set(\"case2ZEP\", case2ZEP);\n}\nlet case3ZEP = flow.get('case3ZEP');\nif (case3ZEP === undefined || isNaN(case3ZEP)) {\n    case3ZEP = caseResetP;\n    flow.set(\"case3ZEP\", case3ZEP);\n}\nlet case4ZEP = flow.get('case4ZEP');\nif (case4ZEP === undefined || isNaN(case4ZEP)) {\n    case4ZEP = caseResetP;\n    flow.set(\"case4ZEP\", case4ZEP);\n}\nlet case5ZEP = flow.get('case5ZEP');\nif (case5ZEP === undefined || isNaN(case5ZEP)) {\n    case5ZEP = caseResetP;\n    flow.set(\"case5ZEP\", case5ZEP);\n}\n// PPC Q Control Casereset\nlet case1ZEQ = flow.get('case1ZEQ');\nif (case1ZEQ === undefined || isNaN(case1ZEQ)) {\n    case1ZEQ = caseReset;\n    flow.set(\"case1ZEQ\", case1ZEQ);\n}\nlet case2ZEQ = flow.get('case2ZEQ');\nif (case2ZEQ === undefined || isNaN(case2ZEQ)) {\n    case2ZEQ = caseReset;\n    flow.set(\"case2ZEQ\", case2ZEQ);\n}\nlet case3ZEQ = flow.get('case3ZEQ');\nif (case3ZEQ === undefined || isNaN(case3ZEQ)) {\n    case3ZEQ = caseReset;\n    flow.set(\"case3ZEQ\", case3ZEQ);\n}\nlet case4ZEQ = flow.get('case4ZEQ');\nif (case4ZEQ === undefined || isNaN(case4ZEQ)) {\n    case4ZEQ = caseReset;\n    flow.set(\"case4ZEQ\", case4ZEQ);\n}\nlet case5ZEQ = flow.get('case5ZEQ');\nif (case5ZEQ === undefined || isNaN(case5ZEQ)) {\n    case5ZEQ = caseReset;\n    flow.set(\"case5ZEQ\", case5ZEQ);\n}\n// PPC PF Control Casereset\nlet case1ZEPF = flow.get('case1ZEPF');\nif (case1ZEPF === undefined || isNaN(case1ZEPF)) {\n    case1ZEPF = caseReset;\n    flow.set(\"case1ZEPF\", case1ZEPF);\n}\nlet case2ZEPF = flow.get('case2ZEPF');\nif (case2ZEPF === undefined || isNaN(case2ZEPF)) {\n    case2ZEPF = caseReset;\n    flow.set(\"case2ZEPF\", case2ZEPF);\n}\nlet case3ZEPF = flow.get('case3ZEPF');\nif (case3ZEPF === undefined || isNaN(case3ZEPF)) {\n    case3ZEPF = caseReset;\n    flow.set(\"case3ZEPF\", case3ZEPF);\n}\nlet case4ZEPF = flow.get('case4ZEPF');\nif (case4ZEPF === undefined || isNaN(case4ZEPF)) {\n    case4ZEPF = caseReset;\n    flow.set(\"case4ZEPF\", case4ZEPF);\n}\nlet case5ZEPF = flow.get('case5ZEPF');\nif (case5ZEPF === undefined || isNaN(case5ZEPF)) {\n    case5ZEPF = caseReset;\n    flow.set(\"case5ZEPF\", case5ZEPF);\n}\n// PPC U Control Casereset\nlet case1ZEU = flow.get('case1ZEU');\nif (case1ZEU === undefined || isNaN(case1ZEU)) {\n    case1ZEU = caseReset;\n    flow.set(\"case1ZEU\", case1ZEU);\n}\nlet case2ZEU = flow.get('case2ZEU');\nif (case2ZEU === undefined || isNaN(case2ZEU)) {\n    case2ZEU = caseReset;\n    flow.set(\"case2ZEU\", case2ZEU);\n}\nlet case3ZEU = flow.get('case3ZEU');\nif (case3ZEU === undefined || isNaN(case3ZEU)) {\n    case3ZEU = caseReset;\n    flow.set(\"case3ZEU\", case3ZEU);\n}\nlet case4ZEU = flow.get('case4ZEU');\nif (case4ZEU === undefined || isNaN(case4ZEU)) {\n    case4ZEU = caseReset;\n    flow.set(\"case4ZEU\", case4ZEU);\n}\nlet case5ZEU = flow.get('case5ZEU');\nif (case5ZEU === undefined || isNaN(case5ZEU)) {\n    case5ZEU = caseReset;\n    flow.set(\"case5ZEU\", case5ZEU);\n}\nlet case6ZEU = flow.get('case6ZEU');\nif (case6ZEU === undefined || isNaN(case6ZEU)) {\n    case6ZEU = caseReset;\n    flow.set(\"case6ZEU\", case6ZEU);\n}\n// PPC F Control Casereset\nlet case1ZEF = flow.get('case1ZEF');\nif (case1ZEF === undefined || isNaN(case1ZEF)) {\n    case1ZEF = caseReset;\n    flow.set(\"case1ZEF\", case1ZEF);\n}\nlet case2ZEF = flow.get('case2ZEF');\nif (case2ZEF === undefined || isNaN(case2ZEF)) {\n    case2ZEF = caseReset;\n    flow.set(\"case2ZEF\", case2ZEF);\n}\nlet case3ZEF = flow.get('case3ZEF');\nif (case3ZEF === undefined || isNaN(case3ZEF)) {\n    case3ZEF = caseReset;\n    flow.set(\"case3ZEF\", case3ZEF);\n}\nlet case4ZEF = flow.get('case4ZEF');\nif (case4ZEF === undefined || isNaN(case4ZEF)) {\n    case4ZEF = caseReset;\n    flow.set(\"case4ZEF\", case4ZEF);\n}\nlet case5ZEF = flow.get('case5ZEF');\nif (case5ZEF === undefined || isNaN(case5ZEF)) {\n    case5ZEF = caseReset;\n    flow.set(\"case5ZEF\", case5ZEF);\n}\n\n// ------------------------------- Open Loop Logic Start ---------------------------------------------\nlet OLpacLimit = msg.openplimit\nlet OLqacLimit = msg.openqlimit\nif (powselcmd == 0) {\n    if ((OLpacLimit != undefined || !isNaN(OLpacLimit))) {\n        msg.pacLimitMWrite = OLpacLimit;\n        msg.case = \"Case 0: PACLIMIT has given from User\";\n    }\n    if ((qacRefSel != undefined || !isNaN(qacRefSel))) {\n        msg.qacRefSelMWrite = global.get(\"QAC_REF_SEL_RX\")\n    }\n    if ((OLqacLimit != undefined && !isNaN(OLqacLimit))) {\n        msg.qacLimitMWrite = OLqacLimit;\n        msg.caseq = \"Case 0: QACLIMIT has given from User\";\n    } else {\n        msg.qacLimitMWrite = 0\n        msg.caseq = \"Case 0: QACLIMIT has given from UI\";\n    }\n}\n// ---------------------------------- Open Loop Logic Stop ----------------------------------------------------\n// ---------------------------------- QAC Sel Mode Start----------------------------------------------------\nif (powselcmd == 1) {\n    if ((qacRefSel != undefined || !isNaN(qacRefSel || qacRefSel != 162))) {\n        msg.qacRefSelMWrite = 162\n    }\n}\n// ---------------------------------- QAC Sel Mode End --------------------------------------------------------\n// ---------------------------------------- Active Power Control Logic Start -------------------------------------------------------\n//node.warn(`zePac: ${zePac}, fonoffcmd: ${fonoffcmd}`);\nif (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && pacOnOffCmd == 1 && faconoffcmd == 0) {\n    const prevPMinLoad = flow.get(\"prev_zeminP\");\n    const Diff_old = flow.get(\"Diff_old\");\n    let Diff_New\n    let PPID\n    if (zePMinLoad !== prevPMinLoad) {\n        // Value changed  calculate and save\n        Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminP\", zePMinLoad);\n        flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"P_integral\", 0);\n        flow.set(\"P_previous_error\", 0);\n        flow.set(\"case1ZEP\", 1);\n        flow.set(\"case2ZEP\", 1);\n        oldPacLimit1 = pacLimit;\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n    } else {\n        Diff_New = Diff_old\n        oldPacLimit1 = flow.get(\"oldPacLimit1\");\n    }\n    P_integral = flow.get(\"P_integral\")\n    P_previous_error = flow.get(\"P_previous_error\")\n    P_error = flow.get(\"P_error\")\n    P_derivative = flow.get(\"P_derivative\")\n    PPID = flow.get(\"PID\")\n    Inv_Setpoint = flow.get(\"Inv_Setpoint\")\n    case1ZEP = flow.get(\"case1ZEP\")\n    case2ZEP = flow.get(\"case2ZEP\")\n    const Kp = 0.4\n    const Ti = 15\n    const Kd = 0.01\n    flow.set(\"Kp\", Kp)\n    flow.set(\"Ti\", Ti)\n    flow.set(\"Kd\", Kd)\n    if (zePac >= (zePMinLoad + zePThreshold) && (zeIac < zeIacSetCmd) && (maxPacLimit <= pacMaxSetCmd)) {\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n        //node.warn(pacLimit)\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        if (case1ZEP >= caseResetP) {\n            Inv_Setpoint = zePMinLoad;\n            P_error = zePac - Inv_Setpoint;\n            P_integral = P_integral + (P_error * 0.1);\n            P_derivative = (P_error - P_previous_error) / 0.1\n            P_previous_error = P_error\n            P_error = parseFloat(P_error.toFixed(1));\n            P_integral = parseFloat(P_integral.toFixed(1));\n            P_derivative = parseFloat(P_derivative.toFixed(1));\n            P_previous_error = parseFloat(P_previous_error.toFixed(1));\n            //node.warn(`pvPac: ${pvPac}`);\n            // pacLimit = (((pvPac) - (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))) / inverterOnline)\n            pacLimit = (((pvPac) - (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)))) / inverterOnline)\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            case1ZEP = 0;\n            flow.set('case1ZEP', case1ZEP);\n             if (pacLimit > oldPacLimit1) { pacLimit = oldPacLimit1 - (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)) / inverterOnline) }\n            //if (pacLimit > oldPacLimit1) { pacLimit = oldPacLimit1 }\n            //if (Inv_Setpoint < (pacLimit * inverterOnline)) { pacLimit = oldPacLimit1 }\n            if (pacLimit <= 10) pacLimit = 10;\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            PPID = (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))\n            oldPacLimit1 = pacLimit;\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.1.0 force down\";\n            const logMessage = `1.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        } else {\n            // Increment case1ZEP and set flow context\n            case1ZEP++;\n            flow.set('case1ZEP', case1ZEP);\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.1.1 force down\";\n            const logMessage = `1.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n        flow.set(\"P_integral\", P_integral);\n        flow.set(\"P_previous_error\", P_previous_error);\n        flow.set(\"P_error\", P_error);\n        flow.set(\"P_derivative\", P_derivative);\n        flow.set(\"PPID\", PPID);\n        flow.set(\"Inv_Setpoint\", Inv_Setpoint);\n    }\n    // Case 2: < critical load\n    else if ((zePac <= zePMinLoad - zePThreshold) && zeIac < zeIacSetCmd && (maxPacLimit < pacMaxSetCmd)) {\n        // Set 'pacLimit' to 'oldPacLimit1' initially\n        pacLimit = oldPacLimit1;\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        if (case2ZEP >= caseResetP) {\n            Inv_Setpoint = zePMinLoad;\n            P_error = Inv_Setpoint - (zePac);\n            P_integral = P_integral + (P_error * 0.1);\n            P_derivative = (P_error - P_previous_error) / 0.1\n            P_previous_error = P_error\n            P_error = parseFloat(P_error.toFixed(1));\n            P_integral = parseFloat(P_integral.toFixed(1));\n            P_derivative = parseFloat(P_derivative.toFixed(1));\n            P_previous_error = parseFloat(P_previous_error.toFixed(1));\n            // pacLimit = (((pvPac) + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))) / inverterOnline)\n            pacLimit = (((pvPac) + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)))) / inverterOnline)\n            // node.warn(`invpac1: ${oldPacLimit1}`);\n            if (pacLimit < oldPacLimit1) { pacLimit = oldPacLimit1 + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_previous_error)) / inverterOnline) }\n           // if (pacLimit < oldPacLimit1) { pacLimit = oldPacLimit1 }\n            //if (Inv_Setpoint < pacLimit * inverterOnline) { pacLimit = oldPacLimit1 }\n            if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            PPID = (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))\n            oldPacLimit1 = pacLimit\n            case2ZEP = 0;\n            flow.set('case2ZEP', case2ZEP);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.2.0 force UP\";\n            const logMessage = `1.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        } else {\n            // Increment case2ZEP if caseReset is not reached\n            case2ZEP++;\n            flow.set('case2ZEP', case2ZEP);\n            if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.2.1 force UP\";\n            const logMessage = `1.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${Kp},${P_error},${Ti},${P_integral},${Kd},${P_derivative},${PPID},${pacLimit},${Inv_Setpoint},${oldPacLimit1},`;\n            logCsv(logMessage);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n        flow.set(\"P_integral\", P_integral);\n        flow.set(\"P_previous_error\", P_previous_error);\n        flow.set(\"P_error\", P_error);\n        flow.set(\"P_derivative\", P_derivative);\n        flow.set(\"PPID\", PPID);\n        flow.set(\"Inv_Setpoint\", Inv_Setpoint);\n    }\n    // Case 3:  > Critical  & < lower ---tune up\n    // Case 4: ZEP meter > 0 & ZEP meter < minload no change\n    else if (zeIac >= zeIacSetCmd && maxPacLimit < pacMaxSetCmd) {\n        if (zeIac > zeIacMaxCmd) {\n            let pacLimit = maxPacLimit - (pacTuneStCmd * pacMaxSetCmd / 1000);\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            if (case4ZEP >= caseResetP) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.0 current\"\n                const logMessage = `1.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.1 current\"\n                const logMessage = `1.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            }\n        } else {\n            pacLimit = pacLimit\n            if (case4ZEP >= caseResetP) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 10) pacLimit = 10;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.2 current\"\n                const logMessage = `1.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.3 current\"\n                const logMessage = `1.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsv(logMessage);\n            }\n        }\n    }\n    // Case 5: Stable\n    // else if ((zePac <= zePMinLoad + zePThreshold && zePac >= zePMinLoad - zePThreshold || maxPacLimit <= pacMaxSetCmd )&& zeIac < zeIacSetCmd) {\n    else {\n        pacLimit = oldPacLimit1;\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        oldPacLimit1 = parseFloat(oldPacLimit1.toFixed(1));\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"P_integral\", 0);\n        flow.set(\"P_previous_error\", 0);\n        flow.set(\"case1ZEP\", 1);\n        flow.set(\"case2ZEP\", 1);\n        if (case5ZEP >= caseResetP) {\n            case5ZEP = 0;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"1.5.0 stable\"\n            const logMessage = `1.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        } else {\n            case5ZEP++;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 10) pacLimit = 10;\n            msg.pacLimitMWrite = pacLimit ;\n            msg.case = \"1.5.1 stable\"\n            const logMessage = `1.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsv(logMessage);\n        }\n    }\n}\n// ------------------------------------------ Active Power Control Logic End -------------------------------------------------------------------------------\n// ------------------------------------------ Reactive Power Control Logic Start ----------------------------------------------------------------------------\n//node.warn(`zeQac: ${zeQac}, qaconoffcmd: ${qaconoffcmd}`);\nif (!isNaN(zeQac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && (qaconoffcmd == 1 || svgonoffcmd == 1)) {\n    const now = new Date();\n    const min = now.getMinutes();\n    const hour = now.getHours();\n    //node.warn(`1:${zeQac}, 2:${powselcmd}, 3: ${inverterOnline}, , 4: ${fonoffcmd},5: ${qaconoffcmd}, 6: ${inverterOnline }`)\n    // Select the setpoint based on Slots\n    if (qaconoffcmd == 1 && svgonoffcmd == 1) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            zeCriticalLoad = zeSvgSlot1CriticalLoad;\n            zeMinLoad = zeSvgSlot1MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            zeCriticalLoad = zeSvgSlot2CriticalLoad;\n            zeMinLoad = zeSvgSlot2MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            zeCriticalLoad = zeSvgSlot3CriticalLoad;\n            zeMinLoad = zeSvgSlot3MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            zeCriticalLoad = zeCriticalLoad;\n            zeMinLoad = zeMinLoad;\n            qModeEnable = 1;\n        }\n    }\n    if (qaconoffcmd == 0 && svgonoffcmd == 1) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            zeCriticalLoad = zeSvgSlot1CriticalLoad;\n            zeMinLoad = zeSvgSlot1MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            zeCriticalLoad = zeSvgSlot2CriticalLoad;\n            zeMinLoad = zeSvgSlot2MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            zeCriticalLoad = zeSvgSlot3CriticalLoad;\n            zeMinLoad = zeSvgSlot3MinLoad;\n            qModeEnable = 1;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            qModeEnable = 0;\n        }\n    }\n    if (qaconoffcmd == 1 && svgonoffcmd == 0) {\n        if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n            qModeEnable = 0;\n        }\n        if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n            zeCriticalLoad = zeCriticalLoad;\n            zeMinLoad = zeMinLoad;\n            qModeEnable = 1;\n        }\n    }\n    //node.warn(`svg_status,${hour}`)\n    //node.warn(`setpoint,${svgSlot4StartHour}`)\n    const prevQMinLoad = flow.get(\"prev_zeminQ\");\n    if (zeMinLoad !== prevQMinLoad) {\n        // Value changed  calculate and save\n        //Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminQ\", zeMinLoad);\n        //flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEQ\", 1);\n        flow.set(\"case2ZEQ\", 1);\n        oldQacLimit1 = qacLimit;\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n    } else {\n        oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    }\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    case1ZEQ = flow.get(\"case1ZEQ\")\n    case2ZEQ = flow.get(\"case2ZEQ\")\n    // Case 1: ZE meter < critical load (100VAR); Reactive Power supply to grid  && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    if (zeQac <= (zeMinLoad - zeThreshold) && (maxQacLimit >= -100) && (minQacLimit <= 100)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        if (case1ZEQ >= caseReset) {\n            Inv_Qsetpoint = zeMinLoad\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            //node.warn(`Qerrorcase1: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} , qacLimit: ${(qacLimit)}  `)\n            // if (qacLimit > -12 && qacLimit < 12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEQ = 0;\n            flow.set('case1ZEQ', case1ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.1.0\";\n            const logMessageQ = `2.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case1ZEQ++;\n            flow.set('case1ZEQ', case1ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.1.1\";\n            const logMessageQ = `2.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n        flow.set(\"Q_integral\", Q_integral);\n        flow.set(\"Q_previous_error\", Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n        //node.warn(`Qerrorcase1final: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} , qacLimit: ${(qacLimit)}  `)\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if ((zeQac >= (zeMinLoad + zeThreshold)) && (maxQacLimit >= -100) && (minQacLimit <= 100)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        if (case2ZEQ >= caseReset) {\n            Inv_Qsetpoint = zeMinLoad\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            // if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEQ = 0;\n            flow.set('case2ZEQ', case2ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.2.0\";\n            const logMessageQ = `2.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case2ZEQ++;\n            flow.set('case2ZEQ', case2ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.2.1\";\n            const logMessageQ = `2.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n        flow.set(\"Q_integral\", Q_integral);\n        flow.set(\"Q_previous_error\", Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n        //node.warn(`Qerrorcase2: ${(Q_error)}, Q_integral: ${(Q_integral)}, Q_derivative: ${(Q_derivative)} `)\n    }\n    //case 5   && qModeEnable === 1\n    else if ((zeQac <= (zeMinLoad + zeThreshold)) && (zeQac >= (zeMinLoad - zeThreshold))) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEQ\", 1);\n        flow.set(\"case2ZEQ\", 1);\n        if (case5ZEQ >= caseReset) {\n            case5ZEQ = 0;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.0 stable\"\n            const logMessageQ = `2.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case5ZEQ++;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"2.5.1 stable\"\n            const logMessageQ = `2.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvQ(logMessageQ);\n        }\n    }\n}\n// --------------------------------------------------------- Reactive Power Control Logic End ----------------------------------------------------------------------\n// --------------------------------------------------------- Power Factor Control Logic Start ---------------------------------------------------------------------- */\nif (!isNaN(zePf) && powselcmd === 1 && inverterOnlineQ > 0 && fonoffcmd === 1 && pfonoffcmd === 1) {\n    //node.warn(`Final qacLimitMWrite: ${(maxQacLimit1)}, Case: ${zePFMinLoad + zePFThreshold}`)\n    const prevPFMinLoad = flow.get(\"prev_zeminPF\");\n    if (zePFMinLoad !== prevPFMinLoad) {\n        // Value changed  calculate and save\n        //Diff_New = Math.abs(zePac - zePMinLoad);\n        flow.set(\"prev_zeminPF\", zePFMinLoad);\n        //flow.set(\"Diff_old\", Diff_New);\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        flow.set(\"case1ZEPF\", 1);\n        flow.set(\"case2ZEPF\", 1);\n        flow.set(\"case3ZEPF\", 1);\n        flow.set(\"case4ZEPF\", 1);\n        oldQacLimit1 = qacLimit;\n        flow.set(\"oldQacLimit1\", oldQacLimit1);\n    } else {\n        oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    }\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    case1ZEPF = flow.get(\"case1ZEPF\")\n    case2ZEPF = flow.get(\"case2ZEPF\")\n    case3ZEPF = flow.get(\"case3ZEPF\")\n    case4ZEPF = flow.get(\"case4ZEPF\")\n    //case1: 1st Quadrant Operation with Actual PF (+ve) is less than Setpoint so need to reduce the Reactive Power Supply or Abosrb from Grid and limit should go from 100% to -100%\n    if (zePf < (zePFMinLoad - zePFThreshold) && (zePac > 180) && zePFMinLoad > 0 && zePf > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`x:${zePFMinLoadnew}`)\n        if (case1ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.1.0\";\n            const logMessagePF = `5.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.1.1\";\n            const logMessagePF = `5.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//case2: Runs Only when Actual is -ve PF and Set is +ve PF for short time when P>0 \n    else if (zePf < (zePFMinLoad - zePFThreshold) && (zePac > 180) && zePf <= 1 && zePFMinLoad > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`y:${zePFMinLoadnew}`)\n        if (case1ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case1ZEPF = 0;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.7.0\";\n            const logMessagePF = `5.7.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case1ZEPF++;\n            flow.set('case1ZEPF', case1ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.7.1\";\n            const logMessagePF = `5.7.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    } //Case 3: Runs Only when Actual is -ve PF and Set is +ve PF for short time when P<0\n    else if (zePf < (zePFMinLoad + zePFThreshold) && (zePac < 0) && zePf <= 1 && zePFMinLoad > 0 && minQacLimit > -101 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`z:${zePFMinLoadnew}`)\n        if (case2ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.6.0\";\n            const logMessagePF = `5.6.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.6.1\";\n            const logMessagePF = `5.6.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Maximum Demand Penalty Avoidance Case during Night Time or Improt conditions \n    else if (zeSac >= 1400 && zePac < 0) {\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit * 10;\n        msg.caseq = \"5.9.0\";\n        const logMessagePF = `5.9.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }//If there is not Much Active Power / DC available the Make Q Command as Zero to not force the Inverter.\n    else if (zePac <= 180 && zePac >= 0) {\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        qacLimit = 0\n        msg.qacLimitMWrite = qacLimit * 10;\n        msg.caseq = \"5.9.1\";\n        const logMessagePF = `5.9.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n        logCsvPF(logMessagePF);\n    }//Case4: Setpoint is less than PF actual and also PF setpoint is +ve and so Need to Delivery or Supply more Q to grid; Limits goes to -100 to + 100\n    else if (((zePf > (zePFThreshold + zePFMinLoad))) && zePf >= -1 && zePFMinLoad > 0 && minQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`a:${zePFMinLoadnew}`)\n        if (case2ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case2ZEPF = 0;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.2.0\";\n            const logMessagePF = `5.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case2ZEPF++;\n            flow.set('case2ZEPF', case2ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.2.1\";\n            const logMessagePF = `5.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 5: Actual PF & PF Setpoints are -ve and Actual PF is > Setpoint and so reduce the Q Consumption; Limit goes from -100 to + 100\n    else if (zePf > (zePFThreshold + zePFMinLoad) && zePFMinLoad < 0 && zePf < 0 && maxQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad + zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad + zePFThreshold) * (zePFMinLoad + zePFThreshold)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`b:${zePFMinLoadnew}`)\n        if (case3ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case3ZEPF = 0;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.3.0\";\n            const logMessagePF = `5.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case3ZEPF++;\n            flow.set('case3ZEPF', case3ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.3.1\";\n            const logMessagePF = `5.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 6: Set Point is -ve PF and Actual is +ve PF and so limit should do from +100 to -100\n    else if ((zePf < zePFMinLoad || zePf >= ((-zePFThreshold) - (zePFMinLoad))) && (zePFMinLoad < 0) && (zePf >= -1) && (maxQacLimit < 100) && (minQacLimit > -101)) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold + zePFMinLoad) * (zePFThreshold + zePFMinLoad)));\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        node.warn(`c:${zePFMinLoadnew}`)\n        //node.warn(`(1:${((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)) })`)\n        if (case4ZEPF >= caseReset) {\n            Inv_Qsetpoint = zePFMinLoadnew\n            Q_error = Inv_Qsetpoint - zeQac\n            Q_integral = Q_integral + (Q_error * 0.1)\n            Q_derivative = (Q_error - Q_previous_error) / 0.1\n            Q_previous_error = Q_error\n            qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnlineQ)\n            if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            oldQacLimit1 = qacLimit\n            case4ZEPF = 0;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.4.0\";\n            const logMessagePF = `5.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case4ZEPF++;\n            flow.set('case4ZEPF', case4ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.4.1\";\n            const logMessagePF = `5.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${Q_error},${Q_integral},${Q_derivative},${QPID},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n        // Store the updated 'oldPacLimit1' in the flow context\n        flow.set('oldQacLimit1', oldQacLimit1);\n        flow.set('Q_integral', Q_integral);\n        flow.set('Q_previous_error', Q_previous_error);\n        flow.set(\"Q_error\", Q_error);\n        flow.set(\"Q_derivative\", Q_derivative);\n        flow.set(\"QPID\", QPID);\n    }//Case 7: Stable Case \n    else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set('Q_integral', 0);\n        flow.set('Q_previous_error', 0);\n        if (case5ZEPF >= caseReset) {\n            case5ZEPF = 0;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.5.0\"\n            const logMessagePF = `5.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case5ZEPF++;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"5.5.1\"\n            const logMessagePF = `5.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvPF(logMessagePF);\n        }\n    }\n}\n// ------------------------------------------------------ Power Factor Logic End -----------------------------------------------------------------------------\n// ------------------------------------------------------ Voltage Control Logic Start -------------------------------------------------------------------------\nif (!isNaN(zeUac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && (uaconoffcmd === 1 || lvrtHvrtOnOffCmd === 1)) {\n    ratedQCapacity = msg.ratedPcapacity * 0.33\n    oldQacLimit1 = flow.get(\"oldQacLimit1\");\n    qacLimit = oldQacLimit1\n    Q_integral = flow.get(\"Q_integral\")\n    Q_previous_error = flow.get(\"Q_previous_error\")\n    Q_error = flow.get(\"Q_error\")\n    Q_derivative = flow.get(\"Q_derivative\")\n    let QPID = flow.get(\"PID\")\n    //node.warn(`deadBandMax: ${zeUac}, droopMax: ${droopMax}`);\n    //node.warn(`deadBandMin: ${deadBandMin}, droopMin: ${droopMin}`);\n    //let zeUacold = flow.get(\"zeUacold\")\n    //if (zeUacold === undefined || isNaN(zeUacold)) { zeUacold = 132; }\n    if ((zeUac > (deadBandMax)) && (zeUac <= droopMax)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMax) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n        if ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold) || ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold))))) {\n            if (case1ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},Q_act:${zeQac},Q_CMD:${qacLimit}`)\n                if (zeQac > (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case1ZEU = 0;\n                flow.set(\"case1ZEU\", case1ZEU);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"3.1.0\"\n                const logMessageU = `3.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case1ZEU++;\n                flow.set(\"case1ZEU\", case1ZEU);\n                msg.qacLimitMWrite = oldQacLimit1;\n                msg.caseq = \"3.1.1\"\n                const logMessageU = `3.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.1.5\"\n            const logMessageU = `3.1.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR   && qModeEnable === 1  && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd))\n    else if (zeUac < (deadBandMin) && zeUac >= droopMin) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMin) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100)))\n        if ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold) || ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold))))) {\n            //node.warn(`zeThreshold:${((Inv_Qsetpoint*1000) - zeThreshold)},Q_error:${((Inv_Qsetpoint*1000) + zeThreshold)}`)\n            if (case2ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},zeQaC:${zeQac}`)\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                if (zeQac > (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < (Inv_Qsetpoint * 1000)) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case2ZEU = 0;\n                flow.set(\"case2ZEU\", case2ZEU);\n                msg.qacLimitMWrite = qacLimit;\n                msg.caseq = \"3.2.0\"\n                const logMessageU = `3.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case2ZEU++;\n                flow.set(\"case2ZEU\", case2ZEU);\n                msg.qacLimitMWrite = qacLimit ;\n                msg.caseq = \"3.2.1\"\n                const logMessageU = `3.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit ;\n            msg.caseq = \"3.2.5\"\n            const logMessageU = `3.2.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    // case 3 \n    /*else if ((zePac > 0) && (zeUac >= deadBandMin) && (zeUac <= deadBandMax)) {\n        if (zePac > 0 && uaconoffcmd === 1) {\n            qacMaxSet = 0\n            qacLimit = qacMaxSet * 1000\n            oldQacLimit1 = qacLimit\n            if (case3ZEU >= caseReset) {\n                case3ZEU = 0;\n                flow.set(\"oldQacLimit1\", oldQacLimit1);\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.0\"\n                const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case3ZEU++;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit * 10;\n                msg.caseq = \"3.3.1\"\n                const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n        }\n    }*/\n    else if ((zePac > 0) && (zeUac >= deadBandMin) && (zeUac <= deadBandMax)) {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        Inv_Qsetpoint = ((zeUac - deadBandMin) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100))) * 0\n        if ((zeQac <= ((Inv_Qsetpoint * 1000) - zeThreshold) || ((zeQac >= ((Inv_Qsetpoint * 1000) + zeThreshold))))) {\n            //node.warn(`zeThreshold:${((Inv_Qsetpoint*1000) - zeThreshold)},Q_error:${((Inv_Qsetpoint*1000) + zeThreshold)}`)\n            if (case3ZEU >= caseReset) {\n                Q_error = (Inv_Qsetpoint * 1000) - zeQac\n                node.warn(`Inv_Qsetpoint:${Inv_Qsetpoint},Q_error:${Q_error},zeQaC:${zeQac}`)\n                Q_integral = Q_integral + (Q_error * 0.1)\n                Q_derivative = (Q_error - Q_previous_error) / 0.1\n                Q_previous_error = Q_error\n                qacLimit = (((pvQac) + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))) / inverterOnline)\n                if (zeQac > 0) {\n                    if (qacLimit < 12 && qacLimit > -12) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit > oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                else if (zeQac < 0) {\n                    if (qacLimit < 12 && qacLimit > 0) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                    if (qacLimit < oldQacLimit1) { qacLimit = oldQacLimit1 + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)) / inverterOnlineQ) }\n                }\n                if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n                if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n                QPID = ((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative))\n                qacLimit = parseFloat(qacLimit.toFixed(1));\n                oldQacLimit1 = qacLimit\n                case3ZEU = 0;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit ;\n                msg.caseq = \"3.3.0\"\n                const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            } else {\n                case3ZEU++;\n                flow.set(\"case3ZEU\", case3ZEU);\n                msg.qacLimitMWrite = qacLimit ;\n                msg.caseq = \"3.3.1\"\n                const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n                logCsvU(logMessageU);\n            }\n            // Store the updated 'oldPacLimit1' in the flow context\n            flow.set(\"oldQacLimit1\", oldQacLimit1);\n            flow.set(\"Q_integral\", Q_integral);\n            flow.set(\"Q_previous_error\", Q_previous_error);\n            flow.set(\"Q_error\", Q_error);\n            flow.set(\"Q_derivative\", Q_derivative);\n            flow.set(\"QPID\", QPID);\n        } else {\n            qacLimit = oldQacLimit1\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            flow.set(\"Q_integral\", 0);\n            flow.set(\"Q_previous_error\", 0);\n            case5ZEU++;\n            flow.set(\"case5ZEU\", case5ZEU);\n            msg.qacLimitMWrite = qacLimit;\n            msg.caseq = \"3.3.5\"\n            const logMessageU = `3.3.5,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvU(logMessageU);\n        }\n    }\n    //case 4\n    // case 5 \n    else {\n        qacLimit = oldQacLimit1\n        qacLimit = parseFloat(qacLimit.toFixed(1));\n        flow.set(\"Q_integral\", 0);\n        flow.set(\"Q_previous_error\", 0);\n        case5ZEU++;\n        flow.set(\"case5ZEU\", case5ZEU);\n        msg.qacLimitMWrite = qacLimit;\n        msg.caseq = \"3.5.0\"\n        const logMessageU = `3.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n        logCsvU(logMessageU);\n    }\n}\n// ------------------------------------------------------- Voltage Control Logic End -----------------------------------------------------------------------------------\n// ------------------------------- Frequency COntrol Start --------------------------------------------------\nif (!isNaN(zeFac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && faconoffcmd === 1) {\n    if ((zePac > 0) && (((zeFMinLoad - zeFThreshold) > zeFac) || ((zeFMinLoad + zeFThreshold) < zeFac)) && (zeIac < zeIacSetCmd)) {\n        //let delF = zeFMinLoad - zeFac ;\n        const ratedPcapacity = msg.ratedPcapacity\n        const ratedFrequency = msg.ratedFrequency\n        let delF = ratedFrequency - zeFac;\n        let zeFacOld = flow.get(\"zeFacOld\")\n        if (zeFacOld === undefined || isNaN(zeFacOld)) {\n            zeFacOld = 50;\n        }\n        oldPacLimit1 = flow.get(\"oldPacLimit1\")\n        if ((case1ZEF >= caseReset) && (zeFac != zeFacOld)) {\n            const pacLimitnew = (((zePac / 1000) + (((delF * ratedPcapacity) / (fDroopCmd * ratedFrequency)) * 100)) / inverterOnline)\n            //node.warn(`paclimit:${pacLimitnew}, zePac:${zePac} `) \n            pacLimit = (pacLimitnew * 1000)\n            oldPacLimit1 = pacLimit\n            node.warn(\"oldPacLimit1\" + oldPacLimit1)\n            zeFacOld = zeFac\n            case1ZEF = 0;\n            flow.set(\"zeFacOld\", zeFacOld)\n            flow.set(\"case1ZEF\", case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.1.0\"\n            const logMessageF = `4.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvF(logMessageF);\n        } else {\n            pacLimit = oldPacLimit1\n            case1ZEF++;\n            flow.set(\"case1ZEF\", case1ZEF);\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"4.1.1 \"\n            const logMessageF = `4.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n            logCsvF(logMessageF);\n        }\n        flow.set(\"oldPacLimit1\", oldPacLimit1);\n    } else if ((zeFMinLoad + zeFThreshold) == zeFac) {\n        flow.set(\"zeFacOld\", 50)\n        pacLimit = msg.facCapacityLimit * (blkPacMaxCmd)\n        case2ZEF++;\n        flow.set(\"case7ZEF\", case2ZEF);\n        msg.pacLimitMWrite = pacLimit * 10;\n        msg.case = \"4.5.0 \"\n        const logMessageF = `4.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQac},${oldPacLimit1},${oldQacLimit1},${pacLimit},${qacLimit},`;\n        logCsvF(logMessageF);\n    }\n}\n// -------------------------------------------------------Frequency Control End ----------------------------------------------------------------------------------\n// Save the pacLimit if it has been modified\nif (msg.pacLimitMWrite !== undefined) {\n    //node.warn(\"pacLimitMWrite was not set, setting default to Max limit\");\n    //msg.pacLimitMWrite = ..; // Setting a default value if none of the conditions met\n    //msg.case = \"Default Case: pacLimitMWrite was not set explicitly\";\n    global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n} else {\n    flow.set('P_integral', 0);\n    flow.set('P_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.pacLimitMWrite = 2772; // Setting a default value if none of the conditions met\n    global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n    flow.set('oldPacLimit1', msg.pacLimitMWrite / 10)\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\nlet actualQac\n// Save the qacLimit if it has been modified\nif (msg.qacLimitMWrite !== undefined) {\n    //actualQac = msg.qacLimitMWrite * inverterOnline;\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);\n} else {\n    flow.set('Q_integral', 0);\n    flow.set('Q_previous_error', 0);\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacLimitMWrite = 0; // Setting a default value if none of the conditions met\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);\n    flow.set('oldQacLimit1', msg.qacLimitMWrite / 10)\n    msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\n/* if (msg.qacRefSelMWrite !== undefined) {\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n} else {\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacRefSelMWrite = 162; // Setting a default value if none of the conditions met\n    global.set(`QAC_REF_SEL_CMD`, msg.qacRefSelMWrite);\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n} */\n//node.warn(`Final pacLimitMWrite: ${msg.pacLimitMWrite}, Case: ${msg.case}`);\n//node.warn(`Final qacLimitMWrite: ${msg.qacLimitMWrite}, Case: ${msg.caseq}`);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 770,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "6bbcb4c66c386fb6",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 130,
        "y": 60,
        "wires": [
            [
                "d6ef3a3734c94605"
            ]
        ]
    },
    {
        "id": "d6ef3a3734c94605",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "function 662",
        "func": "global.set (\"PAC_ON_OFF\",0)\nglobal.set(\"F1_ON_OFF\",1)\nglobal.set(\"SEL_PC_RX\", 1)\nglobal.set(\"PAC_PC_RX1\",70)\nglobal.set (\"QAC_ON_OFF\",0)\nglobal.set(\"QAC_PC_RX1\",11.55)\nglobal.set (\"UAC_ON_OFF\",0)\nglobal.set (\"QU_ON_OFF\",0)\nglobal.set (\"UAC_PC_RX1\",33)\nglobal.set (\"FAC_ON_OFF\",0)\nglobal.set (\"FAC_PC_RX1\",50)\nglobal.set (\"PF_ON_OFF\",1)\nglobal.set(\"PF_PC_RX1\",-1)\nreturn msg;\n\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "b36f32cd9e7395eb",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "PPC_Logic",
        "func": "const caseReset = 5; // Threshold for resetting cases\n\n// Function for File handling\nconst fd = global.get('fs');\n\n// Function to rename CSV files\nfunction renameCsvFiles(filePath) {\n    const files = fd.readdirSync(filePath).filter(file => file.endsWith('.csv'));\n    files.forEach(file => {\n        const oldPath = path.join(filePath, file);\n        const newPath = path.join(filePath, `${file.slice(0, -4)}.unsent`);\n        fd.renameSync(oldPath, newPath);\n    });\n}\n\n// Function to get epoch time\nfunction getEpochTime() {\n    // Get the current time and round down to the nearest 300 seconds\n    const now = Math.floor(Date.now() / 1000); // Convert to seconds\n    return now - (now % 300); // Round down to the nearest 300 seconds\n}\n\n// Function to log PPC Active Power Logic CSV\nfunction logCsv(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_01.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Reactive Power Logic CSV\nfunction logCsvQ(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_02.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Power Factor Logic CSV\nfunction logCsvPF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_05.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Voltage Logic CSV\nfunction logCsvU(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_03.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Frequency Logic CSV\nfunction logCsvF(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_04.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Function to log PPC Ramp Logic CSV\nfunction logCsvR(msg) {\n    // Calculate the epoch time for the current 300-second window\n    const epochTime = getEpochTime();\n\n    // Define the file path with the epoch time\n    const filePath = `/mnt/docker_common/dglog/PPC_log_${epochTime}_06.csv`;\n\n    // Ensure the file and directory exist\n    if (!fd.existsSync(filePath)) {\n        // Create the directory if it doesn't exist\n        const dir = path.dirname(filePath);\n        if (!fd.existsSync(dir)) {\n            fd.mkdirSync(dir, { recursive: true });\n        }\n\n        // Write the header if the file doesn't exist\n        fd.writeFileSync(filePath, 'TS,CASE,ZE_PAC,ZE_QAC,ZE_PF,ZE_UAC,ZE_FAC,PV_PAC,PV_QAC,PAC_LIMIT,QAC_LIMIT,PAC_LIMIT_WRITE,QAC_LIMIT_WRITE\"..\"\\n', 'utf8');\n    }\n\n    // Append the message with the current timestamp\n    const now = new Date().toISOString();\n    fd.appendFileSync(filePath, `${now},${msg}\\n`, 'utf8');\n}\n\n// Set last file pack time\nconst TS = getEpochTime();\nflow.set('lastFilePackTime', TS);\n\n// Rename CSV files if needed\nif (flow.get('lastFilePackTime') < TS) {\n    renameCsvFiles('/mnt/jffs2/dglog');\n    flow.set('lastFilePackTime', TS);\n}\n\n// UI Settings value for P Control\n// const pacMaxSetCmd = global.get(\"PAC_MAX_SET_RX1\")\nconst pacMaxSetCmd = 20000\n// const blkPacMaxCmd = global.get(\"BLOCK_PAC_MAX_SET_RX1\")\nconst blkPacMaxCmd = 20000\n//const pacLLSetCmd  = global.get(\"PAC_CL_SET_RX\")\n// const pacULSetCmd  = global.get(\"PAC_ULL_SET_RX\")\nconst pacLLSetCmd = 2\nconst pacULSetCmd = 2\nconst pacGRSetCmd  = global.get(\"PAC_GR_SET_RX\")\n//const pacTuneStCmd = global.get(\"PAC_TUNE_ST_CONST_RX\")\nconst pacTuneStCmd =20\nconst pacIncconstCmd = global.get(\"PAC_INCR_SET_RX\")\nconst pacDecconstCmd = global.get(\"PAC_DECR_CONST_RX\")\n\n// UI Settings value for Q Control\nconst qacMaxSetCmd =  global.get(\"QAC_MAX_SET_RX1\")\nconst blkQacMaxCmd =  global.get(\"BLOCK_QAC_MAX_SET_RX1\")\nconst qacLLSetCmd =  global.get(\"QAC_CL_SET_RX\")\nconst qacULSetCmd =  global.get(\"QAC_ULL_SET_RX\")\nconst qacGRSetCmd =  global.get(\"QAC_GR_SET_RX\")\nconst tuneStep =  global.get(\"QAC_TUNE_ST_CONST_RX\")\nconst qacIncConstCmd =  global.get(\"QAC_INCR_SET_RX\")\nconst qacDecConstCmd =  global.get(\"QAC_DECR_CONST_RX\")\n\n// UI Settings value for SVG Control\nconst svgSlot1StartHour = global.get(\"SVG_SLOT1_START_HOUR_RX1\")\nconst svgSlot2StartHour = global.get(\"SVG_SLOT2_START_HOUR_RX1\")\nconst svgSlot3StartHour = global.get(\"SVG_SLOT3_START_HOUR_RX1\")\nconst svgSlot4StartHour = global.get(\"SVG_SLOT4_START_HOUR_RX1\")\nconst svgSlot1StartMin = global.get(\"SVG_SLOT1_START_MIN_RX1\")\nconst svgSlot2StartMin = global.get(\"SVG_SLOT2_START_MIN_RX1\")\nconst svgSlot3StartMin = global.get(\"SVG_SLOT3_START_MIN_RX1\")\nconst svgSlot4StartMin = global.get(\"SVG_SLOT4_START_MIN_RX1\")\nconst svgSlot1StopHour = global.get(\"SVG_SLOT1_STOP_HOUR_RX1\")\nconst svgSlot2StopHour = global.get(\"SVG_SLOT2_STOP_HOUR_RX1\")\nconst svgSlot3StopHour = global.get(\"SVG_SLOT3_STOP_HOUR_RX1\")\nconst svgSlot4StopHour = global.get(\"SVG_SLOT4_STOP_HOUR_RX1\")\nconst svgSlot1StopMin = global.get(\"SVG_SLOT1_STOP_MIN_RX1\")\nconst svgSlot2StopMin = global.get(\"SVG_SLOT2_STOP_MIN_RX1\")\nconst svgSlot3StopMin = global.get(\"SVG_SLOT3_STOP_MIN_RX1\")\nconst svgSlot4StopMin = global.get(\"SVG_SLOT4_STOP_MIN_RX1\")\n\n// UI Settings Value for PF Control\nconst pfLLSetCmd = global.get(\"PF_LL_SET_RX\")\nconst pfULSetcmd = global.get(\"PF_UL_SET_RX\")\nconst pfGRSetCmd2 = global.get(\"PF_GR_SET_RX2\")\nconst pfGRSetCmd = global.get(\"PF_GR_SET_RX\")\nconst pfDecConstCmd = global.get(\"PF_DECR_CONST_RX\")\nconst pfIncConstCmd = global.get(\"PF_INCR_SET_RX\")\n\n// UI Settings Value for UAC Control\nconst quULSetCmd = global.get(\"UAC_ULL_SET_RX\") \nconst quLLSetCmd = global.get(\"UAC_CL_SET_RX\") \nconst quGRSetCmd = global.get(\"UAC_GR_SET_RX\") \nconst quTuneStCmd = global.get(\"UAC_TUNE_ST_CONST_RX\") \nconst quIncConstCmd = global.get(\"UAC_INCR_SET_RX\") \nconst quDecConstCmd = global.get(\"UAC_DECR_CONST_RX\") \n\n// UI Settings Value for FAC Control\nconst facULSetCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst facLLSetCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst facCULSetCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst facCLLSetCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst facGRSetCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst facTuneStCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst facIncConstCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst facDecConstCmd = global.get(\"UAC_DECR_CONST_RX\")\nconst fDroopCmd = global.get(\"UAC_DECR_CONST_RX\")\n\n// UI Settings Value for RAMP Control\nconst rampTuneStCmd = global.get(\"RAMP_TUNE_ST_CONST_RX\")\nconst rampIncconstCmd = global.get(\"RAMP_INCR_CONST_RX\")\nconst rampDecconstCmd = global.get(\"RAMP_DECR_CONST_RX\")\nconst rampOnOffCmd = msg.ramponoff\n\n// UI Settings Value for VRT Control\nconst lvrthvrtULSetCmd = global.get(\"LVRT_HVRT_ULL_SET_RX\")\nconst lvrthvrtLLSetCmd = global.get(\"LVRT_HVRT_CL_SET_RX\")\n\n// Setpoint & Simulation Value for P Control\nconst dev = msg.device\nconst pacOnOffCmd = msg.paconoff\nconst fonoffcmd = msg.fonoff\nconst powselcmd = msg.selpc\nconst zePac = msg.gridpac \nconst zePMinLoad = (msg.pacpc * 1000)\nconst inverterOnline = msg.inverterOnline\nlet PAC_LIMIT = msg.paclimit\nif (PAC_LIMIT === undefined || isNaN(PAC_LIMIT)) { PAC_LIMIT = 1000; }\nconst zeIacMaxCmd = msg.maxcurrent\nconst zeIacSetCmd = msg.setcurrent\nconst zeIac = msg.gridiac\nconst pvPac = msg.invpac\nconst Kp = msg.kp\nconst Ti = msg.ti\nconst Kd = msg.kd\nlet Inv_Setpoint\nlet P_error\nlet P_integral\nif (P_integral === undefined || isNaN(P_integral)) { P_integral = 0; }\nlet P_derivative\nlet P_previous_error\nif (P_previous_error === undefined || isNaN(P_previous_error)) { P_previous_error = 0; }\n\n// Setpoint & Simulation Value for Q Control\nconst qaconoffcmd = msg.qaconoff\nconst zeQac = msg.gridqac\nlet zeMinLoad = (msg.qacpc * 1000)\nlet QAC_LIMIT = (msg.qaclimit * 0.1)\nif (QAC_LIMIT === undefined || isNaN(QAC_LIMIT)) { QAC_LIMIT = 0; }\nconst zePfSetCmd = msg.setpf\nconst zepfMaxLoad = msg.maxpf\nconst zePf = (msg.gridpf * 0.01)\nconst pvQac = msg.invqac \nconst Kpq = msg.kpq\nconst Tiq = msg.tiq\nconst Kdq = msg.kdq\nlet Inv_Qsetpoint\nlet Q_error \nlet Q_integral \nif (Q_integral === undefined || isNaN(Q_integral)) { Q_integral = 0; }\nlet Q_derivative\nlet Q_previous_error\nif (Q_previous_error === undefined || isNaN(Q_previous_error)) { Q_previous_error = 0; }\n\n\n// Setpint Value for SVG Control\nconst svgonoffcmd = msg.svgonoff\nconst svgslot1pccmd = msg.svgslot1pc\nconst svgslot2pccmd = msg.svgslot2pc\nconst svgslot3pccmd = msg.svgslot3pc\n\n// Setpoint & Simulation Value for PF Control\nconst pfonoffcmd = msg.pfonoff\nconst zePFMinLoad = msg.pfpc\nconst zePFThreshold = pfULSetcmd\n\n// Setpoint & Simulation Value for U Control\nconst uaconoffcmd = msg.uaconoff\nconst zeUMinLoad = msg.uacpc\nconst zeUac = (msg.griduac * 0.1)\nlet zeUThreshold = (zeUMinLoad * (quULSetCmd/100))\nlet zeUCriticalLoad = zeUMinLoad - ((quLLSetCmd / 100) * zeUMinLoad);\nlet qacMaxSet\nlet ratedQCapacity\nconst ratedvoltage = msg.Vrated\nconst  droopPercentage = msg.Vdroop\nconst dbPercentage = quULSetCmd\n\n// Voltage Droop Calculation\nconst dbThreshold = (dbPercentage * ratedvoltage) / 100\nconst droopThreshold = (droopPercentage * ratedvoltage) / 100\nconst deadBandMax = ratedvoltage + dbThreshold\nconst deadBandMin = ratedvoltage - dbThreshold\nconst droopMax = ratedvoltage + droopThreshold\nconst droopMin = ratedvoltage - droopThreshold\n\n// Setpoint & Simulation Value for VRT Control\nconst lvrtHvrtOnOffCmd = msg.lvrthvrtonoff\nconst zelvrthvrtCriticalLoad = (zeUMinLoad * (lvrthvrtULSetCmd / 100));\nconst zelvrthvrtThreshold = zeUMinLoad - ((lvrthvrtLLSetCmd / 100) * zeUMinLoad);\n\n// Setpoint & Simulation Value for F Control\nconst faconoffcmd = msg.faconoff\nconst zeFMinLoad = msg.facpc\nconst zeFac = (msg.gridfac * 0.1)\nconst zeFCriticalLoad = facLLSetCmd\nconst zeFUCriticalLoad = facCULSetCmd\nconst zeFLCriticalLoad = facCLLSetCmd\nconst zeFThreshold = facULSetCmd \nlet pacLimitdel\n\n// Initialize pacLimit and other variables\nlet maxPacLimit = PAC_LIMIT;\nlet oldPacLimit1\n\nlet minPacLimit = maxPacLimit;\nconst invPacLimit = PAC_LIMIT; // Assuming this comes from msg\n\nconst zePCriticalLoad = zePMinLoad - ((pacLLSetCmd / 100) * blkPacMaxCmd)\nconst zePThreshold = (pacULSetCmd / 100) * blkPacMaxCmd\n\n// Update max and min limits based on invPacLimit\nif (!isNaN(invPacLimit)) {\n    if (invPacLimit > maxPacLimit) maxPacLimit = invPacLimit;\n    if (invPacLimit < minPacLimit) minPacLimit = invPacLimit;\n}\n\nlet pacLimit = maxPacLimit;\nlet oldPacLimit = pacLimit;\n\n// Initialize qacLimit and other variables\nlet maxQacLimit = QAC_LIMIT;\nlet minQacLimit = maxQacLimit;\nconst invQacLimit = QAC_LIMIT; // Assuming this comes from msg\n\nlet zeCriticalLoad = zeMinLoad - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeThreshold = (qacULSetCmd / 100) * blkQacMaxCmd\n\n//SVG Variables\nconst zeSvgSlot1MinLoad = svgslot1pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot1CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\n\nconst zeSvgSlot2MinLoad = svgslot2pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot2CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\n\nconst zeSvgSlot3MinLoad = svgslot3pccmd - ((qacLLSetCmd / 100) * blkQacMaxCmd)\nconst zeSvgSlot3CriticalLoad = (qacULSetCmd / 100) * blkQacMaxCmd\n\nlet qModeEnable\n\n// Update max and min limits based on invQacLimit\nif (!isNaN(invQacLimit)) {\n    if (invQacLimit > maxQacLimit) maxQacLimit = invQacLimit;\n    if (invQacLimit < minQacLimit) minQacLimit = invQacLimit;\n}\n\nlet qacLimit = maxQacLimit;\nlet oldQacLimit = qacLimit;\nlet qacLimitW = qacLimit;\nlet oldQacLimitW = qacLimit;\nlet pvQacW = qacLimit;\n\nmsg.pacLimitMWrite = undefined; // Initialize msg.pacLimitMWrite to undefined to identify if it remains unset\nmsg.qacLimitMWrite = undefined; // Initialize msg.qacLimitMWrite to undefined to identify if it remains unset\n\n// PPC P Control Casereset\nlet case1ZEP = flow.get('case1ZEP');\nif (case1ZEP === undefined || isNaN(case1ZEP)) { case1ZEP = 5; }\nlet case2ZEP = flow.get('case2ZEP');\nif (case2ZEP === undefined || isNaN(case2ZEP)) { case2ZEP = 5; }\nlet case3ZEP = flow.get('case3ZEP');\nif (case3ZEP === undefined || isNaN(case3ZEP)) { case3ZEP = 5; }\nlet case4ZEP = flow.get('case4ZEP');\nif (case4ZEP === undefined || isNaN(case4ZEP)) { case4ZEP = 5; }\nlet case5ZEP = flow.get('case5ZEP');\nif (case5ZEP === undefined || isNaN(case5ZEP)) { case5ZEP = 5; }\n\n\n// PPC Q Control Casereset\nlet case1ZEQ = flow.get('case1ZEQ');\nif (case1ZEQ === undefined || isNaN(case1ZEQ)) { case1ZEQ = 5; }\nlet case2ZEQ = flow.get('case2ZEQ');\nif (case2ZEQ === undefined || isNaN(case2ZEQ)) { case2ZEQ = 5; }\nlet case3ZEQ = flow.get('case3ZEQ');\nif (case3ZEQ === undefined || isNaN(case3ZEQ)) { case3ZEQ = 5; }\nlet case4ZEQ = flow.get('case4ZEQ');\nif (case4ZEQ === undefined || isNaN(case4ZEQ)) { case4ZEQ = 5; }\nlet case5ZEQ = flow.get('case5ZEQ');\nif (case5ZEQ === undefined || isNaN(case5ZEQ)) { case5ZEQ = 5; }\n\n// PPC PF Control Casereset\nlet case1ZEPF = flow.get('case1ZEPF');\nif (case1ZEPF === undefined || isNaN(case1ZEPF)) { case1ZEPF = 5; }\nlet case2ZEPF = flow.get('case2ZEPF');\nif (case2ZEPF === undefined || isNaN(case2ZEPF)) { case2ZEPF = 5; }\nlet case3ZEPF = flow.get('case3ZEPF');\nif (case3ZEPF === undefined || isNaN(case3ZEPF)) { case3ZEPF = 5; }\nlet case4ZEPF = flow.get('case4ZEPF');\nif (case4ZEPF === undefined || isNaN(case4ZEPF)) { case4ZEPF = 5; }\nlet case5ZEPF = flow.get('case5ZEPF');\nif (case5ZEPF === undefined || isNaN(case5ZEPF)) { case5ZEPF = 5; }\n\n// PPC U Control Casereset\nlet case1ZEU = flow.get('case1ZEU');\nif (case1ZEU === undefined || isNaN(case1ZEU)) { case1ZEU = 5; }\nlet case2ZEU = flow.get('case2ZEU');\nif (case2ZEU === undefined || isNaN(case2ZEU)) { case2ZEU = 5; }\nlet case3ZEU = flow.get('case3ZEU');\nif (case3ZEU === undefined || isNaN(case3ZEU)) { case3ZEU = 5; }\nlet case4ZEU = flow.get('case4ZEU');\nif (case4ZEU === undefined || isNaN(case4ZEU)) { case4ZEU = 5; }\nlet case5ZEU = flow.get('case5ZEU');\nif (case5ZEU === undefined || isNaN(case5ZEU)) { case5ZEU = 5; }\nlet case6ZEU = flow.get('case6ZEU');\nif (case6ZEU === undefined || isNaN(case6ZEU)) { case6ZEU = 5; }\n\n// PPC F Control Casereset\nlet case1ZEF = flow.get('case1ZEF');\nif (case1ZEF === undefined || isNaN(case1ZEF)) { case1ZEF = 5; }\nlet case2ZEF = flow.get('case2ZEF');\nif (case2ZEF === undefined || isNaN(case2ZEF)) { case2ZEF = 5; }\nlet case3ZEF = flow.get('case3ZEF');\nif (case3ZEF === undefined || isNaN(case3ZEF)) { case3ZEF = 5; }\nlet case4ZEF = flow.get('case4ZEF');\nif (case4ZEF === undefined || isNaN(case4ZEF)) { case4ZEF = 5; }\nlet case5ZEF = flow.get('case5ZEF');\nif (case5ZEF === undefined || isNaN(case5ZEF)) { case5ZEF = 5; }\nlet case6ZEF = flow.get('case6ZEF');\nif (case6ZEF === undefined || isNaN(case6ZEF)) { case6ZEF = 5; }\nlet case7ZEF = flow.get('case7ZEF');\nif (case7ZEF === undefined || isNaN(case7ZEF)) { case7ZEF = 5; }\n\n// PPC R Control Casereset\nlet case1ZER = flow.get('case1ZER');\nif (case1ZER === undefined || isNaN(case1ZER)) { case1ZER = 5; }\nlet case2ZER = flow.get('case2ZER');\nif (case2ZER === undefined || isNaN(case2ZER)) { case2ZER = 5; }\nlet case3ZER = flow.get('case3ZER');\nif (case3ZER === undefined || isNaN(case3ZER)) { case3ZER = 5; }\nlet case4ZER = flow.get('case4ZER');\nif (case4ZER === undefined || isNaN(case4ZER)) { case4ZER = 5; }\nlet case5ZER = flow.get('case5ZER');\nif (case5ZER === undefined || isNaN(case5ZER)) { case5ZER = 5; }\n\n// ------------------------------- Open Loop Logic Start ---------------------------------------------\nlet OLpacLimit = msg.openplimit\nlet OLqacLimit = (msg.openqlimit / blkQacMaxCmd) * 100\nif (powselcmd == 0) { \n   if ((OLpacLimit != undefined || !isNaN(OLpacLimit))) {\n    msg.pacLimitMWrite = OLpacLimit;\n    msg.case = \"Case 0: PACLIMIT has given from User\";}\n\t\n   if ((OLqacLimit != undefined || !isNaN(OLqacLimit))) {\n    msg.qacLimitMWrite = OLqacLimit * 10;\n    msg.caseq = \"Case 0: QACLIMIT has given from User\";}}\n\n// ---------------------------------- Open Loop Logic Stop ----------------------------------------------------\n\n// ---------------------------------------- Active Power Control Logic Start -------------------------------------------------------\nif (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && pacOnOffCmd == 1) {\n    if (zePac >= (zePMinLoad + zePThreshold) && maxPacLimit > 0 && zeIac < zeIacSetCmd) {\n        Inv_Setpoint = zePMinLoad / inverterOnline\n\n        P_error = (pvPac/inverterOnline) - Inv_Setpoint\n\n        P_integral = P_integral + (P_error * 0.1)\n\n        //P_derivative = (P_error - P_previous_error) / 0.1\n\n        //P_previous_error = P_error\n\n        //if (case1ZEP >= caseReset) {\n\n        //pacLimit = pvPac - (((Kp * P_error) + ((Kp/Ti) * P_integral) + (Kd * P_derivative)))\n\n        //pacLimit = (pvPac/inverterOnline) - (((Kp * P_error) + ((Kp/Ti) * P_integral)))\n\n        pacLimit = oldPacLimit1\n        node.warn(`P_error: ${P_error}`);\n        node.warn(`P_integral: ${P_integral}`);\n        node.warn(`invpac: ${pvPac}`);\n        node.warn(`limit: ${pacLimit}`);\n\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n\n        if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n\n           if (case1ZEP >= caseReset) {\n               pacLimit = (pvPac / inverterOnline) - (((Kp * P_error) + ((Kp / Ti) * P_integral)))\n               pacLimit = oldPacLimit1\n                case1ZEP = 0;\n                flow.set('case1ZEP', case1ZEP);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit * 10;\n                msg.case = \"1.1.0 force down\"\n                const logMessage = `1.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            } else {\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit * 10;\n                case1ZEP++;\n                flow.set('case1ZEP', case1ZEP);\n                msg.case = \"1.1.1 force down\"\n                const logMessage = `1.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            }\n    }\n    // Case 2: < critical load\n    else if (zePac <= zePCriticalLoad && minPacLimit < pacMaxSetCmd && zeIac < zeIacSetCmd) {\n\n        pacLimit = oldPacLimit1\n\n        node.warn(`invpac1: ${oldPacLimit1}`);\n        node.warn(`limit1: ${pacLimit}`);\n\n       if (case2ZEP >= caseReset) {\n\n        Inv_Setpoint = zePMinLoad / inverterOnline\n\n        P_error = Inv_Setpoint - (pvPac / inverterOnline) \n\n        P_integral = P_integral + (P_error * 0.1)\n\n        //P_derivative = (P_error - P_previous_error) / 0.1\n\n        //P_previous_error = P_error\n\n        //pacLimit = pvPac + (((Kp * P_error) + ((Kp / Ti) * P_integral) + (Kd * P_derivative)))\n        \n       \n        //pacLimit = (pvPac/inverterOnline) + (((Kp * P_error) + ((Kp / Ti) * P_integral)))\n\n         pacLimit = (pvPac / inverterOnline) + (((Kp * P_error) + ((Kp / Ti) * P_integral)))\n         oldPacLimit1 = pacLimit\n\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n\n        node.warn(`invpac1: ${oldPacLimit1}`);\n        node.warn(`limit1: ${pacLimit}`);\n\n\n        if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n\n           //if (case2ZEP >= caseReset) {\n              \n                case2ZEP = 0;\n                flow.set('case2ZEP', case2ZEP);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit * 10;\n                msg.case = \"1.2.0 force UP\"\n                const logMessage = `1.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            } else {\n                case2ZEP++;\n                flow.set('case2ZEP', case2ZEP);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit * 10;\n                msg.case = \"1.2.1 force UP\"\n                const logMessage = `1.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            }\n    }\n    // Case 3:  > Critical  & < lower ---tune up\n    else if ((zePac <= zePMinLoad - zePThreshold) && zePac > zePCriticalLoad && maxPacLimit < pacMaxSetCmd && zeIac < zeIacSetCmd) {\n        pacLimit = minPacLimit + (pacTuneStCmd * pacMaxSetCmd / 1000);\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n        if (case3ZEP >= caseReset) {\n            case3ZEP = 0;\n            flow.set('case3ZEP', case3ZEP);\n            if (pacLimit <= 2) pacLimit = 2;\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.3.0 tune UP\"\n            const logMessage = `1.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsv(logMessage);\n        } else {\n            case3ZEP++;\n            flow.set('case3ZEP', case3ZEP);\n            msg.pacLimitMWrite = pacLimit*10;\n            msg.case = \"1.3.1 tune UP\"\n            const logMessage = `1.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsv(logMessage);\n        }\n    }\n    // Case 4: ZEP meter > 0 & ZEP meter < minload no change\n    else if (zeIac >= zeIacSetCmd && maxPacLimit < pacMaxSetCmd) {\n        if (zeIac > zeIacMaxCmd) {\n            let pacLimit = maxPacLimit - (pacTuneStCmd * pacMaxSetCmd / 1000);\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            if (case4ZEP >= caseReset) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.0 current\"\n                const logMessage = `1.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.1 current\"\n                const logMessage = `1.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            }\n        }\n        else {\n            pacLimit = pacLimit\n            if (case4ZEP >= caseReset) {\n                case4ZEP = 0;\n                flow.set('case4ZEP', case4ZEP);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.2 current\"\n                const logMessage = `1.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            } else {\n                case4ZEP++;\n                flow.set('case4ZEP', case4ZEP);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"1.4.3 current\"\n                const logMessage = `1.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsv(logMessage);\n            }\n        }\n    }\n    // Case 5: Stable\n    else if ((zePac <= zePMinLoad + zePThreshold && zePac >= zePMinLoad - zePThreshold || maxPacLimit <= pacMaxSetCmd )&& zeIac < zeIacSetCmd) {\n        pacLimit = pacLimit\n        if (case5ZEP >= caseReset) {\n            case5ZEP = 0;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 2) pacLimit = 2;\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.5.0 stable\"\n            const logMessage = `1.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsv(logMessage);\n        } else {\n            case5ZEP++;\n            flow.set('case5ZEP', case5ZEP);\n            if (pacLimit <= 2) pacLimit = 2;\n            msg.pacLimitMWrite = pacLimit * 10;\n            msg.case = \"1.5.1 stable\"\n            const logMessage = `1.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsv(logMessage);\n        }\n    }\n}\n// ------------------------------------------ Active Power Control Logic End -------------------------------------------------------------------------------\n\n\n// ------------------------------------------ Reactive Power Control Logic Start ----------------------------------------------------------------------------\nif (!isNaN(zeQac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && (qaconoffcmd == 1 || svgonoffcmd ==1)) {\n    const now = new Date();\n    const min = now.getMinutes();\n    const hour = now.getHours();\n\n    // Select the setpoint based on Slots\n    if (qaconoffcmd == 1 && svgonoffcmd == 1) {\n    if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n        zeCriticalLoad = zeSvgSlot1CriticalLoad;\n        zeMinLoad = zeSvgSlot1MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n        zeCriticalLoad = zeSvgSlot2CriticalLoad;\n        zeMinLoad = zeSvgSlot2MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n        zeCriticalLoad = zeSvgSlot3CriticalLoad;\n        zeMinLoad = zeSvgSlot3MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n        zeCriticalLoad = zeCriticalLoad;\n        zeMinLoad = zeMinLoad;\n        qModeEnable = 1;\n    }\n}\n\nif (qaconoffcmd == 0 && svgonoffcmd == 1) {\n    if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n        zeCriticalLoad = zeSvgSlot1CriticalLoad;\n        zeMinLoad = zeSvgSlot1MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n        zeCriticalLoad = zeSvgSlot2CriticalLoad;\n        zeMinLoad = zeSvgSlot2MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n        zeCriticalLoad = zeSvgSlot3CriticalLoad;\n        zeMinLoad = zeSvgSlot3MinLoad;\n        qModeEnable = 1;\n    }\n    if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n        qModeEnable = 0;\n    }\n}\n\nif (qaconoffcmd == 1 && svgonoffcmd == 0) {\n    if (((hour > svgSlot1StartHour) || (hour === svgSlot1StartHour && min >= svgSlot1StartMin)) && ((hour < svgSlot1StopHour) || (hour === svgSlot1StopHour && min < svgSlot1StopMin))) {\n        qModeEnable = 0;\n    }\n    if (((hour > svgSlot2StartHour) || (hour === svgSlot2StartHour && min >= svgSlot2StartMin)) && ((hour < svgSlot2StopHour) || (hour === svgSlot2StopHour && min < svgSlot2StopMin))) {\n        qModeEnable = 0;\n    }\n    if (((hour > svgSlot3StartHour) || (hour === svgSlot3StartHour && min >= svgSlot3StartMin)) && ((hour < svgSlot3StopHour) || (hour === svgSlot3StopHour && min < svgSlot3StopMin))) {\n        qModeEnable = 0;\n    }\n    if (((hour > svgSlot4StartHour) || (hour === svgSlot4StartHour && min >= svgSlot4StartMin)) && ((hour < svgSlot4StopHour) || (hour === svgSlot4StopHour && min < svgSlot4StopMin))) {\n        zeCriticalLoad = zeCriticalLoad;\n        zeMinLoad = zeMinLoad;\n        qModeEnable = 1;\n    }\n}\n    //node.warn(`svg_status,${hour}`)\n    //node.warn(`setpoint,${svgSlot4StartHour}`)\n    \n    // Case 1: ZE meter < critical load (100VAR); Reactive Power supply to grid\n    if ((zeQac <= zeCriticalLoad) && (maxQacLimit > -100) && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd)) && qModeEnable === 1) {\n        Inv_Qsetpoint = zeMinLoad / inverterOnline\n\n        if (Inv_Qsetpoint > 0) {\n            Q_error = pvQac - Inv_Qsetpoint\n        } else {\n            Q_error = Inv_Qsetpoint - pvQac\n        }\n\n        Q_integral = Q_integral +(Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        qacLimit = pvQac + (((Kpq * Q_error) + ((Kpq/Tiq) * Q_integral) + (Kdq * Q_derivative)))\n\n        if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n\n            if (case1ZEQ >= caseReset) {\n                case1ZEQ = 0;\n                flow.set('case1ZEQ', case1ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.1.0\";\n                const logMessageQ = `2.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            } else {\n                case1ZEQ++;\n                flow.set('case1ZEQ', case1ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.1.1\";\n                const logMessageQ = `2.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            }\n    }\n    // Case 2: ZE meter > Min Load force up; Reactive Power consumption from grid < -50VAR\n    else if ((zeQac >= (zeMinLoad + zeThreshold)) && (minQacLimit < 100) && ((zePf > zePfSetCmd) || (zePf < -zePfSetCmd)) && qModeEnable === 1) {\n        Inv_Qsetpoint = zeMinLoad / inverterOnline\n\n        if (Inv_Qsetpoint >= 0) {\n            Q_error = Inv_Qsetpoint - pvQac\n        } else {\n            Q_error = pvQac - Inv_Qsetpoint\n        }\n\n        Q_integral = Q_integral + (Q_error * 0.1)\n\n        Q_derivative = (Q_error - Q_previous_error) / 0.1\n\n        Q_previous_error = Q_error\n\n        qacLimit = pvQac + (((Kpq * Q_error) + ((Kpq / Tiq) * Q_integral) + (Kdq * Q_derivative)))\n\n        if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n\n            if (case2ZEQ >= caseReset) {\n                case2ZEQ = 0;\n                flow.set('case2ZEQ', case2ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.2.2\";\n                const logMessageQ = `2.2.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            } else {\n                case1ZEQ++;\n                flow.set('case2ZEQ', case2ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.2.3\";\n                const logMessageQ = `2.2.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            }\n    }\n    // Case 3: ZE meter > minload & ZE meter < 10  tune up\n    else if (zeQac <= (zeMinLoad - zeThreshold) && minQacLimit > -100 && (zePf > zePfSetCmd || zePf < -zePfSetCmd) && qModeEnable === 1) {\n        qacLimit = parseFloat(((maxQacLimit * qacMaxSetCmd / 100) - (tuneStep * qacMaxSetCmd / 1000)).toFixed(1));\n        oldQacLimit = parseFloat((oldQacLimit * qacMaxSetCmd / 100).toFixed(1));\n        if (qacLimit < -qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n        oldQacLimitW = parseFloat((1 * (oldQacLimit / qacMaxSetCmd) * 100).toFixed(1));\n        qacLimitW = parseFloat((1 * (qacLimit / qacMaxSetCmd) * 100).toFixed(1));\n        pvQacW = 1 * (pvQac);\n\n        if (case3ZEQ >= caseReset) {\n            case3ZEQ = 0;\n            flow.set('case3ZEQ', case3ZEQ);\n            msg.qacLimitMWrite = qacLimitW * 10;\n            msg.caseq = \"2.3.0\";\n            const logMessageQ = `2.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case3ZEQ++;\n            flow.set('case3ZEQ', case3ZEQ);\n            msg.qacLimitMWrite = qacLimitW * 10;\n            msg.caseq = \"2.3.1\";\n            const logMessageQ = `2.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQ(logMessageQ);\n        }\n    }\n    //case 4 : ZE meter > 0 & ZE meter < minload  no change\n    else if (((zePf < 0 && zePf >= -zePfSetCmd) || (zePf > 0 && zePf <= zePfSetCmd)) && qModeEnable === 1) {\n        oldQacLimit = parseFloat((oldQacLimit * qacMaxSetCmd / 100).toFixed(1));\n        qacLimit = parseFloat((qacLimit * qacMaxSetCmd / 100).toFixed(1));\n\n        if ((zePf <= zepfMaxLoad && zePf >= -zepfMaxLoad) && maxQacLimit >= 0) {\n            qacLimit = parseFloat(((maxQacLimit * qacMaxSetCmd / 100) - (tuneStep * qacMaxSetCmd / 1000)).toFixed(1));\n            if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            qacLimitW = parseFloat(((1 * (qacLimit / qacMaxSetCmd) * 100)).toFixed(1));\n            pvQacW = 1 * pvQac;\n\n            if (case4ZEQ >= caseReset) {\n                case4ZEQ = 0;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.4.0\";\n                const logMessageQ = `2.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            } else {\n                case4ZEQ++;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.4.1\";\n                const logMessageQ = `2.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            }\n        } else if ((zePf <= zepfMaxLoad && zePf >= -zepfMaxLoad) && maxQacLimit < 0) {\n            qacLimit = parseFloat(((maxQacLimit * qacMaxSetCmd / 100) + (tuneStep * qacMaxSetCmd / 1000)).toFixed(1));\n            if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n            qacLimit = parseFloat(qacLimit.toFixed(1));\n            qacLimitW = parseFloat(((1 * (qacLimit / qacMaxSetCmd) * 100)).toFixed(1));\n            pvQacW = 1 * pvQac;\n\n            if (case4ZEQ >= caseReset) {\n                case4ZEQ = 0;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.4.2\";\n                const logMessageQ = `2.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            } else {\n                case4ZEQ++;\n                flow.set('case4ZEQ', case4ZEQ);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"2.4.3\";\n                const logMessageQ = `2.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvQ(logMessageQ);\n            }\n        }\n    }\n\n    //case 5\n    else if (zeQac <= zeMinLoad + zeThreshold && zeQac >= zePMinLoad - zePThreshold && (zePf > zePfSetCmd || zePf < -zePfSetCmd) && qModeEnable === 1) {\n        qacLimitW = qacLimitW;\n        if (case5ZEQ >= caseReset) {\n            case5ZEQ = 0;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimitW * 10;\n            msg.caseq = \"2.5.0 stable\"\n            const logMessageQ = `2.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQ(logMessageQ);\n        } else {\n            case5ZEQ++;\n            flow.set('case5ZEQ', case5ZEQ);\n            msg.qacLimitMWrite = qacLimitW * 10;\n            msg.caseq = \"2.5.1 stable\"\n            const logMessageQ = `2.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvQ(logMessageQ);\n\n        }\n\n    }\n}\n// --------------------------------------------------------- Reactive Power Control Logic End ----------------------------------------------------------------------\n\n// --------------------------------------------------------- Power Factor Control Logic Start ----------------------------------------------------------------------\n\nif (!isNaN(zePf) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && pfonoffcmd === 1 ) {\n    if (zePf < (zePFMinLoad - zePFThreshold) && zePf > 0 && zePFMinLoad > 0 && maxQacLimit > -103 && zePac > 0 && maxQacLimit < 100) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = (((pvQac + zeQac - zePFMinLoadnew) / inverterOnline) / ((100 - pfGRSetCmd) / 100));\n        if (((-1 * zePFMinLoadnew) / inverterOnline) < qacLimit) qacLimit = (minQacLimit * qacMaxSetCmd / 100);\n        if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n        qacLimit = parseFloat(qacLimit.toFixed(2));\n        oldQacLimit = parseFloat((minQacLimit * qacMaxSetCmd / 100).toFixed(1));\n        if (oldQacLimit >= qacLimit) {\n            qacLimit = oldQacLimit + parseFloat((pfIncConstCmd * qacMaxSetCmd / 1000).toFixed(1));\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = 1 * pvQac;\n            if (case1ZEPF >= caseReset) {\n                case1ZEPF = 0;\n                flow.set('case1ZEPF', case1ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.1.0\"\n                const logMessagePF = `5.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case1ZEPF++;\n                flow.set('case1ZEPF', case1ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.1.1\"\n                const logMessagePF = `5.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        } else {\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = -1 * pvQac;\n            if (case1ZEPF >= caseReset) {\n                case1ZEPF = 0;\n                flow.set('case1ZEPF', case1ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.1.2\"\n                const logMessagePF = `5.1.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case1ZEPF++;\n                flow.set('case1ZEPF', case1ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.1.3\"\n                const logMessagePF = `5.1.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        }\n    } else if (((zePf < zePFMinLoad) || (zePf > (zePFThreshold + zePFMinLoad))) && zePf >= -1 && zePFMinLoad > 0 && maxQacLimit < 101 && maxQacLimit > -100) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)));\n        qacLimit = (((pvQac + zeQac - zePFMinLoadnew) / inverterOnline) * ((100 - pfGRSetCmd2) / 100));\n        if (((-1 * zePFMinLoadnew) / inverterOnline) > qacLimit) qacLimit = (maxQacLimit * qacMaxSetCmd / 100);\n        if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n        qacLimit = parseFloat(qacLimit.toFixed(2));\n        oldQacLimit = parseFloat((maxQacLimit * qacMaxSetCmd / 100).toFixed(3));\n        //node.warn(`old,${oldQacLimit}`)\n        //node.warn(`new,${qacLimit}`)\n        if (oldQacLimit <= qacLimit) {\n            qacLimit = oldQacLimit - parseFloat((pfDecConstCmd * qacMaxSetCmd / 1000).toFixed(3));\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = 1 * pvQac;\n            if (case2ZEPF >= caseReset) {\n                case2ZEPF = 0;\n                flow.set('case2ZEPF', case2ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.2.0\"\n                const logMessagePF = `5.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case2ZEPF++;\n                flow.set('case2ZEPF', case2ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.2.1\"\n                const logMessagePF = `5.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        } else {\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = 1 * pvQac;\n            if (case2ZEPF >= caseReset) {\n                case2ZEPF = 0;\n                flow.set('case2ZEPF', case2ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.2.2\"\n                const logMessagePF = `5.2.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case2ZEPF++;\n                flow.set('case2ZEPF', case2ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.2.3\"\n                const logMessagePF = `5.2.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        }\n    } else if (zePf > (zePFThreshold + zePFMinLoad) && zePf < 0 && maxQacLimit < 101 && maxQacLimit > -103) {\n        let zePFMinLoadnew = (zePac / (zePFMinLoad - zePFThreshold)) * Math.sqrt(1 - ((zePFMinLoad - zePFThreshold) * (zePFMinLoad - zePFThreshold)));\n        qacLimit = (((pvQac + zeQac - zePFMinLoadnew) / inverterOnline) / ((100 - pfGRSetCmd) / 100));\n        if (((-1 * zePFMinLoadnew) / inverterOnline) < qacLimit) qacLimit = (minQacLimit * qacMaxSetCmd / 100);\n        if (qacLimit > qacMaxSetCmd) qacLimit = qacMaxSetCmd;\n        qacLimit = parseFloat(qacLimit.toFixed(2));\n        oldQacLimit = parseFloat((minQacLimit * qacMaxSetCmd / 100).toFixed(1));\n        if (oldQacLimit <= qacLimit) {\n            qacLimit = oldQacLimit - parseFloat((pfDecConstCmd * qacMaxSetCmd / 1000).toFixed(1));\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = 1 * pvQac;\n            if (case3ZEPF >= caseReset) {\n                case3ZEPF = 0;\n                flow.set('case3ZEPF', case3ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.3.0\"\n                const logMessagePF = `5.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case3ZEPF++;\n                flow.set('case3ZEPF', case3ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.3.1\"\n                const logMessagePF = `5.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        } else {\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = -1 * pvQac;\n            if (case3ZEPF >= caseReset) {\n                case3ZEPF = 0;\n                flow.set('case3ZEPF', case3ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.3.2\"\n                const logMessagePF = `5.3.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case3ZEPF++;\n                flow.set('case3ZEPF', case3ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.3.3\"\n                const logMessagePF = `5.3.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        }\n    } else if ((zePf < zePFMinLoad || zePf > ((-zePFThreshold) - (zePFMinLoad))) && (zePFMinLoad < 0) && (zePf >= -1) && (maxQacLimit < 100) && (maxQacLimit > -101)) {\n        let zePFMinLoadnew = (zePac / (zePFThreshold + zePFMinLoad)) * Math.sqrt(1 - ((zePFThreshold - zePFMinLoad) * (zePFThreshold - zePFMinLoad)));\n        qacLimit = (((pvQac + zeQac - zePFMinLoadnew) / inverterOnline) * ((100 - pfGRSetCmd2) / 100));\n        if (((-1 * zePFMinLoadnew) / inverterOnline) > qacLimit) qacLimit = (maxQacLimit * qacMaxSetCmd / 100);\n        if (qacLimit < -qacMaxSetCmd) qacLimit = -qacMaxSetCmd;\n        qacLimit = parseFloat(qacLimit.toFixed(2));\n        oldQacLimit = parseFloat((maxQacLimit * qacMaxSetCmd / 100).toFixed(3));\n        if (oldQacLimit >= qacLimit) {\n            qacLimit = oldQacLimit + parseFloat((pfIncConstCmd * qacMaxSetCmd / 1000).toFixed(3));\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = 1 * pvQac;\n            if (case4ZEPF >= caseReset) {\n                case4ZEPF = 0;\n                flow.set('case4ZEPF', case4ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.4.0\"\n                const logMessagePF = `5.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case4ZEPF++;\n                flow.set('case4ZEPF', case4ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.4.1\"\n                const logMessagePF = `5.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        } else {\n            oldQacLimitW = parseFloat(((1 * oldQacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            qacLimitW = parseFloat(((1 * qacLimit / qacMaxSetCmd) * 100).toFixed(3));\n            pvQacW = 1 * pvQac;\n            if (case4ZEPF >= caseReset) {\n                case4ZEPF = 0;\n                flow.set('case4ZEPF', case4ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.4.2\"\n                const logMessagePF = `5.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n            } else {\n                case4ZEPF++;\n                flow.set('case4ZEPF', case4ZEPF);\n                msg.qacLimitMWrite = qacLimitW * 10;\n                msg.caseq = \"5.4.3\"\n                const logMessagePF = `5.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvPF(logMessagePF);\n\n            }\n        }\n    } else {\n        qacLimitW = qacLimitW\n        if (case5ZEPF >= caseReset) {\n            case5ZEPF = 0;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimitW * 10;\n            msg.caseq = \"5.5.0\"\n            const logMessagePF = `5.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvPF(logMessagePF);\n        } else {\n            case5ZEPF++;\n            flow.set('case5ZEPF', case5ZEPF);\n            msg.qacLimitMWrite = qacLimitW * 10;\n            msg.caseq = \"5.5.1\"\n            const logMessagePF = `5.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvPF(logMessagePF);\n\n        }\n    }\n}\n\n// ------------------------------------------------------ Power Factor Logic End -----------------------------------------------------------------------------\n\n// ------------------------------------------------------ Voltage Control Logic Start -------------------------------------------------------------------------\nif (!isNaN(zeUac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && (uaconoffcmd === 1 || lvrtHvrtOnOffCmd === 1 )) {\n    \n    if (uaconoffcmd == 1 && lvrtHvrtOnOffCmd == 1) {\n        zeUThreshold = zeUThreshold;\n        zeUCriticalLoad = zeUCriticalLoad;\n    }\n\n    if (uaconoffcmd == 0 && lvrtHvrtOnOffCmd == 1) {\n        zeUThreshold = zelvrthvrtThreshold;\n        zeUCriticalLoad = zelvrthvrtCriticalLoad;\n    }\n\n    if (uaconoffcmd == 1 && lvrtHvrtOnOffCmd == 0) {\n        zeUThreshold = zeUThreshold;\n        zeUCriticalLoad = zeUCriticalLoad;\n    }\n    \n    ratedQCapacity = qacMaxSetCmd / 1000\n    \n\n    if (zeUac > (deadBandMax) && zeUac < droopMax && (zePf > zePfSetCmd || zePf < -zePfSetCmd)) {\n        if (zePac > 0 && uaconoffcmd === 1) {\n        qacMaxSet = (zeUac - deadBandMax) * (((-1) * (ratedQCapacity))/((ratedvoltage*droopPercentage)/100))\n        qacLimit = qacMaxSet * 1000\n        qacLimit = parseFloat(qacLimit.toFixed(0));\n\n        if (((-1)*qacLimit) > ratedQCapacity) { qacLimit = (-1*ratedQCapacity)}\n        if (qacLimit > ratedQCapacity) { qacLimit = (-1*ratedQCapacity)}\n\n        if (case1ZEU >= caseReset) {\n            case1ZEU = 0;\n            flow.set('case1ZEU', case1ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.1.0\"\n            const logMessageU = `3.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n        } else {\n            case1ZEU++;\n            flow.set('case1ZEU', case1ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.1.1 \"\n            const logMessageU = `3.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU); \n            } \n        }\n    }\n\n    // case 2\n    else if (zeUac < (deadBandMin) && zeUac > droopMin && (zePf > zePfSetCmd || zePf < -zePfSetCmd)) {\n        if (zePac > 0 && uaconoffcmd === 1) {\n        qacMaxSet = (zeUac - deadBandMax) * (((-1) * (ratedQCapacity)) / ((ratedvoltage * droopPercentage) / 100))\n        qacLimit = qacMaxSet * 1000\n        qacLimit = parseFloat(qacLimit.toFixed(0));\n\n        if (((-1) * qacLimit) > ratedQCapacity) { qacLimit = (ratedQCapacity) }\n        if (qacLimit > ratedQCapacity) { qacLimit = (ratedQCapacity) }\n\n        if (case2ZEU >= caseReset) {\n            case2ZEU = 0;\n            flow.set('case2ZEU', case2ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.2.0\"\n            const logMessageU = `3.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n        } else {\n            case2ZEU++;\n            flow.set('case2ZEU', case2ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.2.1 \"\n            const logMessageU = `3.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n             }\n        }\n    }\n\n   // case 3 \n    else if ((zePac > 0) && (zeUac > deadBandMin) && (zeUac < deadBandMax)) {\n        if (zePac > 0 && uaconoffcmd === 1) {\n            qacMaxSet = 0\n            qacLimit = qacMaxSet * 1000\n\t\t\n            if (case3ZEU >= caseReset) {\n            case3ZEU = 0;\n            flow.set('case3ZEU', case3ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.3.0\"\n            const logMessageU = `3.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n        } else {\n            case3ZEU++;\n            flow.set('case3ZEU', case3ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.3.1 \"\n            const logMessageU = `3.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU); }\n        }\n    } \n\n // case 4\n    else if (zeUac >= (zeUMinLoad - zeUThreshold) && zeUac <= (zeUMinLoad + zeUThreshold) && (zePf > zePfSetCmd || zePf < -zePfSetCmd)) {\n        //node.warn(`inside,${zeUMinLoad - zeUThreshold}`)\n        if (zeUac > zeUMinLoad && maxQacLimit < 0) {\n            qacLimit = parseFloat(maxQacLimit + quTuneStCmd);\n\t\t\tqacLimitW = (qacLimit * (qacMaxSetCmd / 100)).toFixed(2);\n            if (case6ZEU >= caseReset) {\n            case6ZEU = 0;\n            flow.set('case6ZEU', case6ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.6.0\"\n            const logMessageU = `3.6.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n        } else {\n            case6ZEU++;\n            flow.set('case6ZEU', case6ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.6.1 \"\n            const logMessageU = `3.6.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU); }\n        } else if (zeUac < zeUMinLoad && maxQacLimit > 0) {\n            qacLimit = parseFloat(maxQacLimit - quTuneStCmd);\n\t\t\tqacLimitW = (qacLimit * (qacMaxSetCmd / 100)).toFixed(2);\n            if (case6ZEU >= caseReset) {\n            case6ZEU = 0;\n            flow.set('case6ZEU', case6ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.6.2\"\n            const logMessageU = `3.6.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n        } else {\n            case6ZEU++;\n            flow.set('case6ZEU', case6ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.6.3 \"\n            const logMessageU = `3.6.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU); }\n        } else {\n            case6ZEU++;\n            flow.set('case6ZEU', case6ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.6.4 \"\n            const logMessageU = `3.6.4,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n        }\n    }\n\n// case 5 \n     else {\n\t\t\tqacLimit = qacLimit\n            case5ZEU++;\n            flow.set('case5ZEU', case5ZEU);\n            msg.qacLimitMWrite = qacLimit * 10;\n            msg.caseq = \"3.5.0 \"\n            const logMessageU = `3.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvU(logMessageU);\n        }\n    }\n// ------------------------------------------------------- Voltage Control Logic End -----------------------------------------------------------------------------------\n\n// --------------------------------------------------------Frequency Control Logic Start --------------------------------------------------------------------------------\nif (!isNaN(zeFac) && powselcmd === 1 && inverterOnline > 0 && fonoffcmd === 1 && faconoffcmd === 1 ) {\n // Case 1\n if (zeFac > (zeFMinLoad + zeFThreshold) && zeFac <= (zeFMinLoad + zeFCriticalLoad) && maxPacLimit > 0 && zeIac < zeIacSetCmd) {\n     let delF = zeFac - zeFMinLoad;\n     pacLimit = ((pacMaxSetCmd + (((-1 * delF * pacMaxSetCmd) / (zeFMinLoad * fDroopCmd)) * 100))) / ((100 - facGRSetCmd) / 100);\n     if (pacLimit <= 0) pacLimit = 0;\n     pacLimit = parseFloat(pacLimit.toFixed(1));\n     oldPacLimit = parseFloat(maxPacLimit.toFixed(1));\n     if (oldPacLimit <= pacLimit) {\n         pacLimitdel = oldPacLimit - parseFloat((facDecConstCmd * pacMaxSetCmd / 1000).toFixed(1));\n\t\t if (pacLimitdel <= (pacLimit * ((100 - facGRSetCmd) / 100))) {\n                         pacLimit = pacLimit * ((100 - facGRSetCmd) / 100);\n                     } else {\n                         pacLimit = pacLimitdel;\n                     }\n\t\t pacLimit = parseFloat(pacLimit.toFixed(1));\n        if (case1ZEF >= caseReset) {\n            case1ZEF = 0;\n            flow.set('case1ZEF', case1ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.1.0\"\n            const logMessageF = `4.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case1ZEF++;\n            flow.set('case1ZEF', case1ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.1.1 \"\n            const logMessageF = `4.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n     } else {\n\t\t  if (pacLimit <= 0) pacLimit = 0;\n\t\t  pacLimit = parseFloat(pacLimit.toFixed(1));\n          if (case1ZEF >= caseReset) {\n            case1ZEF = 0;\n            flow.set('case1ZEF', case1ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.1.2\"\n            const logMessageF = `4.1.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case1ZEF++;\n            flow.set('case1ZEF', case1ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.1.3 \"\n            const logMessageF = `4.1.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n     }\n }\n // Case 2\n else if (zeFac < (zeFMinLoad - zeFThreshold) && zeFac >= (zeFMinLoad - zeFCriticalLoad) && minPacLimit <= pacMaxSetCmd && zeIac < zeIacSetCmd) {\n     let delF = zeFac - zeFMinLoad;\n     pacLimit = ((pacMaxSetCmd + (((-1 * delF * pacMaxSetCmd) / (zeFMinLoad * fDroopCmd)) * 100))) / ((100 - facGRSetCmd) / 100);\n     //node.warn(`limit,${pacLimit}`)\n     if (pacLimit > pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n     pacLimit = parseFloat(pacLimit.toFixed(1));\n     oldPacLimit = parseFloat(minPacLimit.toFixed(1));\n     if (oldPacLimit >= pacLimit) {\n         pacLimitdel = oldPacLimit + parseFloat((facIncConstCmd * pacMaxSetCmd / 1000).toFixed(1));\n\t\t if (pacLimitdel >= (pacLimit / ((100 - facGRSetCmd) / 100))) {\n                         pacLimit = pacLimit / ((100 - facGRSetCmd) / 100);\n                     } else {\n                         pacLimit = pacLimitdel;\n                     }\n\t\tpacLimit = parseFloat(pacLimit.toFixed(1));\n         if (case2ZEF >= caseReset) {\n            case2ZEF = 0;\n            flow.set('case2ZEF', case2ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.2.0\"\n            const logMessageF = `4.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case2ZEF++;\n            flow.set('case2ZEF', case2ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.2.1 \"\n            const logMessageF = `4.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n     } else {\n\t\t  if (pacLimit <= 0) pacLimit = 0;\n\t\t  pacLimit = parseFloat(pacLimit.toFixed(1));\n          if (case2ZEF >= caseReset) {\n            case2ZEF = 0;\n            flow.set('case2ZEF', case2ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.2.2\"\n            const logMessageF = `4.2.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case2ZEF++;\n            flow.set('case2ZEF', case2ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.2.3 \"\n            const logMessageF = `4.2.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n     }\n }\n // Case 3\n else if (zeFac >= (zeFMinLoad - zeFLCriticalLoad) && zeFac < (zeFMinLoad - zeFCriticalLoad) && maxPacLimit <= pacMaxSetCmd && zeIac < zeIacSetCmd) {\n         pacLimit = pacMaxSetCmd + (0.5 * pacMaxSetCmd);\n     pacLimit = parseFloat(pacLimit.toFixed(1));\n     if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n        if (case3ZEF >= caseReset) {\n            case3ZEF = 0;\n            flow.set('case3ZEF', case3ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.3.0\"\n            const logMessageF = `4.3.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case3ZEF++;\n            flow.set('case3ZEF', case3ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.3.1 \"\n            const logMessageF = `4.3.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n }\n\n // Case 4\n else if (zeFac <= (zeFMinLoad + zeFLCriticalLoad) && zeFac > (zeFMinLoad + zeFCriticalLoad) && minPacLimit <= pacMaxSetCmd && zeIac < zeIacSetCmd) {\n      pacLimit = pacMaxSetCmd - (0.5 * pacMaxSetCmd);\n     pacLimit = parseFloat(pacLimit.toFixed(1));\n    //node.warn(`ch,${pacLimit}`);  \n     if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n             if (case4ZEF >= caseReset) {\n            case4ZEF = 0;\n            flow.set('case4ZEF', case4ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.3.2\"\n            const logMessageF = `4.3.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case4ZEF++;\n            flow.set('case4ZEF', case4ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.3.3 \"\n            const logMessageF = `4.3.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); } \n }\n// case 5 : Current Case\n else if ((zeIac >= zeIacSetCmd) && (maxPacLimit < pacMaxSetCmd)) {\n    if (zeIac > zeIacMaxCmd) {\n        let pacLimit = maxPacLimit - (facTuneStCmd * pacMaxSetCmd / 1000);\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n\t\tif (maxPacLimit <= 0) pacLimit = 0;\n\t\tpacLimit = parseFloat(pacLimit.toFixed(1));\n        if (case5ZEF >= caseReset) {\n            case5ZEF = 0;\n            flow.set('case5ZEF', case5ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.4.0\"\n            const logMessageF = `4.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case5ZEF++;\n            flow.set('case5ZEF', case5ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.4.1 \"\n            const logMessageF = `4.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n    }\n }\n// case 6: Deadband Case\n else if ((zeFac <= (zeFMinLoad + zeFThreshold)) && (zeFac >= (zeFMinLoad - zeFThreshold)) && (maxPacLimit <= pacMaxSetCmd) && (zeIac < zeIacSetCmd)) {\n    let pacLimit = minPacLimit + (0.9 * pacMaxSetCmd);\n    pacLimit = parseFloat(pacLimit.toFixed(1));\n    if (pacLimit >= pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n\tpacLimit = parseFloat(pacLimit.toFixed(1));\n     if (case6ZEF >= caseReset) {\n            case6ZEF = 0;\n            flow.set('case6ZEF', case6ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.4.2\"\n            const logMessageF = `4.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n        } else {\n            case6ZEF++;\n            flow.set('case6ZEF', case6ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.4.3 \"\n            const logMessageF = `4.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF); }\n} else {\n\t\t\tcase7ZEF++;\n            flow.set('case7ZEF', case7ZEF);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"4.5.0 \"\n            const logMessageF = `4.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvF(logMessageF);\n}\n}\n// --------------------------------------------------------Frequency Control Logic End ----------------------------------------------------------------------------------\n\n// -------------------------------------------------------Voltage Droop Control Start ----------------------------------------------------------------------------------\n\n\n\n// ---------------------------------------- Ramp Control Logic Start -------------------------------------------------------\nif (!isNaN(zePac) && powselcmd == 1 && inverterOnline > 0 && fonoffcmd == 1 && rampOnOffCmd == 1) {\n    if (zePac >= (zePMinLoad + zePThreshold) && maxPacLimit > 0 && zeIac < zeIacSetCmd) {\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        let oldPacLimit = parseFloat(maxPacLimit.toFixed(1));\n        if (oldPacLimit <= pacLimit) {\n            pacLimit = oldPacLimit - parseFloat((rampDecconstCmd * pacMaxSetCmd / 1000).toFixed(1));\n            if (case1ZER >= caseReset) {\n                case1ZER = 0;\n                flow.set('case1ZER', case1ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.1.0 force down\"\n                const logMessageR = `6.1.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                msg.pacLimitMWrite = pacLimit;\n                case1ZER++;\n                flow.set('case1ZER', case1ZER);\n                msg.case = \"6.1.1 force down\"\n                const logMessageR = `6.1.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        } else {\n            if (case1ZER >= caseReset) {\n                case1ZER = 0;\n                flow.set('case1ZER', case1ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.1.2 force down\"\n                const logMessageR = `6.1.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                msg.pacLimitMWrite = pacLimit;\n                case1ZER++;\n                flow.set('case1ZER', case1ZER);\n                msg.case = \"6.1.3 force down\"\n                const logMessageR = `6.1.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n    }\n    // Case 2: < critical load\n    else if (zePac <= zePMinLoad - zePThreshold && minPacLimit < pacMaxSetCmd && zeIac < zeIacSetCmd) {\n        pacLimit = parseFloat(pacLimit.toFixed(1));\n        oldPacLimit = parseFloat(minPacLimit.toFixed(1));\n\n        if (oldPacLimit >= pacLimit) {\n            pacLimit = oldPacLimit + parseFloat((rampIncconstCmd * pacMaxSetCmd / 1000).toFixed(1));\n            if (pacLimit > pacMaxSetCmd) pacLimit = pacMaxSetCmd;\n            if (case2ZER >= caseReset) {\n                case2ZER = 0;\n                flow.set('case2ZER', case2ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.0 force UP\"\n                const logMessageR = `6.2.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case2ZER++;\n                flow.set('case2ZER', case2ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.1 force UP\"\n                const logMessageR = `6.2.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        } else {\n            if (case2ZER >= caseReset) {\n                case2ZER = 0;\n                flow.set('case2ZER', case2ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.2 force UP\"\n                const logMessageR = `6.2.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case2ZER++;\n                flow.set('case2ZER', case2ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.2.3 force UP\"\n                const logMessageR = `6.2.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n    }\n\n    // Case 4: ZEP meter > 0 & ZEP meter < minload no change\n    else if (zeIac >= zeIacSetCmd && maxPacLimit < pacMaxSetCmd) {\n        if (zeIac > zeIacMaxCmd) {\n            let pacLimit = maxPacLimit - (rampTuneStCmd * pacMaxSetCmd / 1000);\n            pacLimit = parseFloat(pacLimit.toFixed(1));\n            if (case4ZER >= caseReset) {\n                case4ZER = 0;\n                flow.set('case4ZER', case4ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.0 current\"\n                const logMessageR = `6.4.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case4ZER++;\n                flow.set('case4ZER', case4ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.1 current\"\n                const logMessageR = `6.4.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n        else {\n            pacLimit = pacLimit\n            if (case4ZER >= caseReset) {\n                case4ZER = 0;\n                flow.set('case4ZER', case4ZER);\n                if (pacLimit <= 2) pacLimit = 2;\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.2 current\"\n                const logMessageR = `6.4.2,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            } else {\n                case4ZER++;\n                flow.set('case4ZER', case4ZER);\n                msg.pacLimitMWrite = pacLimit;\n                msg.case = \"6.4.3 current\"\n                const logMessageR = `6.4.3,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n                logCsvR(logMessageR);\n            }\n        }\n    }\n    // Case 5: Stable\n    else if ((zePac <= zePMinLoad + zePThreshold && zePac >= zePMinLoad - zePThreshold || maxPacLimit <= pacMaxSetCmd) && zeIac < zeIacSetCmd) {\n        pacLimit = pacLimit\n        if (case5ZER >= caseReset) {\n            case5ZER = 0;\n            flow.set('case5ZER', case5ZER);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"6.5.0 stable\"\n            const logMessageR = `6.5.0,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvR(logMessageR);\n        } else {\n            case5ZER++;\n            flow.set('case5ZER', case5ZER);\n            msg.pacLimitMWrite = pacLimit;\n            msg.case = \"6.5.1 stable\"\n            const logMessageR = `6.5.1,${zePac},${zeQac},${zePf},${zeUac},${zeFac},${pvPac},${pvQacW},${oldPacLimit},${oldQacLimitW},${pacLimit},${qacLimitW},`;\n            logCsvR(logMessageR);\n        }\n    }\n}\n// ------------------------------------------ Ramp Control Logic End -------------------------------------------------------------------------------\n\n// Save the pacLimit if it has been modified\nif (msg.pacLimitMWrite !== undefined) {\n       //node.warn(\"pacLimitMWrite was not set, setting default to Max limit\");\n   // msg.pacLimitMWrite = 1000; // Setting a default value if none of the conditions met\n    //msg.case = \"Default Case: pacLimitMWrite was not set explicitly\";\n     global.set(`PAC_LIMIT_CMD`, msg.pacLimitMWrite);\n}\n\n// Save the qacLimit if it has been modified\nif (msg.qacLimitMWrite !== undefined) {\n    global.set(`QAC_LIMIT_CMD`, msg.qacLimitMWrite);  \n} else {\n    //node.warn(\"qacLimitMWrite was not set, setting default to 0\");\n    msg.qacLimitMWrite = 0; // Setting a default value if none of the conditions met\n    //msg.caseq = \"Default Case: qacLimitMWrite was not set explicitly\";\n}\n\n//node.warn(`Final pacLimitMWrite: ${msg.pacLimitMWrite}, Case: ${msg.case}`);\n//node.warn(`Final qacLimitMWrite: ${msg.qacLimitMWrite}, Case: ${msg.caseq}`);\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 470,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "73a11b0df899230d",
        "type": "inject",
        "z": "11aec64be1c40451",
        "d": true,
        "name": "",
        "props": [],
        "repeat": "0.1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 140,
        "wires": [
            [
                "1ed680b5b7d75b4e"
            ]
        ]
    },
    {
        "id": "1ed680b5b7d75b4e",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "function 665",
        "func": "global.set (\"QAC_LIMIT_CMD\",0)\nglobal.set (\"PAC_LIMIT_CMD\",200000)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "bde1479a31221e4b",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 420,
        "wires": [
            [
                "f0b3f684795d1cd5"
            ]
        ]
    },
    {
        "id": "f0b3f684795d1cd5",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "215.6",
        "func": "global.set(\"SIM_VOLT\",215.6)\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "081f58ad06997031",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 460,
        "wires": [
            [
                "0995c022f41520a4"
            ]
        ]
    },
    {
        "id": "0995c022f41520a4",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "138.60",
        "func": "global.set(\"SIM_VOLT\",13860)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "2b9f8cea8555d73a",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 620,
        "wires": [
            [
                "d488de15e27e8606"
            ]
        ]
    },
    {
        "id": "d488de15e27e8606",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "128.04",
        "func": "global.set(\"SIM_VOLT\",12804)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "adbb3be7245448d5",
        "type": "comment",
        "z": "11aec64be1c40451",
        "name": "Deadband_Voltage",
        "info": "",
        "x": 130,
        "y": 200,
        "wires": []
    },
    {
        "id": "dc640d64e0732596",
        "type": "comment",
        "z": "11aec64be1c40451",
        "name": "Over _Voltage",
        "info": "",
        "x": 90,
        "y": 280,
        "wires": []
    },
    {
        "id": "5cef4076ca113d97",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 380,
        "wires": [
            [
                "9756fdd82b77a80e"
            ]
        ]
    },
    {
        "id": "9756fdd82b77a80e",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "220",
        "func": "global.set(\"SIM_VOLT\",220)\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "db3af6bce67298a3",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 340,
        "wires": [
            [
                "237c7dbc72473ee4"
            ]
        ]
    },
    {
        "id": "237c7dbc72473ee4",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "224.4",
        "func": "global.set(\"SIM_VOLT\",224.4)\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "563e659e7fe643a9",
        "type": "comment",
        "z": "11aec64be1c40451",
        "name": "Under _Voltage",
        "info": "",
        "x": 120,
        "y": 520,
        "wires": []
    },
    {
        "id": "39bfeb0a095a3cf5",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 580,
        "wires": [
            [
                "92908583dc5a5e37"
            ]
        ]
    },
    {
        "id": "92908583dc5a5e37",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "32.34",
        "func": "global.set(\"SIM_VOLT\",32.34)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "3d3773b4f522ad47",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 110,
        "y": 660,
        "wires": [
            [
                "28dbbf211448632f"
            ]
        ]
    },
    {
        "id": "28dbbf211448632f",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "125.40",
        "func": "global.set(\"SIM_VOLT\",12540)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "0e52fbb7f631f4af",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 260,
        "wires": [
            [
                "d63e319e2f57b263"
            ]
        ]
    },
    {
        "id": "d63e319e2f57b263",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50Hz",
        "func": "global.set(\"SIM_FREQ\",5000)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "736fe81f2d971855",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 300,
        "wires": [
            [
                "1632c1c53ede6c5c"
            ]
        ]
    },
    {
        "id": "1632c1c53ede6c5c",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50.03Hz",
        "func": "global.set(\"SIM_FREQ\",5003)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 300,
        "wires": [
            []
        ]
    },
    {
        "id": "3b61efc7230536d0",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 640,
        "wires": [
            [
                "ee3f4ccb8fc2a668"
            ]
        ]
    },
    {
        "id": "ee3f4ccb8fc2a668",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.90Hz",
        "func": "global.set(\"SIM_FREQ\",4990)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "2c5b7fb1285b3396",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 600,
        "wires": [
            [
                "c03cb8a2061c7a19"
            ]
        ]
    },
    {
        "id": "c03cb8a2061c7a19",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.97Hz",
        "func": "global.set(\"SIM_FREQ\",4997)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "4272c0ebad90e5c5",
        "type": "comment",
        "z": "11aec64be1c40451",
        "name": "Droop_Case_Over_Frequency",
        "info": "",
        "x": 570,
        "y": 200,
        "wires": []
    },
    {
        "id": "ef150e30c223941e",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 420,
        "wires": [
            [
                "745d1dd934fc01c2"
            ]
        ]
    },
    {
        "id": "745d1dd934fc01c2",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50.30Hz",
        "func": "global.set(\"SIM_FREQ\",5030)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "8f126ab4bf3c0119",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 340,
        "wires": [
            [
                "8a366fdf8b40bc53"
            ]
        ]
    },
    {
        "id": "8a366fdf8b40bc53",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50.1Hz",
        "func": "global.set(\"SIM_FREQ\",5010)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "0cff35f289f69323",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 380,
        "wires": [
            [
                "21488d925acb6a01"
            ]
        ]
    },
    {
        "id": "21488d925acb6a01",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50.15Hz",
        "func": "global.set(\"SIM_FREQ\",5015)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "b221f73237d6412a",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 460,
        "wires": [
            [
                "9c03dbeb19a818ec"
            ]
        ]
    },
    {
        "id": "9c03dbeb19a818ec",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50.50Hz",
        "func": "global.set(\"SIM_FREQ\",5050)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "924dff9375578635",
        "type": "comment",
        "z": "11aec64be1c40451",
        "name": "Droop_Case_Under_Frequency",
        "info": "",
        "x": 1510,
        "y": 800,
        "wires": []
    },
    {
        "id": "cd194f6aaef4de49",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1450,
        "y": 860,
        "wires": [
            [
                "b84961c9b7508e69"
            ]
        ]
    },
    {
        "id": "b84961c9b7508e69",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.95Hz",
        "func": "global.set(\"SIM_FREQ\",4995)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "4684c3b5ebf59fd2",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1450,
        "y": 900,
        "wires": [
            [
                "092ed02291e56c60"
            ]
        ]
    },
    {
        "id": "092ed02291e56c60",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.9Hz",
        "func": "global.set(\"SIM_FREQ\",4990)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 900,
        "wires": [
            []
        ]
    },
    {
        "id": "130233ca5cf684cf",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1450,
        "y": 940,
        "wires": [
            [
                "d6ac0be3152ff0ee"
            ]
        ]
    },
    {
        "id": "d6ac0be3152ff0ee",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.8Hz",
        "func": "global.set(\"SIM_FREQ\",4980)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 940,
        "wires": [
            []
        ]
    },
    {
        "id": "7a170f653b83220f",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1450,
        "y": 980,
        "wires": [
            [
                "de82eb48e5bc4780"
            ]
        ]
    },
    {
        "id": "de82eb48e5bc4780",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.5Hz",
        "func": "global.set(\"SIM_FREQ\",4950)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 980,
        "wires": [
            []
        ]
    },
    {
        "id": "584ce56cd3dd34de",
        "type": "comment",
        "z": "11aec64be1c40451",
        "name": "Step_Case_Over_Frequency",
        "info": "",
        "x": 580,
        "y": 540,
        "wires": []
    },
    {
        "id": "5de042e0f0d58d3b",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 680,
        "wires": [
            [
                "2863450ddadadf2a"
            ]
        ]
    },
    {
        "id": "2863450ddadadf2a",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.85Hz",
        "func": "global.set(\"SIM_FREQ\",4985)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 680,
        "wires": [
            []
        ]
    },
    {
        "id": "bed4701e5264925e",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 720,
        "wires": [
            [
                "2bc4c7713ebcf21e"
            ]
        ]
    },
    {
        "id": "2bc4c7713ebcf21e",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.70Hz",
        "func": "global.set(\"SIM_FREQ\",4970)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "52382b253243a423",
        "type": "comment",
        "z": "11aec64be1c40451",
        "name": "Step_Case_Under_Frequency",
        "info": "",
        "x": 1220,
        "y": 780,
        "wires": []
    },
    {
        "id": "f3fc36e231419e9c",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 550,
        "y": 760,
        "wires": [
            [
                "204fd0274c6c8d87"
            ]
        ]
    },
    {
        "id": "204fd0274c6c8d87",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.5Hz",
        "func": "global.set(\"SIM_FREQ\",4950)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "5552acfcc8f86c6c",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1170,
        "y": 880,
        "wires": [
            [
                "be67b6021bc98255"
            ]
        ]
    },
    {
        "id": "be67b6021bc98255",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "48Hz",
        "func": "global.set(\"SIM_FREQ\",4800)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1330,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "2e9ef8242c8fc746",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1010,
        "y": 260,
        "wires": [
            [
                "7524fdc228fe5c14"
            ]
        ]
    },
    {
        "id": "7524fdc228fe5c14",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50Hz",
        "func": "global.set(\"SIM_FREQ\",5000)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "e722b939dc26bd15",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1010,
        "y": 540,
        "wires": [
            [
                "0a4fbac9e66469a9"
            ]
        ]
    },
    {
        "id": "0a4fbac9e66469a9",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50.03Hz",
        "func": "global.set(\"SIM_FREQ\",5003)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "a2e39edfd1283a62",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1010,
        "y": 620,
        "wires": [
            [
                "cdc74a8192ee323c"
            ]
        ]
    },
    {
        "id": "cdc74a8192ee323c",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "50.06Hz",
        "func": "global.set(\"SIM_FREQ\",5006)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "114867a706c67931",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1010,
        "y": 460,
        "wires": [
            [
                "3dcf526c59c962a1"
            ]
        ]
    },
    {
        "id": "3dcf526c59c962a1",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.94Hz",
        "func": "global.set(\"SIM_FREQ\",4994)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "7e4673487bb9f89e",
        "type": "inject",
        "z": "11aec64be1c40451",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1010,
        "y": 380,
        "wires": [
            [
                "eccef297c6456714"
            ]
        ]
    },
    {
        "id": "eccef297c6456714",
        "type": "function",
        "z": "11aec64be1c40451",
        "name": "49.97Hz",
        "func": "global.set(\"SIM_FREQ\",4997)\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "96094fc9f5efa4e3",
        "type": "inject",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": "20",
        "topic": "",
        "x": 190,
        "y": 200,
        "wires": [
            [
                "4822620155dd3b83"
            ]
        ]
    },
    {
        "id": "37d74194d7301759",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    var value = val * msg.payload[i].payload.topic.mf\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "fdbb12fc0a0c8b82",
        "type": "join",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "11",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1070,
        "y": 200,
        "wires": [
            [
                "37d74194d7301759"
            ]
        ]
    },
    {
        "id": "b4d640bbb7acfba7",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 200,
        "wires": [
            [
                "a567c7b11e2b064a",
                "fd1584fe6fb4e127"
            ]
        ]
    },
    {
        "id": "ea61ce8c309d4463",
        "type": "csv",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 430,
        "y": 200,
        "wires": [
            [
                "b4d640bbb7acfba7"
            ]
        ]
    },
    {
        "id": "4822620155dd3b83",
        "type": "template",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,13696,L32,3,1,8,13696,L32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,PAC,Active_Power,Server8782,8782,1,Truboard,0,new,MW,0.001,y\n2,13698,L32,3,1,2,13698,L32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,QAC,Reactive_Power,Server8782,8782,1,Truboard,0,,MVAr,0.001,n\n3,13702,L32,3,1,2,13702,L32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,PF,Power_Factor,Server8782,8782,1,Truboard,0,,,0.001,n\n4,13700,L32,3,1,2,13696,L32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,SAC,Apparent_Power,Server8782,8782,1,Truboard,0,new,MW,0.001,n\n5,13372,L32,3,1,6,13372,L32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,UAC12,Voltage_RY,Server8782,8782,1,Truboard,0,,kV,0.001,y\n6,13374,L32,3,1,2,13374,L32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,UAC23,Voltage_YB,Server8782,8782,1,Truboard,0,,kV,0.001,n\n7,13376,L32,3,1,2,13376,L32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,UAC31,Voltage_BR,Server8782,8782,1,Truboard,0,,kV,0.001,n\n8,13828,L32,3,1,2,13828,U32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,FAC,Frequency,Server8782,8782,1,Truboard,0,,Hz,0.01,y\n9,13318,L32,3,1,6,13318,U32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,IAC1,Current_R,Server8782,8782,1,Truboard,0,,A,1,y\n10,13320,L32,3,1,2,13320,U32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,IAC2,Current_Y,Server8782,8782,1,Truboard,0,,A,1,n\n11,13322,L32,3,1,2,13322,U32,MCR,MAIN_CR,EM01,PLANT,ENERGY_METER,IAC3,Current_B,Server8782,8782,1,Truboard,0,,A,1,n",
        "output": "str",
        "x": 310,
        "y": 200,
        "wires": [
            [
                "ea61ce8c309d4463"
            ]
        ]
    },
    {
        "id": "0477b598e74358e0",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "msg",
        "func": "var obj = {}\nif (msg.error == \"Error: Timed out\") {\n  var value = \"NaN\";\n  var tag = msg.topic.topic.b + \".\" + msg.topic.topic.d + \".\" + \"COMM\" \n  global.set(tag, 0);\n  for (var j = 0; j < msg.topic.error.length; j++) {\n\n\n    obj.payload =\n    {\n      value: value,\n      topic: msg.topic.error[j]\n    }\n    node.send(obj)\n  }\n\n}\nelse {\n\n  if (Array.isArray(msg.payload.results)) {\n    var tag =  msg.topic.topic.b + \".\" + msg.topic.topic.d  + \".\" + \"COMM\"\n    global.set(tag, 1);\n    for (var i = 0; i < msg.topic.error.length; i++) {\n      for (var k = 0; k < msg.payload.results.length; k++) {\n        if (msg.payload.results[k].address == msg.topic.error[i].read_reg_id) {\n          obj.payload = {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n          node.send(obj)\n        }\n\n      }\n\n\n\n    }\n\n  }\n  else {\n    obj.payload = {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n    node.send(obj)\n\n  }\n\n\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 200,
        "wires": [
            [
                "fdbb12fc0a0c8b82"
            ]
        ]
    },
    {
        "id": "486e599ed79766d4",
        "type": "comment",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "SETEC_PQM_130EH_Plus - Line 1",
        "info": "",
        "x": 260,
        "y": 120,
        "wires": []
    },
    {
        "id": "a567c7b11e2b064a",
        "type": "Main-Modbus-Read-Write",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "showStatusActivities": true,
        "showErrors": true,
        "showWarnings": true,
        "server": "0b96cb9d434d59c0",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 750,
        "y": 200,
        "wires": [
            [
                "0477b598e74358e0"
            ],
            []
        ]
    },
    {
        "id": "fd1584fe6fb4e127",
        "type": "debug",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "debug 3195",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 710,
        "y": 160,
        "wires": []
    },
    {
        "id": "1349b8f032394075",
        "type": "template",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,13696,L32,3,1,8,13696,L32,CR,CR_EM01,EM01,EM01,EM,PAC,PAC,Server8582,8582,1,iplon_test,0,new,MW,0.001,y\n2,13698,L32,3,1,2,13698,L32,CR,CR_EM01,EM01,EM01,EM,QAC,QAC,Server8582,8582,1,iplon_test,,,MVAr,0.001,n\n3,13702,L32,3,1,2,13702,L32,CR,CR_EM01,EM01,EM01,EM,PF,PF,Server8582,8582,1,iplon_test,,,,0.001,n\n11,13700,L32,3,1,2,13696,L32,CR,CR_EM01,EM01,EM01,EM,SAC,SAC,Server8582,8582,1,iplon_test,0,new,MW,0.001,n\n4,13372,L32,3,1,6,13372,L32,CR,CR_EM01,EM01,EM01,EM,UAC12,UAC12,Server8582,8582,1,iplon_test,,,kV,0.001,y\n5,13374,L32,3,1,2,13374,L32,CR,CR_EM01,EM01,EM01,EM,UAC23,UAC23,Server8582,8582,1,iplon_test,,,kV,0.001,n\n6,13376,L32,3,1,2,13376,L32,CR,CR_EM01,EM01,EM01,EM,UAC31,UAC31,Server8582,8582,1,iplon_test,,,kV,0.001,n\n7,13828,L32,3,1,2,13828,U32,CR,CR_EM01,EM01,EM01,EM,FAC,FAC,Server8582,8582,1,iplon_test,,,Hz,0.01,y\n8,13318,L32,3,1,6,13318,U32,CR,CR_EM01,EM01,EM01,EM,IAC1,IAC1,Server8582,8582,1,iplon_test,,,A,1,y\n9,13320,L32,3,1,2,13320,U32,CR,CR_EM01,EM01,EM01,EM,IAC2,IAC2,Server8582,8582,1,iplon_test,,,A,1,n\n10,13322,L32,3,1,2,13322,U32,CR,CR_EM01,EM01,EM01,EM,IAC3,IAC3,Server8582,8582,1,iplon_test,,,A,1,n\n",
        "output": "str",
        "x": 310,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "f11552b81b0b945d",
        "type": "function",
        "z": "4b39492785a70ee0",
        "name": "function 728",
        "func": "let obj = global.get(\"COMM\")\nlet total = 0;\nfor (const block in obj) {\n    for (const inverter in obj[block]) {\n        total += obj[block][inverter];\n    }\n}\nglobal.set(\"INV_ONLINE\",total)\n\n//msg.payload = total\n//return msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "b4673908a394c833",
        "type": "inject",
        "z": "4b39492785a70ee0",
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 60,
        "wires": [
            [
                "f11552b81b0b945d"
            ]
        ]
    },
    {
        "id": "b4132fc61efb6b69",
        "type": "inject",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": "20",
        "topic": "",
        "x": 190,
        "y": 320,
        "wires": [
            [
                "15e394cd5841fb46"
            ]
        ]
    },
    {
        "id": "8de1850f5dd7a6c6",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    var value = val * msg.payload[i].payload.topic.mf\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "8c04ece3f20a202e",
        "type": "join",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "11",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1070,
        "y": 320,
        "wires": [
            [
                "8de1850f5dd7a6c6"
            ]
        ]
    },
    {
        "id": "a6b1eb06764e7070",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 320,
        "wires": [
            [
                "5e832def27c0c32c"
            ]
        ]
    },
    {
        "id": "77d6b1485d0adb94",
        "type": "csv",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 430,
        "y": 320,
        "wires": [
            [
                "a6b1eb06764e7070"
            ]
        ]
    },
    {
        "id": "15e394cd5841fb46",
        "type": "template",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,13696,L32,3,1,8,13696,L32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,PAC,Active_Power,Server8782,8782,1,Truboard,0,new,MW,0.001,y\n2,13698,L32,3,1,2,13698,L32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,QAC,Reactive_Power,Server8782,8782,1,Truboard,0,,MVAr,0.001,n\n3,13702,L32,3,1,2,13702,L32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,PF,Power_Factor,Server8782,8782,1,Truboard,0,,,0.001,n\n4,13700,L32,3,1,2,13696,L32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,SAC,Apparent_Power,Server8782,8782,1,Truboard,0,new,MW,0.001,n\n5,13372,L32,3,1,6,13372,L32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,UAC12,Voltage_RY,Server8782,8782,1,Truboard,0,,kV,0.001,y\n6,13374,L32,3,1,2,13374,L32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,UAC23,Voltage_YB,Server8782,8782,1,Truboard,0,,kV,0.001,n\n7,13376,L32,3,1,2,13376,L32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,UAC31,Voltage_BR,Server8782,8782,1,Truboard,0,,kV,0.001,n\n8,13828,L32,3,1,2,13828,U32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,FAC,Frequency,Server8782,8782,1,Truboard,0,,Hz,0.01,y\n9,13318,L32,3,1,6,13318,U32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,IAC1,Current_R,Server8782,8782,1,Truboard,0,,A,1,y\n10,13320,L32,3,1,2,13320,U32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,IAC2,Current_Y,Server8782,8782,1,Truboard,0,,A,1,n\n11,13322,L32,3,1,2,13322,U32,MCR,MAIN_CR,EM02,PLANT,ENERGY_METER,IAC3,Current_B,Server8782,8782,1,Truboard,0,,A,1,n",
        "output": "str",
        "x": 310,
        "y": 320,
        "wires": [
            [
                "77d6b1485d0adb94"
            ]
        ]
    },
    {
        "id": "0aeb8086ddc12feb",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "msg",
        "func": "var obj = {}\nif (msg.error == \"Error: Timed out\") {\n  var value = \"NaN\";\n  var tag = msg.topic.topic.b + \".\" + msg.topic.topic.d + \".\" + \"COMM\" \n  global.set(tag, 0);\n  for (var j = 0; j < msg.topic.error.length; j++) {\n\n\n    obj.payload =\n    {\n      value: value,\n      topic: msg.topic.error[j]\n    }\n    node.send(obj)\n  }\n\n}\nelse {\n\n  if (Array.isArray(msg.payload.results)) {\n    var tag =  msg.topic.topic.b + \".\" + msg.topic.topic.d  + \".\" + \"COMM\"\n    global.set(tag, 1);\n    for (var i = 0; i < msg.topic.error.length; i++) {\n      for (var k = 0; k < msg.payload.results.length; k++) {\n        if (msg.payload.results[k].address == msg.topic.error[i].read_reg_id) {\n          obj.payload = {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n          node.send(obj)\n        }\n\n      }\n\n\n\n    }\n\n  }\n  else {\n    obj.payload = {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n    node.send(obj)\n\n  }\n\n\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 320,
        "wires": [
            [
                "8c04ece3f20a202e"
            ]
        ]
    },
    {
        "id": "5e832def27c0c32c",
        "type": "Main-Modbus-Read-Write",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "",
        "showStatusActivities": true,
        "showErrors": true,
        "showWarnings": true,
        "server": "12e5b4a20ade9a35",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 750,
        "y": 320,
        "wires": [
            [
                "0aeb8086ddc12feb"
            ],
            []
        ]
    },
    {
        "id": "a40795473a414b38",
        "type": "comment",
        "z": "4b39492785a70ee0",
        "g": "05347136fb00c7d9",
        "name": "SETEC_PQM_130EH_Plus - Line 2",
        "info": "",
        "x": 240,
        "y": 260,
        "wires": []
    },
    {
        "id": "771553536fa6e867",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "influx",
        "func": "var time = new Date().getTime()\nvar obj = {}\nobj.payload = [{\n    measurement: \"v\",\n    fields: {\n        qu: 0,\n        text: \"\",\n        value: msg.payload.value\n    },\n    tags: {\n        b: msg.payload.b,\n        bd: msg.payload.bd,\n        d: msg.payload.d,\n        dd: msg.payload.dd,\n        dt: msg.payload.dt,\n        f: msg.payload.f,\n        fd: msg.payload.fd,\n        h: msg.payload.h,\n        iid: msg.payload.iid,\n        m: msg.payload.m,\n        p: msg.payload.p,\n        u: \"\"\n    },\n    timestamp: time,\n}];\nnode.send(obj)\nreturn null",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 480,
        "wires": [
            [
                "bcaba8d066cd2f1c"
            ]
        ]
    },
    {
        "id": "71c351d6db2e5069",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "function 516",
        "func": "var obj = {};\n//var obj1 = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    //let tag_arr = global.get(msg.payload[i].calculated_field)\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if(msg.payload[i].type == \"AVG\") {\n        var arr_length = arr.length\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        val = val / arr_length;\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if (msg.payload[i].type == \"GB_SETS\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if (msg.payload[i].type == \"GB_SETA\") {\n        var arr_length = arr.length\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        val = val / arr_length;\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    val = (val * msg.payload[i].mf);\n    val = parseFloat(val)\n\n    //obj1.payload = [{\n    //    tags: {\n    //        val1_field: arr[0],\n    //        val1: global.get(arr[0]),\n    //        val2_field: arr[1],\n    //        val2: global.get(arr[1])\n    //    }\n    //}];\n    //node.send(obj1)\n\n    obj.payload = {\n        value: val,\n        b: msg.payload[i].b,\n        bd: msg.payload[i].bd,\n        d: msg.payload[i].d,\n        dd: msg.payload[i].dd,\n        dt: msg.payload[i].dt,\n        f: msg.payload[i].f,\n        fd: msg.payload[i].fd,\n        h: msg.payload[i].h,\n        iid: msg.payload[i].iid,\n        m: msg.payload[i].m,\n        p: msg.payload[i].p,\n        qu: msg.payload[i].qu,\n        text: msg.payload[i].text,\n        u: msg.payload[i].u,\n        mf: msg.payload[i].mf\n    }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 480,
        "wires": [
            [
                "771553536fa6e867",
                "5c5dfd1214f6eb71"
            ]
        ]
    },
    {
        "id": "bcaba8d066cd2f1c",
        "type": "debug",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "debug 1437",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 950,
        "y": 480,
        "wires": []
    },
    {
        "id": "89b8caeb7bf75231",
        "type": "inject",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 480,
        "wires": [
            [
                "7c24b68999756557"
            ]
        ]
    },
    {
        "id": "7c24b68999756557",
        "type": "template",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,MCR.EM01.PAC+MCR.EM02.PAC,SUM,MCR,MAIN_CR,VR_EM,VR_EM,EM,PAC,PAC,Server8782,8782,1,Truboard,0,new,MW,0.001\n2,MCR.EM01.QAC+MCR.EM02.QAC,SUM,MCR,MAIN_CR,VR_EM,VR_EM,EM,QAC,QAC,Server8782,8782,1,Truboard,0,new,MVAr,0.001\n3,MCR.EM01.PF+MCR.EM02.PF,AVG,MCR,MAIN_CR,VR_EM,VR_EM,EM,PF,PF,Server8782,8782,1,Truboard,0,new,,0.001\n4,MCR.EM01.UAC12+MCR.EM01.UAC23+MCR.EM01.UAC31,GB_SETA,MCR,MAIN_CR,EM01,EM01,EM,UAC,UAC,Server8782,8782,1,Truboard,0,new,KV,1\n5,MCR.EM02.UAC12+MCR.EM02.UAC23+MCR.EM02.UAC31,GB_SETA,MCR,MAIN_CR,EM02,EM02,EM,UAC,UAC,Server8782,8782,1,Truboard,0,new,KV,1\n6,MCR.EM01.UAC+MCR.EM02.UAC,AVG,MCR,MAIN_CR,VR_EM,VR_EM,EM,UAC,UAC,Server8782,8782,1,Truboard,0,new,KV,0.01\n7,MCR.EM01.IAC1+MCR.EM01.IAC2+MCR.EM01.IAC3,GB_SETS,MCR,MAIN_CR,EM01,EM01,EM,IAC,IAC,Server8782,8782,1,Truboard,0,new,A,1\n8,MCR.EM02.IAC1+MCR.EM02.IAC2+MCR.EM02.IAC3,GB_SETS,MCR,MAIN_CR,EM02,EM02,EM,IAC,IAC,Server8782,8782,1,Truboard,0,new,A,1\n9,MCR.EM01.IAC+MCR.EM02.IAC,SUM,MCR,MAIN_CR,VR_EM,VR_EM,EM,IAC,IAC,Server8782,8782,1,Truboard,0,new,A,1\n10,MCR.EM01.FAC+MCR.EM02.FAC,AVG,MCR,MAIN_CR,VR_EM,VR_EM,EM,FAC,FAC,Server8782,8782,1,Truboard,0,new,Hz,0.01\n11,MCR.EM01.SAC+MCR.EM02.SAC,SUM,MCR,MAIN_CR,VR_EM,VR_EM,EM,SAC,SAC,Server8782,8782,1,Truboard,0,new,MW,0.001",
        "output": "str",
        "x": 320,
        "y": 480,
        "wires": [
            [
                "3a7ff75fe5885c37"
            ]
        ]
    },
    {
        "id": "3a7ff75fe5885c37",
        "type": "csv",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 470,
        "y": 480,
        "wires": [
            [
                "71c351d6db2e5069",
                "fef6f6558f828198"
            ]
        ]
    },
    {
        "id": "5c5dfd1214f6eb71",
        "type": "debug",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "debug 1438",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 790,
        "y": 520,
        "wires": []
    },
    {
        "id": "fef6f6558f828198",
        "type": "debug",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "debug 1441",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 610,
        "y": 520,
        "wires": []
    },
    {
        "id": "a447db7b7c32988e",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "influx",
        "func": "var time = new Date().getTime()\nvar obj = {}\nobj.payload = [{\n    measurement: \"v\",\n    fields: {\n        qu: 0,\n        text: \"\",\n        value: msg.payload.value\n    },\n    tags: {\n        b: msg.payload.b,\n        bd: msg.payload.bd,\n        d: msg.payload.d,\n        dd: msg.payload.dd,\n        dt: msg.payload.dt,\n        f: msg.payload.f,\n        fd: msg.payload.fd,\n        h: msg.payload.h,\n        iid: msg.payload.iid,\n        m: msg.payload.m,\n        p: msg.payload.p,\n        u: \"\"\n    },\n    timestamp: time,\n}];\nnode.send(obj)\nreturn null",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 600,
        "wires": [
            [
                "a9a60f45cfc5f6b4"
            ]
        ]
    },
    {
        "id": "061b018f3220f837",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "function 673",
        "func": "var obj = {};\n//var obj1 = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    //let tag_arr = global.get(msg.payload[i].calculated_field)\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if(msg.payload[i].type == \"AVG\") {\n        var arr_length = arr.length\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        val = val / arr_length;\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if (msg.payload[i].type == \"GB_SETS\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if (msg.payload[i].type == \"GB_SETA\") {\n        var arr_length = arr.length\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        val = val / arr_length;\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    val = (val * msg.payload[i].mf);\n    val = parseFloat(val)\n\n    //obj1.payload = [{\n    //    tags: {\n    //        val1_field: arr[0],\n    //        val1: global.get(arr[0]),\n    //        val2_field: arr[1],\n    //        val2: global.get(arr[1])\n    //    }\n    //}];\n    //node.send(obj1)\n\n    obj.payload = {\n        value: val,\n        b: msg.payload[i].b,\n        bd: msg.payload[i].bd,\n        d: msg.payload[i].d,\n        dd: msg.payload[i].dd,\n        dt: msg.payload[i].dt,\n        f: msg.payload[i].f,\n        fd: msg.payload[i].fd,\n        h: msg.payload[i].h,\n        iid: msg.payload[i].iid,\n        m: msg.payload[i].m,\n        p: msg.payload[i].p,\n        qu: msg.payload[i].qu,\n        text: msg.payload[i].text,\n        u: msg.payload[i].u,\n        mf: msg.payload[i].mf\n    }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 600,
        "wires": [
            [
                "a447db7b7c32988e",
                "c371db16c6ddfc63"
            ]
        ]
    },
    {
        "id": "b5cadf4d42acbf20",
        "type": "inject",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 600,
        "wires": [
            [
                "2215dc8e90fe8340"
            ]
        ]
    },
    {
        "id": "2215dc8e90fe8340",
        "type": "template",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B01_VR_INV.PAC+B02_VR_INV.PAC+B03_VR_INV.PAC,SUM,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,PAC,PAC,Server8782,8782,1,Truboard,0,new,MW,1\n2,B01_VR_INV.QAC+B02_VR_INV.QAC+B03_VR_INV.QAC,SUM,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,QAC,QAC,Server8782,8782,1,Truboard,0,new,MW,1\n3,B01_VR_INV.OLD_PAC_LIMIT+B02_VR_INV.OLD_PAC_LIMIT+B03_VR_INV.OLD_PAC_LIMIT,SUM,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8782,1,Truboard,0,new,MW,1\n4,B01_VR_INV.OLD_QAC_LIMIT+B02_VR_INV.OLD_QAC_LIMIT+B03_VR_INV.OLD_QAC_LIMIT,SUM,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8782,1,Truboard,0,new,MW,1\n\n",
        "output": "str",
        "x": 320,
        "y": 600,
        "wires": [
            [
                "f4b6fea2c0b367b3"
            ]
        ]
    },
    {
        "id": "f4b6fea2c0b367b3",
        "type": "csv",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 470,
        "y": 600,
        "wires": [
            [
                "061b018f3220f837"
            ]
        ]
    },
    {
        "id": "c371db16c6ddfc63",
        "type": "debug",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "debug 2706",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 790,
        "y": 640,
        "wires": []
    },
    {
        "id": "a9a60f45cfc5f6b4",
        "type": "debug",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "debug 2707",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 930,
        "y": 600,
        "wires": []
    },
    {
        "id": "5f69d3fe91aaa12a",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "influx",
        "func": "var time = new Date().getTime()\nvar obj = {}\nobj.payload = [{\n    measurement: \"v\",\n    fields: {\n        qu: 0,\n        text: \"\",\n        value: msg.payload.value\n    },\n    tags: {\n        b: msg.payload.b,\n        bd: msg.payload.bd,\n        d: msg.payload.d,\n        dd: msg.payload.dd,\n        dt: msg.payload.dt,\n        f: msg.payload.f,\n        fd: msg.payload.fd,\n        h: msg.payload.h,\n        iid: msg.payload.iid,\n        m: msg.payload.m,\n        p: msg.payload.p,\n        u: \"\"\n    },\n    timestamp: time,\n}];\nnode.send(obj)\nreturn null",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 740,
        "wires": [
            [
                "a73fc44f850f7471"
            ]
        ]
    },
    {
        "id": "e2ddcba055f3ba35",
        "type": "function",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "function 678",
        "func": "var obj = {};\n//var obj1 = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    //let tag_arr = global.get(msg.payload[i].calculated_field)\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if (msg.payload[i].type == \"AVG\" && msg.payload[i].calculated_field) {\n        var arr = msg.payload[i].calculated_field.split(\"+\"); // Split calculated fields\n        var val = 0;\n        var arr_length = arr.length;\n\n        var sum = 0; \n        var signSum = 0;\n\n        for (var j = 0; j < arr.length; j++) {\n            if (arr[j] && global.get(arr[j]) !== undefined) {\n                var tmp_val = global.get(arr[j]);\n\n                // Calculate the sum and track signs separately\n                sum += Math.abs(tmp_val); // Use absolute value for magnitude\n                signSum += Math.sign(tmp_val); // Track the overall direction\n            } else {\n                node.warn(\"Invalid or missing value for global key: \" + arr[j]);\n            }\n        }\n\n        // Calculate average of magnitudes\n        var avgMagnitude = sum / arr_length;\n\n        // Determine the dominant sign\n        var finalSign = (signSum === 0) ? 1 : Math.sign(signSum);\n\n        // Apply the sign to the average magnitude\n        val = finalSign * avgMagnitude;\n\n        // Construct the tag name and store the result\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f;\n        global.set(tag_val, val);\n    }\n    else if (msg.payload[i].type == \"GB_SETS\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    else if (msg.payload[i].type == \"GB_SETA\") {\n        var arr_length = arr.length\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            val = val + tmp_val\n        }\n        val = val / arr_length;\n        var tag_val = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_val, val)\n    }\n    val = (val * msg.payload[i].mf);\n    val = parseFloat(val)\n\n    //obj1.payload = [{\n    //    tags: {\n    //        val1_field: arr[0],\n    //        val1: global.get(arr[0]),\n    //        val2_field: arr[1],\n    //        val2: global.get(arr[1])\n    //    }\n    //}];\n    //node.send(obj1)\n\n    obj.payload = {\n        value: val,\n        b: msg.payload[i].b,\n        bd: msg.payload[i].bd,\n        d: msg.payload[i].d,\n        dd: msg.payload[i].dd,\n        dt: msg.payload[i].dt,\n        f: msg.payload[i].f,\n        fd: msg.payload[i].fd,\n        h: msg.payload[i].h,\n        iid: msg.payload[i].iid,\n        m: msg.payload[i].m,\n        p: msg.payload[i].p,\n        qu: msg.payload[i].qu,\n        text: msg.payload[i].text,\n        u: msg.payload[i].u,\n        mf: msg.payload[i].mf\n    }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 740,
        "wires": [
            [
                "5f69d3fe91aaa12a"
            ]
        ]
    },
    {
        "id": "c912072e049a3d50",
        "type": "inject",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "props": [],
        "repeat": "0.2",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 740,
        "wires": [
            [
                "a3a896235b7b6594"
            ]
        ]
    },
    {
        "id": "a3a896235b7b6594",
        "type": "template",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,MCR.EM01.PF+MCR.EM02.PF,AVG,MCR,MAIN_CR,VR_EM,VR_EM,EM,PF1,PF1,Server8782,8782,1,Truboard,0,new,,0.001",
        "output": "str",
        "x": 320,
        "y": 740,
        "wires": [
            [
                "c55502568dab5dc7"
            ]
        ]
    },
    {
        "id": "c55502568dab5dc7",
        "type": "csv",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 470,
        "y": 740,
        "wires": [
            [
                "e2ddcba055f3ba35"
            ]
        ]
    },
    {
        "id": "a73fc44f850f7471",
        "type": "debug",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "debug 2722",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 740,
        "wires": []
    },
    {
        "id": "658aa85031b9bce7",
        "type": "comment",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "Test PF overall value",
        "info": "",
        "x": 210,
        "y": 700,
        "wires": []
    },
    {
        "id": "ef9c4d9ad4ba10de",
        "type": "comment",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "PLANT_VR_INV",
        "info": "",
        "x": 180,
        "y": 560,
        "wires": []
    },
    {
        "id": "8cde8087405ef1ec",
        "type": "comment",
        "z": "4b39492785a70ee0",
        "g": "70b4b74643b43e4d",
        "name": "VR_EM",
        "info": "",
        "x": 170,
        "y": 440,
        "wires": []
    },
    {
        "id": "1907e07540f5dd9d",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "PAC SDF",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B31.INV01.PAC+B31.INV02.PAC+B46.INV01.PAC+B46.INV02.PAC+B47.INV01.PAC+B47.INV02.PAC+B49.INV01.PAC+B49.INV02.PAC+B50.INV01.PAC+B50.INV02.PAC,SUM,B01,B01_VR_INV,VR_INV,VR_INV,INV,PAC,PAC,Server9382,9382,1,TATA_AP_70MW,0,,MW,1",
        "output": "str",
        "x": 360,
        "y": 360,
        "wires": [
            [
                "3d36b74c853f5090"
            ]
        ]
    },
    {
        "id": "da62519ce35da62a",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "QAC SDF ",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B31.INV01.QAC+B31.INV02.QAC+B46.INV01.QAC+B46.INV02.QAC+B47.INV01.QAC+B47.INV02.QAC+B49.INV01.QAC+B49.INV02.QAC+B50.INV01.QAC+B50.INV02.QAC,SUM,B01,B01_VR_INV,VR_INV,VR_INV,INV,QAC,QAC,Server9382,9382,1,TATA_AP_70MW,0,,MW,1\n",
        "output": "str",
        "x": 360,
        "y": 400,
        "wires": [
            [
                "9458a7be2f65a2c4"
            ]
        ]
    },
    {
        "id": "854bb1aad870fd1d",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "PF SDF ",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B01.INV01.PF+B01.INV02.PF+B01.INV03.PF+B01.INV04.PF+B02.INV01.PF+B02.INV02.PF+B02.INV03.PF+B02.INV04.PF+B03.INV01.PF+B03.INV02.PF+B03.INV03.PF+B03.INV04.PF+B04.INV01.PF+B04.INV02.PF+B04.INV03.PF+B04.INV04.PF+B05.INV01.PF+B05.INV02.PF+B05.INV03.PF+B05.INV04.PF,AVG,B01,B01_VR_INV,VR_INV,VR_INV,INV,PF,PF,Server9382,9382,1,TATA_AP_70MW,0,,MW,1",
        "output": "str",
        "x": 360,
        "y": 440,
        "wires": [
            [
                "341ed687aa606a62"
            ]
        ]
    },
    {
        "id": "042aa946df75dbc3",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "OLD PAC SDF ",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B01.SAC01.OLD_PAC_LIMIT+B01.SAC02.OLD_PAC_LIMIT+B02.SAC01.OLD_PAC_LIMIT+B03.SAC01.OLD_PAC_LIMIT+B04.SAC01.OLD_PAC_LIMIT+B04.SAC02.OLD_PAC_LIMIT+B05.SAC01.OLD_PAC_LIMIT+B01.SAC01.OLD_PAC_LIMIT,SUM,B01,B01_VR_INV,VR_INV,VR_INV,INV,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server9382,9382,1,TATA_AP_70MW,0,,MW,1\n",
        "output": "str",
        "x": 380,
        "y": 480,
        "wires": [
            [
                "e80d64b9c85b94e8"
            ]
        ]
    },
    {
        "id": "69952c9d1b61c9ac",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "OLD QAC SDF ",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B01.SAC01.OLD_QAC_LIMIT+B01.SAC02.OLD_QAC_LIMIT+B02.SAC01.OLD_QAC_LIMIT+B03.SAC01.OLD_QAC_LIMIT+B04.SAC01.OLD_QAC_LIMIT+B04.SAC02.OLD_QAC_LIMIT+B05.SAC01.OLD_QAC_LIMIT+B01.SAC01.OLD_QAC_LIMIT,SUM,B01,B01_VR_INV,VR_INV,VR_INV,INV,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server9382,9382,1,TATA_AP_70MW,0,,MW,1\n",
        "output": "str",
        "x": 380,
        "y": 520,
        "wires": [
            [
                "88879a913f1247b9"
            ]
        ]
    },
    {
        "id": "eda3ed8c4da57d52",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "OLD_QAC_REF_SEL",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B01.INV01.OLD_QAC_REF_SEL+B01.INV02.OLD_QAC_REF_SEL+B01.INV03.OLD_QAC_REF_SEL+B01.INV04.OLD_QAC_REF_SEL+B02.INV01.OLD_QAC_REF_SEL+B02.INV02.OLD_QAC_REF_SEL+B02.INV03.OLD_QAC_REF_SEL+B02.INV04.OLD_QAC_REF_SEL+B03.INV01.OLD_QAC_REF_SEL+B03.INV02.OLD_QAC_REF_SEL+B03.INV03.OLD_QAC_REF_SEL+B03.INV04.OLD_QAC_REF_SEL+B04.INV01.OLD_QAC_REF_SEL+B04.INV02.OLD_QAC_REF_SEL+B04.INV03.OLD_QAC_REF_SEL+B04.INV04.OLD_QAC_REF_SEL+B05.INV01.OLD_QAC_REF_SEL+B05.INV02.OLD_QAC_REF_SEL+B05.INV03.OLD_QAC_REF_SEL+B05.INV04.OLD_QAC_REF_SEL,AVG,B01,B01_VR_INV,VR_INV,VR_INV,INV,OLD_QAC_REF_SEL,OLD_QAC_REF_SEL,Server9382,9382,1,TATA_AP_70MW,0,,MW,1",
        "output": "str",
        "x": 400,
        "y": 560,
        "wires": [
            [
                "da06202c5fa9a8e0"
            ]
        ]
    },
    {
        "id": "3d36b74c853f5090",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 630,
        "y": 360,
        "wires": [
            [
                "eec371c699c9799a"
            ]
        ]
    },
    {
        "id": "9458a7be2f65a2c4",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 630,
        "y": 400,
        "wires": [
            [
                "13a62de3a78871da"
            ]
        ]
    },
    {
        "id": "341ed687aa606a62",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 630,
        "y": 440,
        "wires": [
            [
                "49b7f36c3a10a32f"
            ]
        ]
    },
    {
        "id": "e80d64b9c85b94e8",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 630,
        "y": 480,
        "wires": [
            [
                "d26c5f3ee29b2af5"
            ]
        ]
    },
    {
        "id": "88879a913f1247b9",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 630,
        "y": 520,
        "wires": [
            [
                "148c2013128bfa1f"
            ]
        ]
    },
    {
        "id": "da06202c5fa9a8e0",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 630,
        "y": 560,
        "wires": [
            [
                "6e97a58ea19a2266"
            ]
        ]
    },
    {
        "id": "eec371c699c9799a",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var obj = {};\nvar obj1 = {};\nlet array = []\n\nvar time = new Date().getTime()\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\")\n    {\n        for (var j = 0; j < arr.length; j++)\n        {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined)\n            {\n                val = val + tmp_val\n                \n            }\n            else\n            {\n                val = val + 0;;\n            }\n        }\n    }\n    else if (msg.payload[i].type == \"AVG\")\n    {\n        var arr_length = 0\n        for (var j = 0; j < arr.length; j++)\n        {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined)\n            {\n                val = val + tmp_val\n                arr_length++;\n            }\n            else\n            {\n                val = val + 0;\n            }\n        }\n        val = val / arr_length;  \n   \n    }\n\n   \n        val = (val * msg.payload[i].mf).toFixed(2);\n        val = parseFloat(val)\n        var tag_name = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n        global.set(tag_name, val)\n\n         var length = flow.get(\"length\")\n\n         var value = global.get(tag_name)\n\n            obj.payload = {\n                value: value,\n                b: msg.payload[i].b,\n                bd: msg.payload[i].bd,\n                d: msg.payload[i].d,\n                dd: msg.payload[i].dd,\n                dt: msg.payload[i].dt,\n                f: msg.payload[i].f,\n                fd: msg.payload[i].fd,\n                h: msg.payload[i].h,\n                iid: msg.payload[i].iid,\n                m: msg.payload[i].m,\n                p: msg.payload[i].p,\n                qu: msg.payload[i].qu,\n                text: msg.payload[i].text,\n                u: msg.payload[i].u,\n                mf: msg.payload[i].mf,\n                reg_id: msg.payload[i].vr_wr_reg,\n                data_type: msg.payload[i].data_type,\n                qty: msg.payload[i].qty,\n                fc: msg.payload[i].fc,\n                SNo: msg.payload[i].SNo,\n                time: time,        \n            }\n            node.send(obj)\n    }\n\n\n//msg.payload = { length: length }\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 360,
        "wires": [
            [
                "21944ca17939a8dc",
                "a907ce0cd5d37c4c"
            ]
        ]
    },
    {
        "id": "13a62de3a78871da",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var obj = {};\nvar obj1 = {};\nlet array = []\n\nvar time = new Date().getTime()\nfor (var i = 0; i < msg.payload.length; i++) {\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n            }\n            else {\n                val = val + 0;\n            }\n        }\n    }\n    else if (msg.payload[i].type == \"AVG\") {\n        var arr_length = 0\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n                arr_length++;\n            }\n            else {\n                val = val + 0;\n            }\n        }\n        val = val / arr_length;        \n    }\n\n\n    val = (val * msg.payload[i].mf).toFixed(2);\n    val = parseFloat(val)\n    var tag_name = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n    global.set(tag_name, val)\n    var length = flow.get(\"length\")\n\n     var value = global.get(tag_name)\n   \n        obj.payload = {\n            value: value,\n            b: msg.payload[i].b,\n            bd: msg.payload[i].bd,\n            d: msg.payload[i].d,\n            dd: msg.payload[i].dd,\n            dt: msg.payload[i].dt,\n            f: msg.payload[i].f,\n            fd: msg.payload[i].fd,\n            h: msg.payload[i].h,\n            iid: msg.payload[i].iid,\n            m: msg.payload[i].m,\n            p: msg.payload[i].p,\n            qu: msg.payload[i].qu,\n            text: msg.payload[i].text,\n            u: msg.payload[i].u,\n            mf: msg.payload[i].mf,\n            reg_id: msg.payload[i].vr_wr_reg,\n            data_type: msg.payload[i].data_type,\n            qty: msg.payload[i].qty,\n            fc: msg.payload[i].fc,\n            SNo: msg.payload[i].SNo,\n            time: time,        \n        }\n        node.send(obj)\n    }\n\n\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 400,
        "wires": [
            [
                "21944ca17939a8dc"
            ]
        ]
    },
    {
        "id": "49b7f36c3a10a32f",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var obj = {};\nvar obj1 = {};\nlet array = []\n\nvar time = new Date().getTime()\nfor (var i = 0; i < msg.payload.length; i++) {\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n            }\n            else {\n                val = val + 0;\n            }\n        }\n    }\n    else if (msg.payload[i].type == \"AVG\") {\n        var arr_length = 0\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n                arr_length++;\n            }\n            else {\n                val = val + 0;\n            }\n        }\n        val = val / arr_length;\n        var length = arr_length;\n        flow.set(\"length\", length)\n    }\n\n    val = (val * msg.payload[i].mf).toFixed(2);\n    val = parseFloat(val)\n    var tag_name = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n    global.set(tag_name, val)\n\n     var value = global.get(tag_name)\n\n        obj.payload = {\n            value: value,\n            b: msg.payload[i].b,\n            bd: msg.payload[i].bd,\n            d: msg.payload[i].d,\n            dd: msg.payload[i].dd,\n            dt: msg.payload[i].dt,\n            f: msg.payload[i].f,\n            fd: msg.payload[i].fd,\n            h: msg.payload[i].h,\n            iid: msg.payload[i].iid,\n            m: msg.payload[i].m,\n            p: msg.payload[i].p,\n            qu: msg.payload[i].qu,\n            text: msg.payload[i].text,\n            u: msg.payload[i].u,\n            mf: msg.payload[i].mf,\n            reg_id: msg.payload[i].vr_wr_reg,\n            data_type: msg.payload[i].data_type,\n            qty: msg.payload[i].qty,\n            fc: msg.payload[i].fc,\n            SNo: msg.payload[i].SNo,\n            time: time,        \n        }\n        node.send(obj)\n    }\n//msg.payload = { length: length }\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 440,
        "wires": [
            [
                "21944ca17939a8dc"
            ]
        ]
    },
    {
        "id": "d26c5f3ee29b2af5",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var obj = {};\nvar obj1 = {};\nlet array = []\n\nvar time = new Date().getTime()\nfor (var i = 0; i < msg.payload.length; i++) {\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n            }\n            else {\n                val = val + 0;\n            }\n        }\n    }\n    else if (msg.payload[i].type == \"AVG\") {\n        var arr_length = 0\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n                arr_length++;\n            }\n            else {\n                val = val + 0;\n            }\n        }\n        val = val / arr_length;\n        var length = arr_length;\n        flow.set(\"length\", length)\n    }\n\n\n    val = (val * msg.payload[i].mf).toFixed(2);\n    val = parseFloat(val)\n    var tag_name = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n    global.set(tag_name, val)\n\n     var value = global.get(tag_name)\n\n    \n        obj.payload = {\n            value: value,\n            b: msg.payload[i].b,\n            bd: msg.payload[i].bd,\n            d: msg.payload[i].d,\n            dd: msg.payload[i].dd,\n            dt: msg.payload[i].dt,\n            f: msg.payload[i].f,\n            fd: msg.payload[i].fd,\n            h: msg.payload[i].h,\n            iid: msg.payload[i].iid,\n            m: msg.payload[i].m,\n            p: msg.payload[i].p,\n            qu: msg.payload[i].qu,\n            text: msg.payload[i].text,\n            u: msg.payload[i].u,\n            mf: msg.payload[i].mf,\n            reg_id: msg.payload[i].vr_wr_reg,\n            data_type: msg.payload[i].data_type,\n            qty: msg.payload[i].qty,\n            fc: msg.payload[i].fc,\n            SNo: msg.payload[i].SNo,\n            time: time,\n        }\n        node.send(obj)\n    }\n\n//msg.payload = { length: length }\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 480,
        "wires": [
            [
                "21944ca17939a8dc"
            ]
        ]
    },
    {
        "id": "148c2013128bfa1f",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var obj = {};\nvar obj1 = {};\nlet array = []\n\nvar time = new Date().getTime()\nfor (var i = 0; i < msg.payload.length; i++) {\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n            }\n            else {\n                val = val + 0;\n            }\n        }\n    }\n    else if (msg.payload[i].type == \"AVG\") {\n        var arr_length = 0\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n                arr_length++;\n            }\n            else {\n                val = val + 0;\n            }\n        }\n        val = val / arr_length;\n        var length = arr_length;\n        flow.set(\"length\", length)\n    }\n\n    val = (val * msg.payload[i].mf).toFixed(2);\n    val = parseFloat(val)\n    var tag_name = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n    global.set(tag_name, val)\n\n    var value = global.get(tag_name)\n\n        obj.payload = {\n            value: value,\n            b: msg.payload[i].b,\n            bd: msg.payload[i].bd,\n            d: msg.payload[i].d,\n            dd: msg.payload[i].dd,\n            dt: msg.payload[i].dt,\n            f: msg.payload[i].f,\n            fd: msg.payload[i].fd,\n            h: msg.payload[i].h,\n            iid: msg.payload[i].iid,\n            m: msg.payload[i].m,\n            p: msg.payload[i].p,\n            qu: msg.payload[i].qu,\n            text: msg.payload[i].text,\n            u: msg.payload[i].u,\n            mf: msg.payload[i].mf,\n            reg_id: msg.payload[i].vr_wr_reg,\n            data_type: msg.payload[i].data_type,\n            qty: msg.payload[i].qty,\n            fc: msg.payload[i].fc,\n            SNo: msg.payload[i].SNo,\n            time: time,        \n        }\n        node.send(obj)\n    }\n\n//msg.payload = { length: length }\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 520,
        "wires": [
            [
                "21944ca17939a8dc"
            ]
        ]
    },
    {
        "id": "6e97a58ea19a2266",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var obj = {};\nvar obj1 = {};\nlet array = []\n\nvar time = new Date().getTime()\nfor (var i = 0; i < msg.payload.length; i++) {\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n            }\n            else {\n                val = val + 0;\n            }\n        }\n    }\n    else if (msg.payload[i].type == \"AVG\") {\n        var arr_length = 0\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n                arr_length++;\n            }\n            else {\n                val = val + 0;\n            }\n        }\n        val = val / arr_length;\n        var length = arr_length;\n        flow.set(\"length\", length)\n    }\n\n    val = (val * msg.payload[i].mf).toFixed(2);\n    val = parseFloat(val)\n    var tag_name = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n    global.set(tag_name, val)\n\n     var value = global.get(tag_name)\n\n        obj.payload = {\n            value: value,\n            b: msg.payload[i].b,\n            bd: msg.payload[i].bd,\n            d: msg.payload[i].d,\n            dd: msg.payload[i].dd,\n            dt: msg.payload[i].dt,\n            f: msg.payload[i].f,\n            fd: msg.payload[i].fd,\n            h: msg.payload[i].h,\n            iid: msg.payload[i].iid,\n            m: msg.payload[i].m,\n            p: msg.payload[i].p,\n            qu: msg.payload[i].qu,\n            text: msg.payload[i].text,\n            u: msg.payload[i].u,\n            mf: msg.payload[i].mf,\n            reg_id: msg.payload[i].vr_wr_reg,\n            data_type: msg.payload[i].data_type,\n            qty: msg.payload[i].qty,\n            fc: msg.payload[i].fc,\n            SNo: msg.payload[i].SNo,\n            time: time,        \n        }\n        node.send(obj)\n    }\n\n//msg.payload = { length: length }\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 560,
        "wires": [
            [
                "21944ca17939a8dc"
            ]
        ]
    },
    {
        "id": "c622fd43ecd8b2ac",
        "type": "mqtt out",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "topic": "INC_INV1",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "659036d37402c930",
        "x": 1105,
        "y": 460,
        "wires": [],
        "l": false
    },
    {
        "id": "906fde1521cb9e20",
        "type": "comment",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "Incomer Node-RED to PPC",
        "info": "",
        "x": 230,
        "y": 300,
        "wires": []
    },
    {
        "id": "21944ca17939a8dc",
        "type": "join",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": false,
        "timeout": "",
        "count": "4",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 990,
        "y": 460,
        "wires": [
            [
                "c622fd43ecd8b2ac"
            ]
        ]
    },
    {
        "id": "2eb1c355565a3f10",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "NO_OF_INV_Q",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n8,NO_OF_INV_Q,SUM,B01,B01_VR_INV,VR_INV,VR_INV,INV,NO_OF_INV_Q,NO_OF_INV_Q,Server9382,9382,1,TATA_AP_70MW,0,,MW,1",
        "output": "str",
        "x": 380,
        "y": 640,
        "wires": [
            [
                "5a5d61028ec57684"
            ]
        ]
    },
    {
        "id": "5a5d61028ec57684",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": false,
        "include_null_values": "",
        "x": 630,
        "y": 640,
        "wires": [
            [
                "ae83b0b32779b69a"
            ]
        ]
    },
    {
        "id": "8c031db2bc60f63d",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var length = flow.get(\"length\")\nvar svg_length = flow.get(\"svg_length\")\nvar PAC = global.get(\"CR_EM_PAC\")\nvar Inverter_online_Q\n\nif (PAC > 0) {\n    Inverter_online_Q = length\n}\n\nelse if (PAC <= 0) {\n    Inverter_online_Q = svg_length\n}\n\nglobal.set(\"No_of_Inv_Q\", Inverter_online_Q)\n\nif (length != 0) {\n    var time = new Date().getTime()\n    var obj = {};\n    obj.payload = {\n        value: Inverter_online_Q,\n        b: msg.payload.b,\n        bd: msg.payload.bd,\n        d: msg.payload.d,\n        dd: msg.payload.dd,\n        dt: msg.payload.dt,\n        f: msg.payload.f,\n        fd: msg.payload.fd,\n        h: msg.payload.h,\n        iid: msg.payload.iid,\n        m: msg.payload.m,\n        p: msg.payload.p,\n        qu: msg.payload.qu,\n        u: msg.payload.u,\n        mf: msg.payload.mf,\n        SNo: msg.payload.SNo,\n        time: time\n\n    }\n    node.send(obj)\n}\nreturn null;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 640,
        "wires": [
            [
                "21944ca17939a8dc"
            ]
        ]
    },
    {
        "id": "ae83b0b32779b69a",
        "type": "split",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "x": 770,
        "y": 640,
        "wires": [
            [
                "8c031db2bc60f63d"
            ]
        ]
    },
    {
        "id": "a907ce0cd5d37c4c",
        "type": "debug",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "debug 2404",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 360,
        "wires": []
    },
    {
        "id": "0e9c39e05d2061fa",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "PV_ST SDF",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B01.INV01.PV_ST+B01.INV02.PV_ST+B01.INV03.PV_ST+B01.INV04.PV_ST+B02.INV01.PV_ST+B02.INV02.PV_ST+B02.INV03.PV_ST+B02.INV04.PV_ST+B03.INV01.PV_ST+B03.INV02.PV_ST+B03.INV03.PV_ST+B03.INV04.PV_ST+B04.INV01.PV_ST+B04.INV02.PV_ST+B04.INV03.PV_ST+B04.INV04.PV_ST+B05.INV01.PV_ST+B05.INV02.PV_ST+B05.INV03.PV_ST+B05.INV04.PV_ST,AVG,B01,B01_VR_INV,VR_INV,VR_INV,INV,PV_ST,PV_ST,Server9382,9382,1,TATA_AP_70MW,0,,MW,1",
        "output": "str",
        "x": 370,
        "y": 600,
        "wires": [
            [
                "ac591fa29df30fc3"
            ]
        ]
    },
    {
        "id": "ac591fa29df30fc3",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 630,
        "y": 600,
        "wires": [
            [
                "662c07107e8a7dde"
            ]
        ]
    },
    {
        "id": "662c07107e8a7dde",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "var obj = {};\nvar obj1 = {};\nlet array = []\n\nvar time = new Date().getTime()\nfor (var i = 0; i < msg.payload.length; i++) {\n    var arr = msg.payload[i].calculated_field.split(\"+\")\n    var val = 0\n    if (msg.payload[i].type == \"SUM\") {\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined) {\n                val = val + tmp_val\n            }\n            else {\n                val = val + 0;\n            }\n        }\n    }\n    else if (msg.payload[i].type == \"AVG\") {\n        var arr_length = 0\n        for (var j = 0; j < arr.length; j++) {\n            var tmp_val = global.get(arr[j])\n            if (tmp_val != \"NaN\" && tmp_val != \"nan\" && tmp_val != undefined && tmp_val == 7) {\n                val = val + tmp_val\n                arr_length++;\n            }\n            else {\n                val = val + 0;\n            }\n        }\n        val = val / arr_length;\n        var svg_length = arr_length;\n        flow.set(\"svg_length\", svg_length)\n        global.set(\"svg_length\", svg_length)\n    }\n\n    val = (val * msg.payload[i].mf).toFixed(2);\n    val = parseFloat(val)\n    var tag_name = msg.payload[i].b + '.' + msg.payload[i].d + '.' + msg.payload[i].f\n    global.set(tag_name, val)\n\n     var value = global.get(tag_name)\n\n        obj.payload = {\n            value: value,\n            b: msg.payload[i].b,\n            bd: msg.payload[i].bd,\n            d: msg.payload[i].d,\n            dd: msg.payload[i].dd,\n            dt: msg.payload[i].dt,\n            f: msg.payload[i].f,\n            fd: msg.payload[i].fd,\n            h: msg.payload[i].h,\n            iid: msg.payload[i].iid,\n            m: msg.payload[i].m,\n            p: msg.payload[i].p,\n            qu: msg.payload[i].qu,\n            text: msg.payload[i].text,\n            u: msg.payload[i].u,\n            mf: msg.payload[i].mf,\n            reg_id: msg.payload[i].vr_wr_reg,\n            data_type: msg.payload[i].data_type,\n            qty: msg.payload[i].qty,\n            fc: msg.payload[i].fc,\n            SNo: msg.payload[i].SNo,\n            time: time,        \n        }\n        node.send(obj)\n    }\n\n//msg.payload = { length: length }\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "4079525aff2cea4b",
        "type": "template",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "NO_OF_INV",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "SNo,calculated_field,type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n7,NO_OF_INV,SUM,B01,B01_VR_INV,VR_INV,VR_INV,INV,NO_OF_INV,NO_OF_INV,Server9382,9382,1,TATA_AP_70MW,0,,MW,1",
        "output": "str",
        "x": 370,
        "y": 680,
        "wires": [
            [
                "4d16c2dfe0aa8cc6"
            ]
        ]
    },
    {
        "id": "4d16c2dfe0aa8cc6",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": false,
        "include_null_values": "",
        "x": 630,
        "y": 680,
        "wires": [
            [
                "3ac69fcdcf9c6fff"
            ]
        ]
    },
    {
        "id": "4c942010abf1ab71",
        "type": "function",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "To_MQTT",
        "func": "    var length = flow.get(\"length\")\n    global.set(\"No_of_Inv\", length)\n    if(length != 0)\n    {\n        var time = new Date().getTime()\n        var obj = {};\n        obj.payload = {\n            value:length,\n            b: msg.payload.b,\n            bd: msg.payload.bd,\n            d: msg.payload.d,\n            dd: msg.payload.dd,\n            dt: msg.payload.dt,\n            f: msg.payload.f,\n            fd: msg.payload.fd,\n            h: msg.payload.h,\n            iid: msg.payload.iid,\n            m: msg.payload.m,\n            p: msg.payload.p,\n            qu: msg.payload.qu,     \n            u: msg.payload.u,\n            mf: msg.payload.mf,        \n            SNo: msg.payload.SNo, \n            time:time     \n     \n    }\n    node.send(obj)\n    }\n    return null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 680,
        "wires": [
            [
                "21944ca17939a8dc"
            ]
        ]
    },
    {
        "id": "3ac69fcdcf9c6fff",
        "type": "split",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "x": 770,
        "y": 680,
        "wires": [
            [
                "4c942010abf1ab71"
            ]
        ]
    },
    {
        "id": "3026df9b7b8e4704",
        "type": "inject",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 170,
        "y": 440,
        "wires": [
            [
                "1907e07540f5dd9d",
                "da62519ce35da62a",
                "854bb1aad870fd1d",
                "042aa946df75dbc3",
                "69952c9d1b61c9ac",
                "eda3ed8c4da57d52",
                "0e9c39e05d2061fa"
            ]
        ]
    },
    {
        "id": "625d3324f8657f08",
        "type": "template",
        "z": "f586f2e111bf806e",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,3000,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Wind_Speed,wind_Speed,8784,8784,1,Trueboard,0,,kMPH,0.0001\n2,3002,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Wind_Direction,Wind_Direction,8784,8784,1,Trueboard,0,,DEGREE,0.01\n3,3004,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Ambient_Temperature,Ambient_Temperature,8784,8784,1,Trueboard,0,,DEGREE_CELSIUS,0.001\n4,3008,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Rainfall,Rainfall,8784,8784,1,Trueboard,0,,MM,0.01\n5,3010,f32,4,1,2,,,WS,WS_35,WS,WS,WS,GHI,GHI,8784,8784,1,Trueboard,0,,W/M2,0.1\n6,3014,f32,4,1,2,,,WS,WS_35,WS,WS,WS,GTI,GTI,8784,8784,1,Trueboard,0,,W/",
        "output": "str",
        "x": 600,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "44035b62414659ff",
        "type": "inject",
        "z": "f586f2e111bf806e",
        "name": "",
        "props": [],
        "repeat": "3",
        "crontab": "",
        "once": false,
        "onceDelay": "20",
        "topic": "",
        "x": 250,
        "y": 200,
        "wires": [
            [
                "adb402839e2f4aec"
            ]
        ]
    },
    {
        "id": "a155fb0752931a1b",
        "type": "function",
        "z": "f586f2e111bf806e",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    var value = val * msg.payload[i].payload.topic.mf\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "b190bb7cccf5e601",
        "type": "join",
        "z": "f586f2e111bf806e",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "11",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1130,
        "y": 200,
        "wires": [
            [
                "a155fb0752931a1b"
            ]
        ]
    },
    {
        "id": "19af0ca4394b394f",
        "type": "function",
        "z": "f586f2e111bf806e",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 200,
        "wires": [
            [
                "3a67d0eff2f3645d"
            ]
        ]
    },
    {
        "id": "2d2da237573b2762",
        "type": "csv",
        "z": "f586f2e111bf806e",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 490,
        "y": 200,
        "wires": [
            [
                "19af0ca4394b394f"
            ]
        ]
    },
    {
        "id": "adb402839e2f4aec",
        "type": "template",
        "z": "f586f2e111bf806e",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,3000,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Wind_Speed,wind_Speed,8784,8784,1,Trueboard,0,,kMPH,0.0001\n2,3002,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Wind_Direction,Wind_Direction,8784,8784,1,Trueboard,0,,DEGREE,0.01\n3,3004,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Ambient_Temperature,Ambient_Temperature,8784,8784,1,Trueboard,0,,DEGREE_CELSIUS,0.001\n4,3008,f32,4,1,2,,,WS,WS_35,WS,WS,WS,Rainfall,Rainfall,8784,8784,1,Trueboard,0,,MM,0.01\n5,3010,f32,4,1,2,,,WS,WS_35,WS,WS,WS,GHI,GHI,8784,8784,1,Trueboard,0,,W/M2,0.1\n6,3014,f32,4,1,2,,,WS,WS_35,WS,WS,WS,GTI,GTI,8784,8784,1,Trueboard,0,,W/",
        "output": "str",
        "x": 370,
        "y": 200,
        "wires": [
            [
                "2d2da237573b2762"
            ]
        ]
    },
    {
        "id": "96c4d8e97ee15315",
        "type": "function",
        "z": "f586f2e111bf806e",
        "name": "msg",
        "func": "var obj = {}\nif (msg.error == \"Error: Timed out\") {\n  var value = \"NaN\";\n  var tag = msg.topic.topic.b + \".\" + msg.topic.topic.d + \".\" + \"COMM\" \n  global.set(tag, 0);\n  for (var j = 0; j < msg.topic.error.length; j++) {\n\n\n    obj.payload =\n    {\n      value: value,\n      topic: msg.topic.error[j]\n    }\n    node.send(obj)\n  }\n\n}\nelse {\n\n  if (Array.isArray(msg.payload.results)) {\n    var tag =  msg.topic.topic.b + \".\" + msg.topic.topic.d  + \".\" + \"COMM\"\n    global.set(tag, 1);\n    for (var i = 0; i < msg.topic.error.length; i++) {\n      for (var k = 0; k < msg.payload.results.length; k++) {\n        if (msg.payload.results[k].address == msg.topic.error[i].read_reg_id) {\n          obj.payload = {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n          node.send(obj)\n        }\n\n      }\n\n\n\n    }\n\n  }\n  else {\n    obj.payload = {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n    node.send(obj)\n\n  }\n\n\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 200,
        "wires": [
            [
                "b190bb7cccf5e601"
            ]
        ]
    },
    {
        "id": "3a67d0eff2f3645d",
        "type": "Main-Modbus-Read-Write",
        "z": "f586f2e111bf806e",
        "d": true,
        "name": "",
        "showStatusActivities": true,
        "showErrors": true,
        "showWarnings": true,
        "server": "0b96cb9d434d59c0",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 810,
        "y": 200,
        "wires": [
            [
                "96c4d8e97ee15315"
            ],
            []
        ]
    },
    {
        "id": "4a3eca5c89ce5b0e",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "influxdb",
        "func": "\nvar time = new Date().getTime()\nvar array = []\narray.length = 0\nvar obj1 = {}\nfor (var i = 0; i < msg.payload.length; i++) {    \n    var val1 = msg.payload[i].fields.value\n    if(!isNaN(val1))\n    {   \n        var cal_val = parseFloat(val1)\n\n         var obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": val1\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].tags.b,\n            \"bd\": msg.payload[i].tags.bd,\n            \"d\": msg.payload[i].tags.d,\n            \"dd\": msg.payload[i].tags.dd,\n            \"dt\": msg.payload[i].tags.dt,\n            \"f\": msg.payload[i].tags.f,\n            \"fd\": msg.payload[i].tags.fd,\n            \"h\": msg.payload[i].tags.h,\n            \"iid\": msg.payload[i].tags.iid,\n            \"m\": msg.payload[i].tags.m,\n            \"p\": msg.payload[i].tags.p,\n            \"u\": \"\"\n        },\n        \"timestamp\": time,\n    }\n \n        array.push(obj)\n    }\n}\nif(array.length != 0)\n{\n    msg.payload = array\n    return msg;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2120,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "e69079d4b5604113",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B31_INV01",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B31,B31-INV01,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B31,B31-INV01,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B31,B31-INV01,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B31,B31-INV01,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B31,B31-INV01,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B31,B31-INV01,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B31,B31-INV01,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 320,
        "wires": [
            [
                "eec84e8d29b5b68f"
            ]
        ]
    },
    {
        "id": "eec84e8d29b5b68f",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 320,
        "wires": [
            [
                "256557216b82426a"
            ]
        ]
    },
    {
        "id": "256557216b82426a",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 320,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "7cffef28a8101585",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B31_INV02",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B31,B31-INV02,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B31,B31-INV02,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B31,B31-INV02,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B31,B31-INV02,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B31,B31-INV02,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B31,B31-INV02,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B31,B31-INV02,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 360,
        "wires": [
            [
                "8f70e04e24208088"
            ]
        ]
    },
    {
        "id": "8f70e04e24208088",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 360,
        "wires": [
            [
                "c569759cd23047e8"
            ]
        ]
    },
    {
        "id": "c569759cd23047e8",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 360,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "dde8ae25e3ee3031",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 440,
        "wires": [
            [
                "73634fc49a3de845"
            ]
        ]
    },
    {
        "id": "73634fc49a3de845",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 440,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "925d7681c274d668",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 480,
        "wires": [
            [
                "190341187cd14712"
            ]
        ]
    },
    {
        "id": "190341187cd14712",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 480,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "8fd78bebaaaa9053",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 560,
        "wires": [
            [
                "92529f7cfa160eef"
            ]
        ]
    },
    {
        "id": "92529f7cfa160eef",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 560,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "d394b5081eb661be",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 600,
        "wires": [
            [
                "1b32c22692be6a34"
            ]
        ]
    },
    {
        "id": "1b32c22692be6a34",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 600,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "658e3d1adff86978",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 680,
        "wires": [
            [
                "7ce36a1516acf52d"
            ]
        ]
    },
    {
        "id": "7ce36a1516acf52d",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 680,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "b76b0b27f1d97029",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 720,
        "wires": [
            [
                "333c6f7e65f5437d"
            ]
        ]
    },
    {
        "id": "333c6f7e65f5437d",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 720,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "7f4c167c15302094",
        "type": "influxdb batch",
        "z": "022b4db85aaf3abc",
        "d": true,
        "influxdb": "ea571d30b091616d",
        "precision": "",
        "retentionPolicy": "",
        "name": "influx",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "iplon",
        "bucket": "iSolar",
        "x": 1210,
        "y": 220,
        "wires": []
    },
    {
        "id": "67bb27f51e6fb6e4",
        "type": "inject",
        "z": "022b4db85aaf3abc",
        "name": "",
        "props": [],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 150,
        "y": 240,
        "wires": [
            [
                "ca9f285f3d2548b1"
            ]
        ]
    },
    {
        "id": "7331c5e5ad375a29",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B46_INV01",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B46,B46-INV01,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B46,B46-INV01,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B46,B46-INV01,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B46,B46-INV01,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B46,B46-INV01,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B46,B46-INV01,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B46,B46-INV01,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 440,
        "wires": [
            [
                "dde8ae25e3ee3031"
            ]
        ]
    },
    {
        "id": "55fc38f89dee5d66",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B46_INV02",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B46,B46-INV02,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B46,B46-INV02,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B46,B46-INV02,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B46,B46-INV02,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B46,B46-INV02,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B46,B46-INV02,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B46,B46-INV02,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 480,
        "wires": [
            [
                "925d7681c274d668"
            ]
        ]
    },
    {
        "id": "d2142368d002d173",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B47_INV01",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B47,B47-INV01,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B47,B47-INV01,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B47,B47-INV01,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B47,B47-INV01,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B47,B47-INV01,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B47,B47-INV01,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B47,B47-INV01,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 560,
        "wires": [
            [
                "8fd78bebaaaa9053"
            ]
        ]
    },
    {
        "id": "1bcd29a88050ea0d",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B47_INV02",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B47,B47-INV02,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B47,B47-INV02,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B47,B47-INV02,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B47,B47-INV02,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B47,B47-INV02,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B47,B47-INV02,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B47,B47-INV02,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 600,
        "wires": [
            [
                "d394b5081eb661be"
            ]
        ]
    },
    {
        "id": "dadca73176035e8e",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B49_INV01",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B49,B49-INV01,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B49,B49-INV01,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B49,B49-INV01,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B49,B49-INV01,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B49,B49-INV01,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B49,B49-INV01,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B49,B49-INV01,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 680,
        "wires": [
            [
                "658e3d1adff86978"
            ]
        ]
    },
    {
        "id": "f554b5f5d0f517ca",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B49_INV02",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B49,B49-INV02,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B49,B49-INV02,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B49,B49-INV02,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B49,B49-INV02,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B49,B49-INV02,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B49,B49-INV02,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B49,B49-INV02,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 720,
        "wires": [
            [
                "b76b0b27f1d97029"
            ]
        ]
    },
    {
        "id": "89b0cb330816e810",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B50_INV01",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B50,B50-INV01,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B50,B50-INV01,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B50,B50-INV01,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B50,B50-INV01,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B50,B50-INV01,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B50,B50-INV01,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B50,B50-INV01,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 800,
        "wires": [
            [
                "e75ca0514dfbea9d"
            ]
        ]
    },
    {
        "id": "10479e1eee7321b5",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "B31_INV02",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B50,B50-INV02,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8782,8182,1,Truboard,0,new,kW,1\n2,B50,B50-INV02,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8782,8182,1,Truboard,0,new,KVAr,1\n3,B50,B50-INV02,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n4,B50,B50-INV02,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8182,1,Truboard,,,,1\n5,B50,B50-INV02,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8782,8182,1,Truboard,,,,1\n6,B50,B50-INV02,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n7,B50,B50-INV02,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8782,8182,1,Truboard,,,,1\n\n",
        "output": "str",
        "x": 1450,
        "y": 840,
        "wires": [
            [
                "dfd5fe74318e1e44"
            ]
        ]
    },
    {
        "id": "e75ca0514dfbea9d",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 800,
        "wires": [
            [
                "c925e68b4d0799d3"
            ]
        ]
    },
    {
        "id": "c925e68b4d0799d3",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 800,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "dfd5fe74318e1e44",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 1610,
        "y": 840,
        "wires": [
            [
                "af2a3087f3865dfa"
            ]
        ]
    },
    {
        "id": "af2a3087f3865dfa",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "d": true,
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 840,
        "wires": [
            [
                "4a3eca5c89ce5b0e"
            ]
        ]
    },
    {
        "id": "594999bca5c1629f",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "influxdb",
        "func": "\nvar time = new Date().getTime()\nvar array = []\narray.length = 0\nvar obj1 = {}\nfor (var i = 0; i < msg.payload.length; i++) {    \n    var val1 = msg.payload[i].fields.value\n    if(!isNaN(val1))\n    {   \n        var cal_val = parseFloat(val1)\n\n         var obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": val1\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].tags.b,\n            \"bd\": msg.payload[i].tags.bd,\n            \"d\": msg.payload[i].tags.d,\n            \"dd\": msg.payload[i].tags.dd,\n            \"dt\": msg.payload[i].tags.dt,\n            \"f\": msg.payload[i].tags.f,\n            \"fd\": msg.payload[i].tags.fd,\n            \"h\": msg.payload[i].tags.h,\n            \"iid\": msg.payload[i].tags.iid,\n            \"m\": msg.payload[i].tags.m,\n            \"p\": msg.payload[i].tags.p,\n            \"u\": msg.payload[i].tags.u\n        },\n        \"timestamp\": time,\n    }\n \n        node.send({ payload: obj });\n    }\n}\nreturn null",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 260,
        "wires": [
            [
                "927d0201185d8226"
            ]
        ]
    },
    {
        "id": "243a8a5aa5b35074",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "name": "PLANT_VR_INV",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,PAC,Active_Power,Server8782,8782,1,Truboard,,,MW,1\n2,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,QAC,Reactive_Power,Server8782,8782,1,Truboard,,,MW,1\n3,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8782,8782,1,Truboard,,,MW,1\n4,PLANT,PLANT,VR_INV,VIRTUAL_INV,CALC,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8782,8782,1,Truboard,,,MW,1",
        "output": "str",
        "x": 400,
        "y": 140,
        "wires": [
            [
                "c0ae2cfcc4ddddb4"
            ]
        ]
    },
    {
        "id": "dd4548453e36f348",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "name": "CR_EM01",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,MCR,MAIN_CR,EM01,ACTIVE_POWER,ENERGY_METER,PAC,Active_Power,Server9382,9382,1,Truboard,0,,MW,1\n2,MCR,MAIN_CR,EM01,REACTIVE,ENERGY_METER,QAC,Reactive_Power,Server9382,9382,1,Truboard,0,,KVAr,1\n3,MCR,MAIN_CR,EM01,POWER_FACTOR,ENERGY_METER,PF,Power_Factor,Server9382,9382,1,Truboard,0,,dec,1\n4,MCR,MAIN_CR,EM01,VOLTAGE,ENERGY_METER,UAC12,Voltage_RY,Server9382,9382,1,Truboard,0,,kV,1\n5,MCR,MAIN_CR,EM01,1,ENERGY_METER,UAC23,Voltage_YB,Server9382,9382,1,Truboard,0,,kV,1\n6,MCR,MAIN_CR,EM01,1,ENERGY_METER,UAC31,Voltage_BR,Server9382,9382,1,Truboard,0,,kV,1\n7,MCR,MAIN_CR,EM01,FREQUENCY,ENERGY_METER,FAC,Frequency,Server9382,9382,1,Truboard,0,,Hz,1\n8,MCR,MAIN_CR,EM01,1,ENERGY_METER,IAC1,Current_R,Server9382,9382,1,Truboard,0,,A,1\n9,MCR,MAIN_CR,EM01,1,ENERGY_METER,IAC2,Current_Y,Server9382,9382,1,Truboard,0,,A,1\n10,MCR,MAIN_CR,EM01,1,ENERGY_METER,IAC3,Current_B,Server9382,9382,1,Truboard,0,,A,1\n11,MCR,MAIN_CR,EM01,APPARENT_POWER,ENERGY_METER,SAC,Apparent_Power,Server9382,9382,1,Truboard,0,,MW,1\n12,MCR,MAIN_CR,EM01,COMMUNICATION,ENERGY_METER,COMM,Communication,Server9382,9382,1,Truboard,0,,dec,1",
        "output": "str",
        "x": 390,
        "y": 220,
        "wires": [
            [
                "858bcc31b65ef284"
            ]
        ]
    },
    {
        "id": "c0ae2cfcc4ddddb4",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 140,
        "wires": [
            [
                "87068b6f12ad594e"
            ]
        ]
    },
    {
        "id": "87068b6f12ad594e",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 140,
        "wires": [
            [
                "594999bca5c1629f"
            ]
        ]
    },
    {
        "id": "858bcc31b65ef284",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 220,
        "wires": [
            [
                "49ec9d40c99fe9f7"
            ]
        ]
    },
    {
        "id": "49ec9d40c99fe9f7",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val * (msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 220,
        "wires": [
            [
                "594999bca5c1629f"
            ]
        ]
    },
    {
        "id": "aa11794099c189a6",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Get all global values",
        "func": "// Get all keys from global context\nvar allKeys = global.keys();\nmsg.data = allKeys;\n// Create an array to store all key-value pairs\nvar allValues = [];\n\n// Loop through each key and get its value\nallKeys.forEach(function (key) {\n    var value = global.get(key);\n    // Check if the value is not an object\n    if (key !== 'nodered-status' && ((typeof value !== 'object' || value === null) && (value !== 'NaN')) ) {\n        allValues.push({ key: key, value: value });\n    }\n});\n\n// Set the result in the message payload\nmsg.payload = allValues;\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 400,
        "wires": [
            [
                "e8d022ca1f61a602"
            ]
        ]
    },
    {
        "id": "e8d022ca1f61a602",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Influxdb",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n     const value = (msg.payload[i].value)\n     const field = (msg.payload[i].key)\n     let device = null\n     if (field.includes(\"PC_RX\")){\n         device = \"SETPOINT\"\n     } else if (field.includes(\"ON_OFF\")){\n        device = \"STATUS\"\n     } else {\n        device = \"UI\"\n     }\n\n     let field_type = null\n    if (field.includes(\"PAC\")) {\n        field_type = \"ACTIVE_POWER\"\n    } else if (field.includes(\"QAC\")) {\n        field_type = \"REACTIVE\"\n    } else if (field.includes(\"FAC\")) {\n        field_type = \"FREQUENCY\"\n    } else if (field.includes(\"UAC\")) {\n        field_type = \"VOLTAGE\"\n    } else if (field.includes(\"PF\")) {\n        field_type = \"POWER_FACTOR\"\n    } else {\n        field_type = \"USER_INTERFACE\"\n    }\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": \"MCR\",\n            \"bd\": \"MAIN_CR\",\n            \"d\": device,\n            \"dd\": field_type,\n            \"dt\": \"UI\",\n            \"f\": msg.payload[i].key,\n            \"fd\": msg.payload[i].key,\n            \"h\": \"Server8782\",\n            \"iid\": \"8782\",\n            \"m\": 1,\n            \"p\": \"Truboard\",\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n \n        node.send({ payload: obj });\n}\nreturn null",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 400,
        "wires": [
            [
                "927d0201185d8226",
                "487102965643393c"
            ]
        ]
    },
    {
        "id": "0fab70528b188a9e",
        "type": "debug",
        "z": "022b4db85aaf3abc",
        "name": "debug 4",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 400,
        "wires": []
    },
    {
        "id": "0b5e76074c3bb2fa",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Influxdb",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n     const value = (msg.payload[i].value)\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": \"CR\",\n            \"bd\": \"CR\",\n            \"d\": \"UI\",\n            \"dd\": \"UI\",\n            \"dt\": \"UI\",\n            \"f\": msg.payload[i].key,\n            \"fd\": msg.payload[i].key,\n            \"h\": \"Server9084\",\n            \"iid\": \"8084\",\n            \"m\": 1,\n            \"p\": \"JS_Test\",\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "f6a0bcd6e6348149",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "name": "COMM",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B31,BLOCK_31,INV01,INV01,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n2,B31,BLOCK_31,INV02,INV02,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n3,B46,BLOCK_46,INV01,INV01,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n4,B46,BLOCK_46,INV02,INV02,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n5,B47,BLOCK_47,INV01,INV01,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n6,B47,BLOCK_47,INV02,INV02,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n7,B49,BLOCK_49,INV01,INV01,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n8,B49,BLOCK_49,INV02,INV02,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n9,B50,BLOCK_50,INV01,INV01,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1\n10,B50,BLOCK_50,INV02,INV02,INVERTER,COMM,COMMUNICATION,Server8782,8782,1,Truboard,0,,MW,1",
        "output": "str",
        "x": 380,
        "y": 300,
        "wires": [
            [
                "61dc2d77e15182d1"
            ]
        ]
    },
    {
        "id": "0f2afd82d0b81db0",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].f}.${msg.payload[i].b}.${msg.payload[i].d}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": msg.payload[i].u\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 300,
        "wires": [
            [
                "594999bca5c1629f"
            ]
        ]
    },
    {
        "id": "61dc2d77e15182d1",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 300,
        "wires": [
            [
                "0f2afd82d0b81db0"
            ]
        ]
    },
    {
        "id": "b9ca410ff82e2046",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "name": "COMM_RM",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,B31,BLOCK_31,INV01,INV01_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n2,B31,BLOCK_31,INV02,INV02_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n3,B46,BLOCK_46,INV01,INV01_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n4,B46,BLOCK_46,INV02,INV02_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n5,B47,BLOCK_47,INV01,INV01_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n6,B47,BLOCK_47,INV02,INV02_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n7,B49,BLOCK_49,INV01,INV01_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n8,B49,BLOCK_49,INV02,INV02_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n9,B50,BLOCK_50,INV01,INV01_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1\n10,B50,BLOCK_50,INV02,INV02_RM,INVERTER,RM_COMM,COMM,Server8782,8782,1,Truboard,0,,MW,1",
        "output": "str",
        "x": 390,
        "y": 340,
        "wires": [
            [
                "0da1559b1b348a5e"
            ]
        ]
    },
    {
        "id": "0da1559b1b348a5e",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 340,
        "wires": [
            [
                "9369179a2b5d2154"
            ]
        ]
    },
    {
        "id": "9369179a2b5d2154",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].f}.${msg.payload[i].b}.${msg.payload[i].d}`;\n    const val = global.get(tag_val);\n    const value = (val *(msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": msg.payload[i].u\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 340,
        "wires": [
            [
                "594999bca5c1629f"
            ]
        ]
    },
    {
        "id": "cf726ac01251ee6b",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "name": "CR_EM02",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,MCR,MAIN_CR,EM02,ACTIVE_POWER,ENERGY_METER,PAC,Active_Power,Server9382,9382,1,Truboard,0,,MW,1\n2,MCR,MAIN_CR,EM02,REACTIVE,ENERGY_METER,QAC,Reactive_Power,Server9382,9382,1,Truboard,0,,KVAr,1\n3,MCR,MAIN_CR,EM02,POWER_FACTOR,ENERGY_METER,PF,Power_Factor,Server9382,9382,1,Truboard,0,,dec,1\n4,MCR,MAIN_CR,EM02,VOLTAGE,ENERGY_METER,UAC12,Voltage_RY,Server9382,9382,1,Truboard,0,,kV,1\n5,MCR,MAIN_CR,EM02,1,ENERGY_METER,UAC23,Voltage_YB,Server9382,9382,1,Truboard,0,,kV,1\n6,MCR,MAIN_CR,EM02,1,ENERGY_METER,UAC31,Voltage_BR,Server9382,9382,1,Truboard,0,,kV,1\n7,MCR,MAIN_CR,EM02,FREQUENCY,ENERGY_METER,FAC,Frequency,Server9382,9382,1,Truboard,0,,Hz,1\n8,MCR,MAIN_CR,EM02,1,ENERGY_METER,IAC1,Current_R,Server9382,9382,1,Truboard,0,,A,1\n9,MCR,MAIN_CR,EM02,1,ENERGY_METER,IAC2,Current_Y,Server9382,9382,1,Truboard,0,,A,1\n10,MCR,MAIN_CR,EM02,1,ENERGY_METER,IAC3,Current_B,Server9382,9382,1,Truboard,0,,A,1\n11,MCR,MAIN_CR,EM02,APPARENT_POWER,ENERGY_METER,SAC,Apparent_Power,Server9382,9382,1,Truboard,0,,MW,1\n12,MCR,MAIN_CR,EM02,COMMUNICATION,ENERGY_METER,COMM,Communication,Server9382,9382,1,Truboard,0,,dec,1",
        "output": "str",
        "x": 390,
        "y": 260,
        "wires": [
            [
                "5eaa57d0352f0791"
            ]
        ]
    },
    {
        "id": "5eaa57d0352f0791",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 260,
        "wires": [
            [
                "38a48bfdc6f66522"
            ]
        ]
    },
    {
        "id": "38a48bfdc6f66522",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val * (msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 260,
        "wires": [
            [
                "594999bca5c1629f"
            ]
        ]
    },
    {
        "id": "e69c853bf7a4dc6d",
        "type": "mqtt out",
        "z": "022b4db85aaf3abc",
        "name": "",
        "topic": "local_influx",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "6900a3972037d1fd",
        "x": 1330,
        "y": 260,
        "wires": []
    },
    {
        "id": "bfe2f380fa390c7b",
        "type": "join",
        "z": "022b4db85aaf3abc",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": false,
        "accumulate": false,
        "timeout": "1",
        "count": "",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1170,
        "y": 260,
        "wires": [
            [
                "e69c853bf7a4dc6d",
                "0fab70528b188a9e"
            ]
        ]
    },
    {
        "id": "60e8fc67c6eec9b9",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "influxdb",
        "func": "\nvar time = new Date().getTime()\nvar array = []\narray.length = 0\nvar obj1 = {}\nfor (var i = 0; i < msg.payload.length; i++) {    \n    var val1 = msg.payload[i].fields.value\n    if(!isNaN(val1))\n    {   \n        var cal_val = parseFloat(val1)\n\n         var obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": val1\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].tags.b,\n            \"bd\": msg.payload[i].tags.bd,\n            \"d\": msg.payload[i].tags.d,\n            \"dd\": msg.payload[i].tags.dd,\n            \"dt\": msg.payload[i].tags.dt,\n            \"f\": msg.payload[i].tags.f,\n            \"fd\": msg.payload[i].tags.fd,\n            \"h\": msg.payload[i].tags.h,\n            \"iid\": msg.payload[i].tags.iid,\n            \"m\": msg.payload[i].tags.m,\n            \"p\": msg.payload[i].tags.p,\n            \"u\": \"\"\n        },\n        \"timestamp\": time,\n    }\n \n        array.push(obj)\n    }\n}\nif(array.length != 0)\n{\n    msg.payload = array\n    return msg;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "3460298c36b5fddf",
        "type": "template",
        "z": "022b4db85aaf3abc",
        "name": "MCR_VR_EM",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "Sl_No,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,MCR,MAIN_CR,VR_EM,ACTIVE_POWER,ENERGY_METER,PAC,Active_Power,Server9382,9382,1,Truboard,0,,MW,1\n2,MCR,MAIN_CR,VR_EM,REACTIVE,ENERGY_METER,QAC,Reactive_Power,Server9382,9382,1,Truboard,0,,KVAr,1\n3,MCR,MAIN_CR,VR_EM,POWER_FACTOR,ENERGY_METER,PF,Power_Factor,Server9382,9382,1,Truboard,0,,dec,1\n4,MCR,MAIN_CR,VR_EM,VOLTAGE,ENERGY_METER,UAC,Voltage,Server9382,9382,1,Truboard,0,,kV,1\n7,MCR,MAIN_CR,VR_EM,FREQUENCY,ENERGY_METER,FAC,Frequency,Server9382,9382,1,Truboard,0,,Hz,1\n8,MCR,MAIN_CR,VR_EM,CURRENT,ENERGY_METER,IAC,Current,Server9382,9382,1,Truboard,0,,A,1\n11,MCR,MAIN_CR,VR_EM,APPARENT_POWER,ENERGY_METER,SAC,Apparent_Power,Server9382,9382,1,Truboard,0,,MW,1\n12,MCR,MAIN_CR,VR_EM,COMMUNICATION,ENERGY_METER,COMM,Communication,Server9382,9382,1,Truboard,0,,dec,1",
        "output": "str",
        "x": 400,
        "y": 180,
        "wires": [
            [
                "1d19797ea6c1a3eb"
            ]
        ]
    },
    {
        "id": "1d19797ea6c1a3eb",
        "type": "csv",
        "z": "022b4db85aaf3abc",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "once",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 180,
        "wires": [
            [
                "b1a12aa081c510a0"
            ]
        ]
    },
    {
        "id": "b1a12aa081c510a0",
        "type": "function",
        "z": "022b4db85aaf3abc",
        "name": "Custom Function",
        "func": "let array = [];\nconst time = new Date().getTime();\n\nfor (let i = 0; i < msg.payload.length; i++) {\n    const tag_val = `${msg.payload[i].b}.${msg.payload[i].d}.${msg.payload[i].f}`;\n    const val = global.get(tag_val);\n    const value = (val * (msg.payload[i].mf))\n\n    const obj = {\n        \"measurement\": \"v\",\n        \"fields\": {\n            \"qu\": 0,\n            \"text\": \"\",\n            \"value\": value\n        },\n        \"tags\": {\n            \"b\": msg.payload[i].b,\n            \"bd\": msg.payload[i].bd,\n            \"d\": msg.payload[i].d,\n            \"dd\": msg.payload[i].dd,\n            \"dt\": msg.payload[i].dt,\n            \"f\": msg.payload[i].f,\n            \"fd\": msg.payload[i].fd,\n            \"h\": msg.payload[i].h,\n            \"iid\": msg.payload[i].iid,\n            \"m\": msg.payload[i].m,\n            \"p\": msg.payload[i].p,\n            \"u\": \"\"\n        },\n        timestamp: time\n    };\n\n    array.push(obj);\n}\n\nmsg.payload = array;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 180,
        "wires": [
            [
                "594999bca5c1629f"
            ]
        ]
    },
    {
        "id": "487102965643393c",
        "type": "debug",
        "z": "022b4db85aaf3abc",
        "name": "debug 10",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1140,
        "y": 460,
        "wires": []
    },
    {
        "id": "26b96cfb55df4d4b",
        "type": "http in",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "",
        "url": "/endpoint/grafana",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 280,
        "y": 300,
        "wires": [
            [
                "7fabc85b65e936a1",
                "f597a5e258ae9b12",
                "4d7763e8022ffcd8",
                "15d49f5162b870be"
            ]
        ]
    },
    {
        "id": "7fabc85b65e936a1",
        "type": "http response",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 630,
        "y": 260,
        "wires": []
    },
    {
        "id": "f597a5e258ae9b12",
        "type": "join",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": false,
        "timeout": "5",
        "count": "",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 630,
        "y": 300,
        "wires": [
            [
                "d75c0ff270881800"
            ]
        ]
    },
    {
        "id": "2333360a287e0b32",
        "type": "debug",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "debug 2928",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 970,
        "y": 300,
        "wires": []
    },
    {
        "id": "d75c0ff270881800",
        "type": "function",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "function 685",
        "func": "var flag = 1\nlet array = []\nfor(var i = 0; i < msg.payload.length; i++)\n{\n        if(msg.payload[i].user == \"iplon\"){\n        var mode = msg.payload[i].mode\n        var value = msg.payload[i].val\n        var out = {mode,value}\n\n        global.set(mode,value)\n        array.push(out)\n        }\n        \n}\nmsg.payload = array\nreturn msg\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 300,
        "wires": [
            [
                "2333360a287e0b32"
            ]
        ]
    },
    {
        "id": "ea8196cb99badea9",
        "type": "function",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "psql",
        "func": "for(var i = 0; i < msg.payload.length; i++)\n{\n    if(msg.payload[i].user == \"iplon\"){\n    var obj = {};\n    var time = msg.payload[i].time\n    var timestamp = time + 19800\n    var dateUTC = new Date(timestamp).toISOString(); \n\n    obj.payload = {\n        date: dateUTC,\n        timestamp: msg.payload[i].time, \n        source: msg.payload[i].server,\n        user: msg.payload[i].user,\n        mode: msg.payload[i].mode,\n        tag_id: msg.payload[i].id,\n        tag_name: msg.payload[i].tag_name,\n        type: msg.payload[i].type,\n        value: msg.payload[i].val,\n        control: msg.payload[i].control\n    }\n    node.send(obj)\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 360,
        "wires": [
            [
                "84e16ed7825c2cbb"
            ]
        ]
    },
    {
        "id": "84e16ed7825c2cbb",
        "type": "template",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "",
        "field": "query",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "INSERT INTO public.postgres1(\"SOURCE\", \"USER\", \"DATE\", \"TIMESTAMP\", \"CONTROL\", \"TYPE\", \"TAG_ID\", \"TAG_NAME\", \"MODE\", \"VALUE\") VALUES ('{{payload.source}}', '{{payload.user}}', '{{payload.date}}', '{{payload.timestamp}}', '{{payload.control}}','{{payload.type}}', '{{payload.tag_id}}', '{{payload.tag_name}}', '{{payload.mode}}', '{{payload.value}}')",
        "output": "str",
        "x": 960,
        "y": 360,
        "wires": [
            [
                "5459e514e8b5a62b",
                "abd0ab318a561745"
            ]
        ]
    },
    {
        "id": "4d7763e8022ffcd8",
        "type": "join",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": false,
        "timeout": "6",
        "count": "",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 630,
        "y": 360,
        "wires": [
            [
                "ea8196cb99badea9"
            ]
        ]
    },
    {
        "id": "50c293361ea9bb22",
        "type": "debug",
        "z": "cfa8980ee5e33ee0",
        "g": "fa01649a1ca3ae29",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 80,
        "wires": []
    },
    {
        "id": "150c3bbf6a1d05dc",
        "type": "inject",
        "z": "cfa8980ee5e33ee0",
        "g": "fa01649a1ca3ae29",
        "name": "create table",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 270,
        "y": 80,
        "wires": [
            [
                "ef2838e3b3fde275"
            ]
        ]
    },
    {
        "id": "5459e514e8b5a62b",
        "type": "debug",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "debug 2935",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1130,
        "y": 320,
        "wires": []
    },
    {
        "id": "15d49f5162b870be",
        "type": "debug",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 220,
        "wires": []
    },
    {
        "id": "abd0ab318a561745",
        "type": "postgresql",
        "z": "cfa8980ee5e33ee0",
        "g": "478bc90ac909f00b",
        "name": "",
        "query": "",
        "postgreSQLConfig": "262dfd1de0802d52",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 1130,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "ef2838e3b3fde275",
        "type": "postgresql",
        "z": "cfa8980ee5e33ee0",
        "g": "fa01649a1ca3ae29",
        "name": "",
        "query": "CREATE TABLE public.postgres1( \"S_NO\" serial PRIMARY KEY, \"SOURCE\" text, \"USER\" text, \"DATE\" text, \"TIMESTAMP\" text, \"CONTROL\" text, \"TYPE\" text, \"TAG_ID\" text, \"TAG_NAME\" text, \"MODE\" text, \"VALUE\" numeric, \"STATUS\" text) WITH  ( OIDS=FALSE)",
        "postgreSQLConfig": "262dfd1de0802d52",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 450,
        "y": 80,
        "wires": [
            [
                "50c293361ea9bb22"
            ]
        ]
    },
    {
        "id": "c5c68086b179ee6a",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1150,
        "y": 200,
        "wires": [
            [
                "16d56a281291b6aa",
                "dbfe60b941553fbf"
            ]
        ]
    },
    {
        "id": "5b49a2b173412f4a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 220,
        "wires": [
            [
                "732d4c2d2e4e2657",
                "d5731d550a91caf7"
            ]
        ]
    },
    {
        "id": "6eab47e5aefda065",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 530,
        "y": 220,
        "wires": [
            [
                "5b49a2b173412f4a"
            ]
        ]
    },
    {
        "id": "2a2af41d1cd1833b",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,1,n\n",
        "output": "str",
        "x": 410,
        "y": 220,
        "wires": [
            [
                "6eab47e5aefda065"
            ]
        ]
    },
    {
        "id": "d71d1add5514cee3",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 200,
        "wires": [
            [
                "c5c68086b179ee6a"
            ]
        ]
    },
    {
        "id": "8f1e3ce7687f466a",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B50_INV01",
        "info": "",
        "x": 230,
        "y": 100,
        "wires": []
    },
    {
        "id": "ace0a621df74eb34",
        "type": "inject",
        "z": "80362ddefbe410fa",
        "d": true,
        "name": "",
        "props": [],
        "repeat": "5",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 150,
        "y": 1360,
        "wires": [
            [
                "2a2af41d1cd1833b",
                "d1e5bf16732b7474",
                "1f52a9acd9b2ff35",
                "3303e42c564f15c8",
                "c6bddf61ca9a4465",
                "e54d9475624344a6",
                "8da8c14545bcd873",
                "60e00691273fe229",
                "b8de61775ac4d413",
                "64e5a8d63c0144e0",
                "3cb5d42be39adf6b",
                "6742ce984b0fc171",
                "49c0ba223121158e",
                "fe0e3deac079a4c4",
                "6cb28b3b888b225e",
                "16d4618452eed414",
                "a68f65a400d0bb6e",
                "65dbaf0bf02b9d63",
                "fbec6f33d846e1a3",
                "b01d3895ea64c04a"
            ]
        ]
    },
    {
        "id": "732d4c2d2e4e2657",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "e39e6931f56bee45",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 850,
        "y": 220,
        "wires": [
            [
                "d71d1add5514cee3"
            ],
            [
                "8ca86e225b39fcc9"
            ]
        ]
    },
    {
        "id": "e69c6fe19cfa1dea",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 260,
        "wires": []
    },
    {
        "id": "16d56a281291b6aa",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 200,
        "wires": [
            [
                "1972ad59a9e2175e"
            ]
        ]
    },
    {
        "id": "1972ad59a9e2175e",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 13",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1430,
        "y": 200,
        "wires": []
    },
    {
        "id": "06326ec02d48a4ec",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 530,
        "y": 160,
        "wires": [
            [
                "df50d5212f2a573e",
                "b5b805c2305a95b2"
            ]
        ]
    },
    {
        "id": "d1e5bf16732b7474",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B50,BLOCK-50,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 410,
        "y": 160,
        "wires": [
            [
                "06326ec02d48a4ec"
            ]
        ]
    },
    {
        "id": "df50d5212f2a573e",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 160,
        "wires": [
            [
                "5f00f8bc69047a80",
                "1d1377164a7df228"
            ]
        ]
    },
    {
        "id": "5f00f8bc69047a80",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)     \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 160,
        "wires": [
            [
                "032fbe5f492a550c",
                "732d4c2d2e4e2657"
            ]
        ]
    },
    {
        "id": "1d1377164a7df228",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 14",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 120,
        "wires": []
    },
    {
        "id": "dbfe60b941553fbf",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 15",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1280,
        "y": 160,
        "wires": []
    },
    {
        "id": "b5b805c2305a95b2",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 16",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 120,
        "wires": []
    },
    {
        "id": "d5731d550a91caf7",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 17",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 280,
        "wires": []
    },
    {
        "id": "a54b3d2decce49b3",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 260,
        "wires": [
            [
                "e69c6fe19cfa1dea"
            ]
        ]
    },
    {
        "id": "032fbe5f492a550c",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 18",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 160,
        "wires": []
    },
    {
        "id": "52e2afe7f3c8b493",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1150,
        "y": 480,
        "wires": [
            [
                "195fae1fc5352ac7",
                "ac4b611756c2152f"
            ]
        ]
    },
    {
        "id": "cfef530e12865e15",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 500,
        "wires": [
            [
                "f84992158fb682d3",
                "3f7e9d784536e64d"
            ]
        ]
    },
    {
        "id": "553c3fd4989a127b",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 530,
        "y": 500,
        "wires": [
            [
                "cfef530e12865e15"
            ]
        ]
    },
    {
        "id": "3303e42c564f15c8",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n\n",
        "output": "str",
        "x": 410,
        "y": 500,
        "wires": [
            [
                "553c3fd4989a127b"
            ]
        ]
    },
    {
        "id": "d5a2ecf7fb498817",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 480,
        "wires": [
            [
                "52e2afe7f3c8b493"
            ]
        ]
    },
    {
        "id": "1452e5dc14f1d778",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B50_INV02",
        "info": "",
        "x": 230,
        "y": 380,
        "wires": []
    },
    {
        "id": "f84992158fb682d3",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "508bd054a75cba90",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 850,
        "y": 500,
        "wires": [
            [
                "d5a2ecf7fb498817"
            ],
            []
        ]
    },
    {
        "id": "a0f71de3d5bfa6cb",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 19",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 540,
        "wires": []
    },
    {
        "id": "195fae1fc5352ac7",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 480,
        "wires": [
            [
                "e8cbf19949327a5f"
            ]
        ]
    },
    {
        "id": "e8cbf19949327a5f",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 20",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1430,
        "y": 480,
        "wires": []
    },
    {
        "id": "0ba721e8788d2b8f",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 530,
        "y": 440,
        "wires": [
            [
                "278454e310104b73",
                "5e52afe6a3dd7cfd"
            ]
        ]
    },
    {
        "id": "1f52a9acd9b2ff35",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B50,BLOCK-50,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 410,
        "y": 440,
        "wires": [
            [
                "0ba721e8788d2b8f"
            ]
        ]
    },
    {
        "id": "278454e310104b73",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 440,
        "wires": [
            [
                "c9a7100b09d4cfe2",
                "442570f7bd2b12a3"
            ]
        ]
    },
    {
        "id": "c9a7100b09d4cfe2",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)     \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 440,
        "wires": [
            [
                "571e7ef87f783977",
                "f84992158fb682d3"
            ]
        ]
    },
    {
        "id": "442570f7bd2b12a3",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 21",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 400,
        "wires": []
    },
    {
        "id": "ac4b611756c2152f",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 22",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1280,
        "y": 420,
        "wires": []
    },
    {
        "id": "5e52afe6a3dd7cfd",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 23",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 400,
        "wires": []
    },
    {
        "id": "3f7e9d784536e64d",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 24",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 560,
        "wires": []
    },
    {
        "id": "f8e927883566b6c2",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 540,
        "wires": [
            [
                "a0f71de3d5bfa6cb"
            ]
        ]
    },
    {
        "id": "571e7ef87f783977",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 25",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 440,
        "wires": []
    },
    {
        "id": "85b929ad4c236bba",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1170,
        "y": 800,
        "wires": [
            [
                "6b276b80e5b47041",
                "1ebf76f33ab8b82f"
            ]
        ]
    },
    {
        "id": "85d33b554bf05b97",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 820,
        "wires": [
            [
                "12eb74a33888bebb",
                "8f548b37102468a4"
            ]
        ]
    },
    {
        "id": "471595fbdfe6dd97",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 820,
        "wires": [
            [
                "85d33b554bf05b97"
            ]
        ]
    },
    {
        "id": "e54d9475624344a6",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n\n",
        "output": "str",
        "x": 430,
        "y": 820,
        "wires": [
            [
                "471595fbdfe6dd97"
            ]
        ]
    },
    {
        "id": "c36dd9740c594071",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 800,
        "wires": [
            [
                "85b929ad4c236bba"
            ]
        ]
    },
    {
        "id": "f2d992dba6d55cf9",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B49_INV01",
        "info": "",
        "x": 250,
        "y": 700,
        "wires": []
    },
    {
        "id": "12eb74a33888bebb",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "44a7947291c9227a",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 870,
        "y": 820,
        "wires": [
            [
                "c36dd9740c594071"
            ],
            []
        ]
    },
    {
        "id": "204d51af24e954b5",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 27",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 860,
        "wires": []
    },
    {
        "id": "6b276b80e5b47041",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 800,
        "wires": [
            [
                "0f966e7c278cec82"
            ]
        ]
    },
    {
        "id": "0f966e7c278cec82",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 28",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1450,
        "y": 800,
        "wires": []
    },
    {
        "id": "a248d9e9f3e0f585",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 760,
        "wires": [
            [
                "4b2ed7cca724cef8",
                "590fa892fb16fb4e"
            ]
        ]
    },
    {
        "id": "c6bddf61ca9a4465",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B49,BLOCK-49,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 430,
        "y": 760,
        "wires": [
            [
                "a248d9e9f3e0f585"
            ]
        ]
    },
    {
        "id": "4b2ed7cca724cef8",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 760,
        "wires": [
            [
                "df047719700e288a",
                "3f2753c8cef205d8"
            ]
        ]
    },
    {
        "id": "df047719700e288a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)      \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 760,
        "wires": [
            [
                "8e94f821ef8c8aa9",
                "12eb74a33888bebb"
            ]
        ]
    },
    {
        "id": "3f2753c8cef205d8",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 29",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 720,
        "wires": []
    },
    {
        "id": "1ebf76f33ab8b82f",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 30",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 760,
        "wires": []
    },
    {
        "id": "590fa892fb16fb4e",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 31",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 720,
        "wires": []
    },
    {
        "id": "8f548b37102468a4",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 32",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 880,
        "wires": []
    },
    {
        "id": "961715f779cc3149",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 860,
        "wires": [
            [
                "204d51af24e954b5"
            ]
        ]
    },
    {
        "id": "8e94f821ef8c8aa9",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 33",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 760,
        "wires": []
    },
    {
        "id": "cf8bdba373e8c285",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1170,
        "y": 1080,
        "wires": [
            [
                "436638c01c1b18d1",
                "199919d978e9d0ca"
            ]
        ]
    },
    {
        "id": "a8429890ec9c2652",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 1100,
        "wires": [
            [
                "0374d85337b133f0",
                "2f4457c9efc17bfd"
            ]
        ]
    },
    {
        "id": "50bba1412863e3c1",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 1100,
        "wires": [
            [
                "a8429890ec9c2652"
            ]
        ]
    },
    {
        "id": "60e00691273fe229",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n\n",
        "output": "str",
        "x": 430,
        "y": 1100,
        "wires": [
            [
                "50bba1412863e3c1"
            ]
        ]
    },
    {
        "id": "7754245df8970478",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 1080,
        "wires": [
            [
                "cf8bdba373e8c285"
            ]
        ]
    },
    {
        "id": "81a3a31e2f77239f",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B49_INV02",
        "info": "",
        "x": 250,
        "y": 980,
        "wires": []
    },
    {
        "id": "0374d85337b133f0",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "8473ea32a5d8f50e",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 870,
        "y": 1100,
        "wires": [
            [
                "7754245df8970478"
            ],
            []
        ]
    },
    {
        "id": "9531c0532cd171c0",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 34",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 1140,
        "wires": []
    },
    {
        "id": "436638c01c1b18d1",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 1080,
        "wires": [
            [
                "d992c785d4b72003"
            ]
        ]
    },
    {
        "id": "d992c785d4b72003",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 35",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1450,
        "y": 1080,
        "wires": []
    },
    {
        "id": "92c1af47873fd29f",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 550,
        "y": 1040,
        "wires": [
            [
                "3e1aa4ad6050aa7e",
                "e881e47e7a3a3c5c"
            ]
        ]
    },
    {
        "id": "8da8c14545bcd873",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B49,BLOCK-49,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 430,
        "y": 1040,
        "wires": [
            [
                "92c1af47873fd29f"
            ]
        ]
    },
    {
        "id": "3e1aa4ad6050aa7e",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 1040,
        "wires": [
            [
                "0aad4cb0cf7441f1",
                "94d2cd430e4d3d51"
            ]
        ]
    },
    {
        "id": "0aad4cb0cf7441f1",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\nvar remote_value = global.get(remote_tag)\n\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)      \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 1040,
        "wires": [
            [
                "42ab6a5b7d131afa",
                "0374d85337b133f0"
            ]
        ]
    },
    {
        "id": "94d2cd430e4d3d51",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 36",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1000,
        "wires": []
    },
    {
        "id": "199919d978e9d0ca",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 37",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1040,
        "wires": []
    },
    {
        "id": "e881e47e7a3a3c5c",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 38",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 1000,
        "wires": []
    },
    {
        "id": "2f4457c9efc17bfd",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 39",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 1160,
        "wires": []
    },
    {
        "id": "de5c81e1ebe652cc",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1140,
        "wires": [
            [
                "9531c0532cd171c0"
            ]
        ]
    },
    {
        "id": "42ab6a5b7d131afa",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 40",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 1040,
        "wires": []
    },
    {
        "id": "3d27bb6ea8306bb6",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1190,
        "y": 1380,
        "wires": [
            [
                "385a03daefd1e9a7",
                "b95b6996c76a38b0"
            ]
        ]
    },
    {
        "id": "62b2037c1fe8a85f",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 1400,
        "wires": [
            [
                "3d9368d42d3c2457",
                "7285ea5cb4f8a7b3"
            ]
        ]
    },
    {
        "id": "daa8e6b59755d7cf",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 570,
        "y": 1400,
        "wires": [
            [
                "62b2037c1fe8a85f"
            ]
        ]
    },
    {
        "id": "64e5a8d63c0144e0",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n\n\n",
        "output": "str",
        "x": 450,
        "y": 1400,
        "wires": [
            [
                "daa8e6b59755d7cf"
            ]
        ]
    },
    {
        "id": "800f1638f3d62982",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 1380,
        "wires": [
            [
                "3d27bb6ea8306bb6"
            ]
        ]
    },
    {
        "id": "cf094887907c856f",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B46_INV01",
        "info": "",
        "x": 630,
        "y": 1180,
        "wires": []
    },
    {
        "id": "3d9368d42d3c2457",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "e8257c92c5ac9def",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 890,
        "y": 1400,
        "wires": [
            [
                "800f1638f3d62982"
            ],
            [
                "403560b3a4d0c308"
            ]
        ]
    },
    {
        "id": "403560b3a4d0c308",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 41",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1120,
        "y": 1440,
        "wires": []
    },
    {
        "id": "385a03daefd1e9a7",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 1380,
        "wires": [
            [
                "80b16576d42ff246"
            ]
        ]
    },
    {
        "id": "80b16576d42ff246",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 42",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 1380,
        "wires": []
    },
    {
        "id": "48f31c2685e5d45f",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 570,
        "y": 1340,
        "wires": [
            [
                "41bfa421e0c618b2",
                "b619a53ded8351a7"
            ]
        ]
    },
    {
        "id": "b8de61775ac4d413",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B46,BLOCK-46,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 450,
        "y": 1340,
        "wires": [
            [
                "48f31c2685e5d45f"
            ]
        ]
    },
    {
        "id": "41bfa421e0c618b2",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 1340,
        "wires": [
            [
                "b04d3471254c2d5a",
                "63e60b92ceb8e40b"
            ]
        ]
    },
    {
        "id": "b04d3471254c2d5a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)     \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 1340,
        "wires": [
            [
                "02ee03f36ff2be7b",
                "3d9368d42d3c2457"
            ]
        ]
    },
    {
        "id": "63e60b92ceb8e40b",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 43",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 1300,
        "wires": []
    },
    {
        "id": "b95b6996c76a38b0",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 44",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1340,
        "wires": []
    },
    {
        "id": "b619a53ded8351a7",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 45",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 700,
        "y": 1300,
        "wires": []
    },
    {
        "id": "7285ea5cb4f8a7b3",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 46",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1460,
        "wires": []
    },
    {
        "id": "02ee03f36ff2be7b",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 47",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 1340,
        "wires": []
    },
    {
        "id": "477ae40d2a3fa702",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1190,
        "y": 1660,
        "wires": [
            [
                "bfe5e5350265a55a",
                "3ce413d2a946f077"
            ]
        ]
    },
    {
        "id": "38cc9f816cf3c733",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 1680,
        "wires": [
            [
                "9fd2fd282d1bc14b",
                "76624f2104a98486"
            ]
        ]
    },
    {
        "id": "d0e2deeeba938f4d",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 570,
        "y": 1680,
        "wires": [
            [
                "38cc9f816cf3c733"
            ]
        ]
    },
    {
        "id": "6742ce984b0fc171",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n\n\n",
        "output": "str",
        "x": 450,
        "y": 1680,
        "wires": [
            [
                "d0e2deeeba938f4d"
            ]
        ]
    },
    {
        "id": "c7eb44324c67f158",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 1660,
        "wires": [
            [
                "477ae40d2a3fa702"
            ]
        ]
    },
    {
        "id": "a65af5301f2d9126",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B46_INV02",
        "info": "",
        "x": 270,
        "y": 1560,
        "wires": []
    },
    {
        "id": "9fd2fd282d1bc14b",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "bbb7096bb7e73e42",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 890,
        "y": 1680,
        "wires": [
            [
                "c7eb44324c67f158"
            ],
            []
        ]
    },
    {
        "id": "8781baa6d43f0507",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 48",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1720,
        "wires": []
    },
    {
        "id": "bfe5e5350265a55a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 1660,
        "wires": [
            [
                "c31759c13267a03b"
            ]
        ]
    },
    {
        "id": "c31759c13267a03b",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 49",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 1660,
        "wires": []
    },
    {
        "id": "a8ed104d8bfce9e5",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 570,
        "y": 1620,
        "wires": [
            [
                "3b8bd3ac6ac95a03",
                "cc3bd86d5628710c"
            ]
        ]
    },
    {
        "id": "3cb5d42be39adf6b",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B46,BLOCK-46,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 450,
        "y": 1620,
        "wires": [
            [
                "a8ed104d8bfce9e5"
            ]
        ]
    },
    {
        "id": "3b8bd3ac6ac95a03",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 1620,
        "wires": [
            [
                "63258123319abd89",
                "207831f8147f5358"
            ]
        ]
    },
    {
        "id": "63258123319abd89",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)   \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 1620,
        "wires": [
            [
                "ff6ee827753d7e25",
                "9fd2fd282d1bc14b"
            ]
        ]
    },
    {
        "id": "207831f8147f5358",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 50",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 1580,
        "wires": []
    },
    {
        "id": "3ce413d2a946f077",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 51",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 1620,
        "wires": []
    },
    {
        "id": "cc3bd86d5628710c",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 52",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 700,
        "y": 1580,
        "wires": []
    },
    {
        "id": "76624f2104a98486",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 53",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1740,
        "wires": []
    },
    {
        "id": "a02f8edf46886a59",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 1720,
        "wires": [
            [
                "8781baa6d43f0507"
            ]
        ]
    },
    {
        "id": "ff6ee827753d7e25",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 54",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 1620,
        "wires": []
    },
    {
        "id": "abf49945771f98e7",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1204,
        "y": 1960,
        "wires": [
            [
                "799a1298c3076f3a",
                "9eaf4b19c303c6cd"
            ]
        ]
    },
    {
        "id": "dcea6942a1e74212",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 704,
        "y": 1980,
        "wires": [
            [
                "88342281d2f2b6c9",
                "28b6510653d3ab8d"
            ]
        ]
    },
    {
        "id": "241f2ddcde36bfca",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 584,
        "y": 1980,
        "wires": [
            [
                "dcea6942a1e74212"
            ]
        ]
    },
    {
        "id": "fe0e3deac079a4c4",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n\n\n",
        "output": "str",
        "x": 464,
        "y": 1980,
        "wires": [
            [
                "241f2ddcde36bfca"
            ]
        ]
    },
    {
        "id": "56b6d105ed6e8474",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1084,
        "y": 1960,
        "wires": [
            [
                "abf49945771f98e7"
            ]
        ]
    },
    {
        "id": "c08b6147f7afbfbd",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B31_INV01",
        "info": "",
        "x": 284,
        "y": 1860,
        "wires": []
    },
    {
        "id": "88342281d2f2b6c9",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "cd9af449ab56d106",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 904,
        "y": 1980,
        "wires": [
            [
                "56b6d105ed6e8474"
            ],
            [
                "75b30ecda2170b3f"
            ]
        ]
    },
    {
        "id": "7002a12c662ba1cb",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 55",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1234,
        "y": 2020,
        "wires": []
    },
    {
        "id": "799a1298c3076f3a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1334,
        "y": 1960,
        "wires": [
            [
                "f5b24f9329ce62bd"
            ]
        ]
    },
    {
        "id": "f5b24f9329ce62bd",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 56",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1600,
        "y": 1940,
        "wires": []
    },
    {
        "id": "2b9ac9c6ab723dc7",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 584,
        "y": 1920,
        "wires": [
            [
                "7a28c48fd53773c8",
                "ef28bafbfa173302"
            ]
        ]
    },
    {
        "id": "49c0ba223121158e",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B31,BLOCK-31,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 464,
        "y": 1920,
        "wires": [
            [
                "2b9ac9c6ab723dc7"
            ]
        ]
    },
    {
        "id": "7a28c48fd53773c8",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 724,
        "y": 1920,
        "wires": [
            [
                "9e2abad88fc95e43",
                "bbdfddc2a454b623"
            ]
        ]
    },
    {
        "id": "9e2abad88fc95e43",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\n// var new_qac_limit = 10\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)    \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 1920,
        "wires": [
            [
                "80ef291f5735dce5",
                "88342281d2f2b6c9"
            ]
        ]
    },
    {
        "id": "bbdfddc2a454b623",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 57",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 874,
        "y": 1880,
        "wires": []
    },
    {
        "id": "9eaf4b19c303c6cd",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 58",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1334,
        "y": 1920,
        "wires": []
    },
    {
        "id": "ef28bafbfa173302",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 59",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 714,
        "y": 1880,
        "wires": []
    },
    {
        "id": "28b6510653d3ab8d",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 60",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 854,
        "y": 2040,
        "wires": []
    },
    {
        "id": "6546571ab676872f",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1094,
        "y": 2020,
        "wires": [
            [
                "7002a12c662ba1cb"
            ]
        ]
    },
    {
        "id": "80ef291f5735dce5",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 61",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1094,
        "y": 1920,
        "wires": []
    },
    {
        "id": "ddfb7b6bf6205c15",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1204,
        "y": 2240,
        "wires": [
            [
                "9b758a4613495b4e",
                "7ad8bc03d6dbe11a"
            ]
        ]
    },
    {
        "id": "5b7834d927cd2de9",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 704,
        "y": 2260,
        "wires": [
            [
                "34202d67be2ee9d7",
                "5ffb03d98e4ee404"
            ]
        ]
    },
    {
        "id": "0f9326794813e385",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 584,
        "y": 2260,
        "wires": [
            [
                "5b7834d927cd2de9"
            ]
        ]
    },
    {
        "id": "16d4618452eed414",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n",
        "output": "str",
        "x": 464,
        "y": 2260,
        "wires": [
            [
                "0f9326794813e385"
            ]
        ]
    },
    {
        "id": "09706f356d43f685",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1084,
        "y": 2240,
        "wires": [
            [
                "ddfb7b6bf6205c15"
            ]
        ]
    },
    {
        "id": "371ef3ee97cfb1e8",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B31_INV02",
        "info": "",
        "x": 284,
        "y": 2140,
        "wires": []
    },
    {
        "id": "34202d67be2ee9d7",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "server": "842e03518674f086",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 904,
        "y": 2260,
        "wires": [
            [
                "09706f356d43f685"
            ],
            []
        ]
    },
    {
        "id": "1e7b7a60d90f81bf",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 62",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1234,
        "y": 2300,
        "wires": []
    },
    {
        "id": "9b758a4613495b4e",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1334,
        "y": 2240,
        "wires": [
            [
                "17c0f571d4e0d3d2"
            ]
        ]
    },
    {
        "id": "17c0f571d4e0d3d2",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 63",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1484,
        "y": 2240,
        "wires": []
    },
    {
        "id": "c458d6d2a5f4feb3",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 584,
        "y": 2200,
        "wires": [
            [
                "4148430cbf8ddcb1",
                "6d341a8a4ca12e49"
            ]
        ]
    },
    {
        "id": "6cb28b3b888b225e",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B31,BLOCK-31,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 464,
        "y": 2200,
        "wires": [
            [
                "c458d6d2a5f4feb3"
            ]
        ]
    },
    {
        "id": "4148430cbf8ddcb1",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 724,
        "y": 2200,
        "wires": [
            [
                "07a6440e11108da7",
                "8e337a74fafa79d9"
            ]
        ]
    },
    {
        "id": "07a6440e11108da7",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)      \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 864,
        "y": 2200,
        "wires": [
            [
                "ed9823003aac8c5e",
                "34202d67be2ee9d7"
            ]
        ]
    },
    {
        "id": "8e337a74fafa79d9",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 64",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 874,
        "y": 2160,
        "wires": []
    },
    {
        "id": "7ad8bc03d6dbe11a",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 65",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1334,
        "y": 2200,
        "wires": []
    },
    {
        "id": "6d341a8a4ca12e49",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 66",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 714,
        "y": 2160,
        "wires": []
    },
    {
        "id": "5ffb03d98e4ee404",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 67",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 854,
        "y": 2320,
        "wires": []
    },
    {
        "id": "0e8edf3195fec327",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1094,
        "y": 2300,
        "wires": [
            [
                "1e7b7a60d90f81bf"
            ]
        ]
    },
    {
        "id": "ed9823003aac8c5e",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 68",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1094,
        "y": 2200,
        "wires": []
    },
    {
        "id": "7779bd40e23a24b5",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1224,
        "y": 2520,
        "wires": [
            [
                "ea1645dacfcdf23b",
                "45f0ed2ea30efe90"
            ]
        ]
    },
    {
        "id": "5dec25afbb5961c2",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 724,
        "y": 2540,
        "wires": [
            [
                "48bbd3cfacd23bc5",
                "8c2900c5d6be4f1f"
            ]
        ]
    },
    {
        "id": "826430470b32ccbd",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 604,
        "y": 2540,
        "wires": [
            [
                "5dec25afbb5961c2"
            ]
        ]
    },
    {
        "id": "65dbaf0bf02b9d63",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n",
        "output": "str",
        "x": 484,
        "y": 2540,
        "wires": [
            [
                "826430470b32ccbd"
            ]
        ]
    },
    {
        "id": "e839c2f20d7ae652",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1104,
        "y": 2520,
        "wires": [
            [
                "7779bd40e23a24b5"
            ]
        ]
    },
    {
        "id": "0d3244071728cbb3",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B47_INV01",
        "info": "",
        "x": 304,
        "y": 2420,
        "wires": []
    },
    {
        "id": "48bbd3cfacd23bc5",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "0795889e0c58f9c0",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 930,
        "y": 2540,
        "wires": [
            [
                "e839c2f20d7ae652"
            ],
            []
        ]
    },
    {
        "id": "d7bfd68e84265f85",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 69",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1254,
        "y": 2580,
        "wires": []
    },
    {
        "id": "ea1645dacfcdf23b",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1354,
        "y": 2520,
        "wires": [
            [
                "dc5464b7e33ccbef"
            ]
        ]
    },
    {
        "id": "dc5464b7e33ccbef",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 70",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1504,
        "y": 2520,
        "wires": []
    },
    {
        "id": "17ad03369b82d45a",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 604,
        "y": 2480,
        "wires": [
            [
                "a22c5cde0619ab8d",
                "89dd33431f0e9490"
            ]
        ]
    },
    {
        "id": "a68f65a400d0bb6e",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B47,BLOCK-47,INV01,INVERTER-01,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 484,
        "y": 2480,
        "wires": [
            [
                "17ad03369b82d45a"
            ]
        ]
    },
    {
        "id": "a22c5cde0619ab8d",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 744,
        "y": 2480,
        "wires": [
            [
                "735eacde7723d52c",
                "e970694c32738feb"
            ]
        ]
    },
    {
        "id": "735eacde7723d52c",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)     \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 884,
        "y": 2480,
        "wires": [
            [
                "48b8e25c75d90472",
                "48bbd3cfacd23bc5"
            ]
        ]
    },
    {
        "id": "e970694c32738feb",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 71",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 960,
        "y": 2420,
        "wires": []
    },
    {
        "id": "45f0ed2ea30efe90",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 72",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1354,
        "y": 2480,
        "wires": []
    },
    {
        "id": "89dd33431f0e9490",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 73",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 734,
        "y": 2440,
        "wires": []
    },
    {
        "id": "8c2900c5d6be4f1f",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 74",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 874,
        "y": 2600,
        "wires": []
    },
    {
        "id": "795bd2a2bfdf63c9",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1114,
        "y": 2580,
        "wires": [
            [
                "d7bfd68e84265f85"
            ]
        ]
    },
    {
        "id": "48b8e25c75d90472",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 75",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1114,
        "y": 2480,
        "wires": []
    },
    {
        "id": "f7045449ab984ff0",
        "type": "join",
        "z": "80362ddefbe410fa",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 1228,
        "y": 2800,
        "wires": [
            [
                "c707a01c0632852a",
                "529720555b0314fb"
            ]
        ]
    },
    {
        "id": "c5daf23ee446d587",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "query",
        "func": "var object = msg.payload\n\n\nfor (var i = 0; i < msg.payload.length; i++) {\n    if (msg.payload[i].read == \"y\") {\n        var query = {}\n        query.payload = { 'fc': msg.payload[i].fun_code, 'unitid': msg.payload[i].unit_id, 'address': msg.payload[i].read_reg_id, 'quantity': msg.payload[i].addr_qty, 'datatype': msg.payload[i].read_reg_type, 'operation': 'read' };\n        query.topic = { topic: msg.payload[i], error: object };\n\n        node.send(query);\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 728,
        "y": 2820,
        "wires": [
            [
                "5f98fb050cf0c3fa",
                "697dcb4ba861a6da"
            ]
        ]
    },
    {
        "id": "e0be8a1e85f50727",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 608,
        "y": 2820,
        "wires": [
            [
                "c5daf23ee446d587"
            ]
        ]
    },
    {
        "id": "b01d3895ea64c04a",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Read",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf,read\n1,8205,S16,3,1,2,,,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,PAC,PAC,Server8501,8501,1,Trueboard,0,,kW,0.1,y\n2,8206,S16,3,1,1,,,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,QAC,QAC,Server8501,8501,1,Trueboard,0,,KVAr,0.1,n\n3,8272,S16,3,1,3,,,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,OLD_PAC_LIMIT,OLD_PAC_LIMIT,Server8501,8501,1,Trueboard,0,,kW,1,y\n4,8273,S16,3,1,1,,,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,OLD_QAC_LIMIT,OLD_QAC_LIMIT,Server8501,8501,1,Trueboard,0,,kVAr,1,n\n5,8274,S16,3,1,1,,,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,0,,,0.001,n\n\n\n",
        "output": "str",
        "x": 488,
        "y": 2820,
        "wires": [
            [
                "e0be8a1e85f50727"
            ]
        ]
    },
    {
        "id": "8ea379b6126d725e",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "msg",
        "func": "if (msg.error === \"Error: Timed out\") {\n if (msg.topic && typeof msg.topic === 'object' && !Array.isArray(msg.topic)) {\n    let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n    global.set(tag, 0);\n  if(msg.topic.error)\n  {\n    for (let j = 0; j < msg.topic.error.length; j++) {\n      let outMsg = {\n        payload: {\n          value: \"NaN\",\n          topic: msg.topic.error[j]\n        }\n      };\n      node.send(outMsg);\n    }\n  }\n  }\n}\nelse if (msg.payload && Array.isArray(msg.payload.results)) {\n\n  let tag = \"COMM\" + \".\" + msg.topic.topic.b + \".\" + msg.topic.topic.d;\n  global.set(tag, 1);\n\n  for (let i = 0; i < msg.topic.error.length; i++) {\n    for (let k = 0; k < msg.payload.results.length; k++) {\n      if (msg.payload.results[k].address === msg.topic.error[i].read_reg_id) {\n        let outMsg = {\n          payload: {\n            value: msg.payload.results[k].value,\n            topic: msg.topic.error[i]\n          }\n        };\n        node.send(outMsg);\n      }\n    }\n  }\n}\nelse if (msg.payload && msg.payload.value !== undefined) {\n\n  let outMsg = {\n    payload: {\n      value: msg.payload.value,\n      topic: msg.topic.topic\n    }\n  };\n  node.send(outMsg);\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1108,
        "y": 2800,
        "wires": [
            [
                "f7045449ab984ff0"
            ]
        ]
    },
    {
        "id": "de76bae0e5e6704f",
        "type": "comment",
        "z": "80362ddefbe410fa",
        "name": "B47_INV02",
        "info": "",
        "x": 308,
        "y": 2700,
        "wires": []
    },
    {
        "id": "5f98fb050cf0c3fa",
        "type": "Main-Modbus-Read-Write",
        "z": "80362ddefbe410fa",
        "name": "",
        "showStatusActivities": true,
        "showErrors": false,
        "showWarnings": true,
        "server": "c63b7c3157e71798",
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 928,
        "y": 2820,
        "wires": [
            [
                "8ea379b6126d725e",
                "732e9424768309aa"
            ],
            []
        ]
    },
    {
        "id": "5c3124f3dbc30e84",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 76",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1258,
        "y": 2860,
        "wires": []
    },
    {
        "id": "c707a01c0632852a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "VR_EM",
        "func": "var obj = {};\nfor (var i = 0; i < msg.payload.length; i++) {\n    var tag_val = msg.payload[i].payload.topic.b + '.' + msg.payload[i].payload.topic.d + '.' + msg.payload[i].payload.topic.f\n    var val = msg.payload[i].payload.value\n    if (val != \"NaN\")\n     {\n        var value = val * msg.payload[i].payload.topic.mf\n    }\n    else {\n        value = val\n    }\n\n    global.set(tag_val, value)\n    obj.payload = { tag_val: tag_val, value: value }\n    node.send(obj)\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1358,
        "y": 2800,
        "wires": [
            [
                "54d60fe1755e7c71"
            ]
        ]
    },
    {
        "id": "54d60fe1755e7c71",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 77",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1508,
        "y": 2800,
        "wires": []
    },
    {
        "id": "df5d2c624df1074d",
        "type": "csv",
        "z": "80362ddefbe410fa",
        "name": "",
        "sep": ",",
        "hdrin": true,
        "hdrout": "none",
        "multi": "mult",
        "ret": "\\n",
        "temp": "",
        "skip": "0",
        "strings": true,
        "include_empty_strings": "",
        "include_null_values": "",
        "x": 608,
        "y": 2760,
        "wires": [
            [
                "b8d18dd7d5b767c5",
                "21a74056c0e79747"
            ]
        ]
    },
    {
        "id": "fbec6f33d846e1a3",
        "type": "template",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "S.No,old_limit,read_reg_id,read_reg_type,fun_code,unit_id,addr_qty,write_reg_id,write_reg_type,b,bd,d,dd,dt,f,fd,h,iid,m,p,qu,text,u,mf\n1,OLD_QAC_LIMIT,,,6,1,1,12305,S16,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,QAC_LIMIT_CMD,QAC_LIMIT_CMD,Server8501,8501,1,Trueboard,,,kVAr,1\n2,OLD_PF_LIMIT,,,6,1,1,12306,S16,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,OLD_PF_LIMIT,OLD_PF_LIMIT,Server8501,8501,1,Trueboard,,,,0.001\n3,OLD_PAC_LIMIT,,,6,1,1,12304,U16,B47,BLOCK-47,INV02,INVERTER-02,INVERTER,PAC_LIMIT_CMD,PAC_LIMIT_CMD,,Server8501,8501,1,Trueboard,,,kW,1",
        "output": "str",
        "x": 488,
        "y": 2760,
        "wires": [
            [
                "df5d2c624df1074d"
            ]
        ]
    },
    {
        "id": "b8d18dd7d5b767c5",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "data process",
        "func": "let array = []\n\nfor (var i = 0; i < msg.payload.length; i++)\n{\n    var topic = msg.payload[i]\n    var old_name = msg.payload[i].b +'.' + msg.payload[i].d +'.' + msg.payload[i].old_limit\n    var old_value = global.get(old_name)\n\n    var new_tag = msg.payload[i].f\n    var new_value = global.get(new_tag)\n\n    var obj  = {\n                old_tag:old_name,\n                old_value:old_value,\n                new_tag:new_tag,\n                new_value:new_value,\n                register:msg.payload[i].write_reg_id,\n                qnty:msg.payload[i].addr_qty,\n                fc:msg.payload[i].fun_code,\n                unit_id:msg.payload[i].unit_id,\n                reg_type:msg.payload[i].write_reg_type,\n                p:msg.payload[i].p,\n                b:msg.payload[i].b,\n                d:msg.payload[i].d\n                }\n    obj.topic = topic\n    array.push(obj)\n}\nmsg.payload = array\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 748,
        "y": 2760,
        "wires": [
            [
                "3fd76812b48f1d3a",
                "caa8568617b6ea0b"
            ]
        ]
    },
    {
        "id": "3fd76812b48f1d3a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "Write",
        "func": "var pac_limit_tag = msg.payload[2].b + '.' + msg.payload[2].d + '.' + msg.payload[2].new_tag\nvar old_pac_limit = msg.payload[2].old_value\nvar new_pac_limit = msg.payload[2].new_value\nglobal.set(pac_limit_tag, new_pac_limit)\nvar new_pac_limit_Reg_id = msg.payload[2].register\nvar new_pac_limit_Reg_type = msg.payload[2].reg_type\n\nvar old_qac_limit = msg.payload[0].old_value\nvar new_qac_limit = msg.payload[0].new_value\nvar qac_limit_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + msg.payload[0].new_tag\nglobal.set(qac_limit_tag, new_qac_limit)\nvar new_qac_limit_Reg_id = msg.payload[0].register\nvar new_qac_limit_Reg_type = msg.payload[0].reg_type\n\nvar old_pf_limit = msg.payload[1].old_value\nvar new_pf_limit = msg.payload[1].new_value\nvar new_pf_limit_Reg_id = msg.payload[1].register\nvar new_pf_limit_Reg_type = msg.payload[1].reg_type\nvar pf_limit_tag = msg.payload[1].b + '.' + msg.payload[1].d + '.' + msg.payload[1].new_tag\nglobal.set(pf_limit_tag, new_pf_limit)\n\n\nvar block_tag = msg.payload[0].b + '.' + msg.payload[0].d + '.' + \"PAC\"\nvar pac_tag = global.get(block_tag)\n\nvar remote_tag = \"RM_COMM\" + '.' + msg.payload[0].b + '.' + msg.payload[0].d\n//node.warn(remote_tag);\nvar remote_value = global.get(remote_tag)\n//node.warn(remote_value)\n\n\nif (((remote_value == 1) )  || (remote_value == 0))\n{\n    var msg4 = {};\n    msg4.payload = {\n        'value': remote_value,\n        'fc': 5,\n        'unitid': 1,\n        'address': 12288,\n        'quantity': 1,\n        'datatype': 'S16',\n        'operation': 'write'\n    };\n    msg4.topic = {topic:msg.payload[0].topic}\n    node.send(msg4);\n    \n    global.set(remote_tag,2)     \n}\n\n\nif (old_pac_limit != new_pac_limit && new_pac_limit != 0 && new_pac_limit != undefined) {\n    var msg1 = {};\n    msg1.payload = {\n        'value': new_pac_limit,\n        'fc': 6,\n        'unitid': 1,\n        'address': new_pac_limit_Reg_id,\n        'quantity': 1,\n        'datatype': new_pac_limit_Reg_type,\n        'operation': 'write'\n    };\n    msg1.topic = {topic:msg.payload[0].topic}\n    node.send(msg1);\n}\n\n\n if (old_qac_limit != new_qac_limit && new_qac_limit != undefined) {\n     const decimalValue = new_qac_limit;\n     var msg2 = {};\n     msg2.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_qac_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_qac_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg2.topic = {topic:msg.payload[0].topic}\n     node.send(msg2);\n }\n\n\n if (old_pf_limit != new_pf_limit && new_pf_limit != 0 && new_pf_limit != undefined) {\n     const decimalValue = new_pf_limit;\n     var msg3 = {};\n     msg3.payload = {\n         \"value\": decimalValue,\n         'fc': 6,\n         'unitid': 1,\n         'address': new_pf_limit_Reg_id,\n         'quantity': 1,\n         'datatype': new_pf_limit_Reg_type,\n         'operation': 'write'\n     };\n     msg3.topic = {topic:msg.payload[0].topic}\n     node.send(msg3);\n }\n\n\n\n\n//msg.payload = { new: new_pac_limit, old: old_pac_limit, sel: SEL_PC_RX, pac: PAC_ON_OFF_1}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 888,
        "y": 2760,
        "wires": [
            [
                "6456157a05b8f73a",
                "5f98fb050cf0c3fa"
            ]
        ]
    },
    {
        "id": "caa8568617b6ea0b",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 78",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 898,
        "y": 2720,
        "wires": []
    },
    {
        "id": "529720555b0314fb",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 79",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1358,
        "y": 2760,
        "wires": []
    },
    {
        "id": "21a74056c0e79747",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 80",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 738,
        "y": 2720,
        "wires": []
    },
    {
        "id": "697dcb4ba861a6da",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 81",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 878,
        "y": 2880,
        "wires": []
    },
    {
        "id": "046124e69ba20f6a",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "global set",
        "func": "if (msg.payload) {\n\n    var pac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_PAC_LIMIT\"\n    var qac_field = msg.topic[0].b + \".\" + msg.topic[0].d + \".\" + \"OLD_QAC_LIMIT\"\n    var new_pac_limit = msg.payload.value[2]\n    var new_qac_limit = msg.payload.value[4]\n    global.set(pac_field, new_pac_limit);\n    global.set(qac_field, new_qac_limit);\n\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1118,
        "y": 2860,
        "wires": [
            [
                "5c3124f3dbc30e84"
            ]
        ]
    },
    {
        "id": "6456157a05b8f73a",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 82",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1118,
        "y": 2760,
        "wires": []
    },
    {
        "id": "8ca86e225b39fcc9",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 320,
        "wires": []
    },
    {
        "id": "75b30ecda2170b3f",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 2100,
        "wires": []
    },
    {
        "id": "970093ac95da7dfd",
        "type": "interval",
        "z": "80362ddefbe410fa",
        "name": "interval",
        "interval": "500",
        "onstart": false,
        "msg": "msg.payload",
        "showstatus": true,
        "unit": "milliseconds",
        "statusformat": "YYYY-MM-D HH:mm:ss",
        "x": 90,
        "y": 2080,
        "wires": [
            [
                "257560a04a2bc470",
                "d915c9c1a6d72b81",
                "851107da290de35c"
            ]
        ]
    },
    {
        "id": "bafd8acf98bac728",
        "type": "function",
        "z": "80362ddefbe410fa",
        "name": "function 1",
        "func": "global.set(\"RM_COMM.B50.INV01\",2)\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "82955d7a5229f76e",
        "type": "inject",
        "z": "80362ddefbe410fa",
        "name": "",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 90,
        "y": 180,
        "wires": [
            [
                "bafd8acf98bac728"
            ]
        ]
    },
    {
        "id": "732e9424768309aa",
        "type": "debug",
        "z": "80362ddefbe410fa",
        "name": "debug 6",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1120,
        "y": 2900,
        "wires": []
    }
]